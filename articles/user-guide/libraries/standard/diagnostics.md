---
title: Q#Standart kitaplıklarda tanılama
description: Q#Standart kitaplıklarda bulunan ve hisse ve hataların hatalarını yakalamak için kullanılan tanılama işlevleri ve işlemleri hakkında bilgi edinin.
author: cgranade
uid: microsoft.quantum.libraries.diagnostics
ms.author: chgranad
ms.topic: conceptual
no-loc:
- Q#
- $$v
ms.openlocfilehash: d13122187a24893d297cfdbb3ad4db03eb22ded0
ms.sourcegitcommit: 71605ea9cc630e84e7ef29027e1f0ea06299747e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 01/26/2021
ms.locfileid: "98858691"
---
# <a name="diagnostics"></a><span data-ttu-id="30748-103">Tanılama</span><span class="sxs-lookup"><span data-stu-id="30748-103">Diagnostics</span></span> #

<span data-ttu-id="30748-104">Klasik geliştirmede olduğu gibi, hisse ve hata programlarındaki hataları ve hataları tanılamanıza de bilmek önemlidir.</span><span class="sxs-lookup"><span data-stu-id="30748-104">As with classical development, it is important to be able to diagnose mistakes and errors in quantum programs.</span></span>
<span data-ttu-id="30748-105">Q#Standart kitaplıklar, bölümünde açıklandığı gibi hisse programlarının doğruluğunu sağlamak için çeşitli yollar sağlar <xref:microsoft.quantum.guide.testingdebugging> .</span><span class="sxs-lookup"><span data-stu-id="30748-105">The Q# standard libraries provide a variety of different ways to ensure the correctness of quantum programs, as detailed in <xref:microsoft.quantum.guide.testingdebugging>.</span></span>
<span data-ttu-id="30748-106">Büyük ölçüde konuşuyor, bu destek, hedef makineye ana bilgisayar programına veya geliştiriciye ek tanılama bilgileri sağlamasını belirten işlev ve işlemler biçiminde gelir veya işlev ya da işlem çağrısıyla ifade edilen koşulların ve varyantların doğruluğunu zorunlu kılar.</span><span class="sxs-lookup"><span data-stu-id="30748-106">Largely speaking, this support comes in the form of functions and operations that either instruct the target machine to provide additional diagnostic information to the host program or developer, or enforce the correctness of conditions and invariants expressed by the function or operation call.</span></span>

## <a name="machine-diagnostics"></a><span data-ttu-id="30748-107">Makine tanılama</span><span class="sxs-lookup"><span data-stu-id="30748-107">Machine Diagnostics</span></span> ##

<span data-ttu-id="30748-108">Klasik değerler hakkında tanılama, <xref:Microsoft.Quantum.Intrinsic.Message> bir iletiyi makineye bağlı bir şekilde günlüğe kaydetmek için işlevi kullanılarak elde edilebilir.</span><span class="sxs-lookup"><span data-stu-id="30748-108">Diagnostics about classical values can be obtained by using the <xref:Microsoft.Quantum.Intrinsic.Message> function to log a message in a machine-dependent way.</span></span>
<span data-ttu-id="30748-109">Varsayılan olarak, bu dizeyi konsola yazar.</span><span class="sxs-lookup"><span data-stu-id="30748-109">By default, this writes the string to the console.</span></span>
<span data-ttu-id="30748-110">Enterpolasyonlu dizeler ile birlikte kullanıldığında, <xref:Microsoft.Quantum.Intrinsic.Message> Klasik değerler hakkında tanılama bilgilerini rapor etmelerini kolaylaştırır:</span><span class="sxs-lookup"><span data-stu-id="30748-110">Used together with interpolated strings, <xref:Microsoft.Quantum.Intrinsic.Message> makes it easy to report diagnostic information about classical values:</span></span>

```qsharp
let angle = Microsoft.Quantum.Math.PI() * 2.0 / 3.0;
Message($"About to rotate by an angle of {angle}...");
```

> [!NOTE]
> <span data-ttu-id="30748-111">`Message` imza içerir `(String -> Unit)` ve bir hata ayıklama günlüğü iletisinin yayılamıyor olduğunu temsil eder Q# .</span><span class="sxs-lookup"><span data-stu-id="30748-111">`Message` has signature `(String -> Unit)`, again representing that emitting a debug log message cannot be observed from within Q#.</span></span>

<span data-ttu-id="30748-112"><xref:Microsoft.Quantum.Diagnostics.DumpMachine>Ve <xref:Microsoft.Quantum.Diagnostics.DumpRegister> callables, hedef makinelere, geçerli olarak ayrılmış olan tüm qubits ve sırasıyla belirli bir qubit kaydı hakkında tanılama bilgileri sağlar.</span><span class="sxs-lookup"><span data-stu-id="30748-112">The <xref:Microsoft.Quantum.Diagnostics.DumpMachine> and <xref:Microsoft.Quantum.Diagnostics.DumpRegister> callables instruct target machines to provide diagnostic information about all currently allocated qubits or about a specific register of qubits, respectively.</span></span>
<span data-ttu-id="30748-113">Her bir hedef makine, bir döküm yönergesine yanıt olarak hangi tanılama bilgilerinin sağlandığını farklılık gösterir.</span><span class="sxs-lookup"><span data-stu-id="30748-113">Each target machine varies in what diagnostic information is provided in response to a dump instruction.</span></span>
<span data-ttu-id="30748-114">Örneğin, [tam durum simülatörü](xref:microsoft.quantum.machines.full-state-simulator) hedef makinesi, ana bilgisayar programını, bir qubits 'in bir kaydını temsil etmek için dahili olarak kullandığı durum vektörünü sağlar.</span><span class="sxs-lookup"><span data-stu-id="30748-114">The [full state simulator](xref:microsoft.quantum.machines.full-state-simulator) target machine, for instance, provides the host program with the state vector that it uses internally to represent a register of qubits.</span></span>
<span data-ttu-id="30748-115">Karşılaştırmayla, [Toffoli simülatör](xref:microsoft.quantum.machines.toffoli-simulator) hedef makinesi her bir qubit için tek bir klasik bit sağlar.</span><span class="sxs-lookup"><span data-stu-id="30748-115">By comparison, the [Toffoli simulator](xref:microsoft.quantum.machines.toffoli-simulator) target machine provides a single classical bit for each qubit.</span></span>

 <span data-ttu-id="30748-116">[Tam durum simülatörü](xref:microsoft.quantum.machines.full-state-simulator) çıkışı hakkında daha fazla bilgi edinmek için `DumpMachine` [test ve hata ayıklama Makalemizin](xref:microsoft.quantum.guide.testingdebugging#dump-functions)döküm işlevleri bölümüne göz atın.</span><span class="sxs-lookup"><span data-stu-id="30748-116">To learn more about the [full state simulator's](xref:microsoft.quantum.machines.full-state-simulator) `DumpMachine` output, take a look at the dump functions section of our [testing and debugging article](xref:microsoft.quantum.guide.testingdebugging#dump-functions).</span></span>


## <a name="facts-and-assertions"></a><span data-ttu-id="30748-117">Olgular ve Onaylamalar</span><span class="sxs-lookup"><span data-stu-id="30748-117">Facts and Assertions</span></span> ##

<span data-ttu-id="30748-118">[Test ve hata ayıklama](xref:microsoft.quantum.guide.testingdebugging)bölümünde açıklandığı gibi, imzasına veya sırasıyla bir işlev veya işlem `Unit -> Unit` `Unit => Unit` *birim testi* olarak işaretlenebilir.</span><span class="sxs-lookup"><span data-stu-id="30748-118">As discussed in [Testing and Debugging](xref:microsoft.quantum.guide.testingdebugging), a function or operation with signature `Unit -> Unit` or `Unit => Unit`, respectively, can be marked as a *unit test*.</span></span>
<span data-ttu-id="30748-119">Her birim testi genellikle küçük bir hisse programından ve bu programın doğruluğunu kontrol eden bir veya daha fazla koşuldan oluşur.</span><span class="sxs-lookup"><span data-stu-id="30748-119">Each unit test generally consists of a small quantum program, along with one or more conditions that check the correctness of that program.</span></span>
<span data-ttu-id="30748-120">Bu _koşullar, giriş_ olarak geçirilen bir veya daha fazla qubit 'in durumlarını kontrol eden her iki _olgu_ biçiminde gelebilir.</span><span class="sxs-lookup"><span data-stu-id="30748-120">These conditions can come in the form of either _facts_, which check the values of their inputs, or _assertions_, which check the states of one or more qubits passed as input.</span></span>

<span data-ttu-id="30748-121">Örneğin, `EqualityFactI(1 + 1, 2, "1 + 1 != 2")` $1 + 1 = $2 olan matematiksel olguyu temsil ederken, `AssertQubit(One, qubit)` `qubit` ölçüyle bir belirsizlik döndüren koşulu temsil eder `One` .</span><span class="sxs-lookup"><span data-stu-id="30748-121">For example, `EqualityFactI(1 + 1, 2, "1 + 1 != 2")` represents the mathematical fact that $1 + 1 = 2$, while `AssertQubit(One, qubit)` represents the condition that measuring `qubit` will return a `One` with certainty.</span></span>
<span data-ttu-id="30748-122">Önceki durumda, koşulun yalnızca kendi değerleri verilen değerini denetliyoruz, ikincisi de onaylaması değerlendirmek için qubit durumu hakkında bir şeyler bilmelidir.</span><span class="sxs-lookup"><span data-stu-id="30748-122">In the former case, we can check the correctness of the condition given only its values, while in the latter, we must know something about the state of the qubit in order to evaluate the assertion.</span></span>

<span data-ttu-id="30748-123">Q#Standart kitaplıklar, olguları temsil etmek için çeşitli farklı işlevler sağlar; örneğin:</span><span class="sxs-lookup"><span data-stu-id="30748-123">The Q# standard libraries provide several different functions for representing facts, including:</span></span>

- <xref:Microsoft.Quantum.Diagnostics.Fact>
- <xref:Microsoft.Quantum.Diagnostics.EqualityWithinToleranceFact>
- <xref:Microsoft.Quantum.Diagnostics.NearEqualityFactC>
- <xref:Microsoft.Quantum.Diagnostics.EqualityFactI>


### <a name="testing-qubit-states"></a><span data-ttu-id="30748-124">Qubit durumlarını test etme</span><span class="sxs-lookup"><span data-stu-id="30748-124">Testing Qubit States</span></span> ###

<span data-ttu-id="30748-125">Pratikte, onaylamalar, gerçek makinemiz için bir simülatör kullanırken fiziksel ölçümleri ve onaylamaları yapabilmemiz gibi, tüm hisse uygun olmayan ölçümleri ve kayıt kaldırma işlemlerini [hiçbir](https://arxiv.org/abs/quant-ph/9607018)şekilde etkilemez.</span><span class="sxs-lookup"><span data-stu-id="30748-125">In practice, assertions rely on the fact that classical simulations of quantum mechanics need not obey the [no-cloning theorem](https://arxiv.org/abs/quant-ph/9607018), such that we can make unphysical measurements and assertions when using a simulator for our target machine.</span></span>
<span data-ttu-id="30748-126">Bu nedenle, donanıma dağıtım yapmadan önce tek tek işlemleri klasik Benzetici üzerinde test edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="30748-126">Thus, we can test individual operations on a classical simulator before deploying on hardware.</span></span>
<span data-ttu-id="30748-127">Onayların değerlendirmesine izin verilmeyen hedef makinelerde, çağrıları <xref:Microsoft.Quantum.Diagnostics.AssertMeasurement> güvenle yoksayılabilir.</span><span class="sxs-lookup"><span data-stu-id="30748-127">On target machines which do not allow evaluation of assertions, calls to <xref:Microsoft.Quantum.Diagnostics.AssertMeasurement> can be safely ignored.</span></span>

<span data-ttu-id="30748-128">Daha genel olarak, <xref:Microsoft.Quantum.Diagnostics.AssertMeasurement> işlem, verilen pabdtabanında verilen qubits 'leri ölçmeye her zaman verilen sonuca sahip olacağını onaylar.</span><span class="sxs-lookup"><span data-stu-id="30748-128">More generally, the <xref:Microsoft.Quantum.Diagnostics.AssertMeasurement> operation asserts that measuring the given qubits in the given Pauli basis will always have the given result.</span></span>
<span data-ttu-id="30748-129">Onaylama başarısız olursa, çalıştırma, belirtilen iletiyle çağırarak sona erer `fail` .</span><span class="sxs-lookup"><span data-stu-id="30748-129">If the assertion fails, the run ends by calling `fail` with the given message.</span></span>
<span data-ttu-id="30748-130">Varsayılan olarak, bu işlem uygulanmaz; Bunu destekleyebilen simülatörleri, çalışma zamanı denetimini gerçekleştiren bir uygulama sağlamalıdır.</span><span class="sxs-lookup"><span data-stu-id="30748-130">By default, this operation is not implemented; simulators that can support it should provide an implementation that performs runtime checking.</span></span>
<span data-ttu-id="30748-131">`AssertMeasurement` imza içeriyor `((Pauli[], Qubit[], Result, String) -> ())` .</span><span class="sxs-lookup"><span data-stu-id="30748-131">`AssertMeasurement` has signature `((Pauli[], Qubit[], Result, String) -> ())`.</span></span>
<span data-ttu-id="30748-132">`AssertMeasurement`, Çıkış türü olarak boş bir tanımlama grubu olan bir işlev olduğundan, çağrılmasından hiçbir efekt `AssertMeasurement` bir program içinde observable değildir Q# .</span><span class="sxs-lookup"><span data-stu-id="30748-132">Since `AssertMeasurement` is a function with an empty tuple as its output type, no effects from having called `AssertMeasurement` are observable within a Q# program.</span></span>

<span data-ttu-id="30748-133"><xref:Microsoft.Quantum.Diagnostics.AssertMeasurementProbability>İşlem işlevi, verilen pabdtabanında verilen qubits 'in belirli bir tolerans dahilinde verilen olasılığa sahip olduğunu ölçmeye yönelik onaylar.</span><span class="sxs-lookup"><span data-stu-id="30748-133">The <xref:Microsoft.Quantum.Diagnostics.AssertMeasurementProbability> operation function asserts that measuring the given qubits in the given Pauli basis will have the given result with the given probability, within some tolerance.</span></span>
<span data-ttu-id="30748-134">Tolerans eklenebilir (örneğin, `abs(expected-actual) < tol` ).</span><span class="sxs-lookup"><span data-stu-id="30748-134">Tolerance is additive (for example, `abs(expected-actual) < tol`).</span></span>
<span data-ttu-id="30748-135">Onaylama başarısız olursa, çalıştırma, belirtilen iletiyle çağırarak sona erer `fail` .</span><span class="sxs-lookup"><span data-stu-id="30748-135">If the assertion fails, the run ends by calling `fail` with the given message.</span></span>
<span data-ttu-id="30748-136">Varsayılan olarak, bu işlem uygulanmaz; Bunu destekleyebilen simülatörleri, çalışma zamanı denetimini gerçekleştiren bir uygulama sağlamalıdır.</span><span class="sxs-lookup"><span data-stu-id="30748-136">By default, this operation is not implemented; simulators that can support it should provide an implementation that performs runtime checking.</span></span>
<span data-ttu-id="30748-137">`AssertMeasurementProbability` imza içeriyor `((Pauli[], Qubit[], Result, Double, String, Double) -> Unit)` .</span><span class="sxs-lookup"><span data-stu-id="30748-137">`AssertMeasurementProbability` has signature `((Pauli[], Qubit[], Result, Double, String, Double) -> Unit)`.</span></span> <span data-ttu-id="30748-138">`Double`Parametrelerin ilki, sonucun istenen olasılığını ve ikinci bir toleransı sağlar.</span><span class="sxs-lookup"><span data-stu-id="30748-138">The first of `Double` parameters gives the desired probability of the result, and the second one the tolerance.</span></span>

<span data-ttu-id="30748-139">Tek bir ölçüm için bir Benzetici tarafından kullanılan klasik bilgilerin, bir qubit 'in iç durumunu temsil etmesi için kullanılan klasik bilgilerin kopyalanmaya, bu şekilde, fiticimizi test etmek için bir ölçüm gerçekleştirmeleri gerekmez.</span><span class="sxs-lookup"><span data-stu-id="30748-139">We can do more than assert a single measurement, using that the classical information used by a simulator to represent the internal state of a qubit is amenable to copying, such that we do not need to actually perform a measurement to test our assertion.</span></span>
<span data-ttu-id="30748-140">Özellikle, bu, gerçek donanım üzerinde mümkün olmayan, *uyumsuz* ölçümler hakkında nedenimizi olanaklı kılmaktadır.</span><span class="sxs-lookup"><span data-stu-id="30748-140">In particular, this allows us to reason about *incompatible* measurements that would be impossible on actual hardware.</span></span>

<span data-ttu-id="30748-141">`P : Qubit => Unit`Girişi $ \ket $ durumunda olduğunda $ \ket{\psı} $ durumunun hazırlanması amaçlanan bir işlem olduğunu varsayalım {0} .</span><span class="sxs-lookup"><span data-stu-id="30748-141">Suppose that `P : Qubit => Unit` is an operation intended to prepare the state $\ket{\psi}$ when its input is in the state $\ket{0}$.</span></span>
<span data-ttu-id="30748-142">Let $ \ket{\psı '} $ tarafından hazırlanan gerçek eyalet olmalıdır `P` .</span><span class="sxs-lookup"><span data-stu-id="30748-142">Let $\ket{\psi'}$ be the actual state prepared by `P`.</span></span>
<span data-ttu-id="30748-143">Ardından, $ \ket{\psı} = \ket{\psı '} $ ise ve yalnızca $ \ket{\psı} $ tarafından tanımlanan eksende $ \ket{\psı '} $ her zaman döndürülür `Zero` .</span><span class="sxs-lookup"><span data-stu-id="30748-143">Then, $\ket{\psi} = \ket{\psi'}$ if and only if measuring $\ket{\psi'}$ in the axis described by $\ket{\psi}$ always returns `Zero`.</span></span>
<span data-ttu-id="30748-144">Diğer bir deyişle, \begin{hizalaması} \ket{\psı} = \ket{\psı '} \Text{IF ve yalnızca If} \braket{\psı | \psı '} = 1.</span><span class="sxs-lookup"><span data-stu-id="30748-144">That is, \begin{align} \ket{\psi} = \ket{\psi'} \text{ if and only if } \braket{\psi | \psi'} = 1.</span></span>
<span data-ttu-id="30748-145">\end{hizalaması} Prelude tanımlanan temel işlemleri kullanarak, `Zero` $ \ket{\psı} $ Pauli işleçlerinden birinin eigenstate olması durumunda, döndüren bir ölçümü doğrudan gerçekleştirebiliriz.</span><span class="sxs-lookup"><span data-stu-id="30748-145">\end{align} Using the primitive operations defined in the prelude, we can directly perform a measurement that returns `Zero` if $\ket{\psi}$ is an eigenstate of one of the Pauli operators.</span></span>


<span data-ttu-id="30748-146">Bu işlem, <xref:Microsoft.Quantum.Diagnostics.AssertQubit> < \ket{\psı} = \ket $ onayını test etmek istediğimiz için özellikle yararlı bir Özet sağlar {0} .</span><span class="sxs-lookup"><span data-stu-id="30748-146">The operation <xref:Microsoft.Quantum.Diagnostics.AssertQubit> provides a particularly useful shorthand to do so in the case that we wish to test the assertion $\ket{\psi} = \ket{0}$.</span></span>
<span data-ttu-id="30748-147">Bu, örneğin, {0} serbest bırakıldığımızda, serbest bırakmadan önce $ \ket $ ' e geri dönmek için hesaplandığımız zaman yaygındır.</span><span class="sxs-lookup"><span data-stu-id="30748-147">This is common, for instance, when we have uncomputed to return ancilla qubits to $\ket{0}$ before releasing them.</span></span>
<span data-ttu-id="30748-148">$ \Ket {0} $ ' e karşı onaylama, iki durum hazırlığı `P` ve `Q` işlemlerinin her ikisinin de aynı durumu hazırlanmasını ve ne zaman `Q` desteklenmesini sağlamak için de yararlıdır `Adjoint` .</span><span class="sxs-lookup"><span data-stu-id="30748-148">Asserting against $\ket{0}$ is also useful when we wish to assert that two state preparation `P` and `Q` operations both prepare the same state, and when `Q` supports `Adjoint`.</span></span>
<span data-ttu-id="30748-149">Özellikle,</span><span class="sxs-lookup"><span data-stu-id="30748-149">In particular,</span></span>

```qsharp
using (register = Qubit()) {
    P(register);
    Adjoint Q(register);

    AssertQubit(Zero, register);
}
```

<span data-ttu-id="30748-150">Ancak genel olarak, Pauli işleçlerinin eigenstates ile aynı olmayan durumlar hakkında onaylara erişemeyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="30748-150">More generally, however, we may not have access to assertions about states that do not coincide with eigenstates of Pauli operators.</span></span>
<span data-ttu-id="30748-151">Örneğin, $ \ket{\psı} = (\ket {0} + e ^ {i \pi/8} \ket {1} )/\sqrt {2} $, bir Pauli işlecinin eigenstate değil; bu nedenle, <xref:Microsoft.Quantum.Diagnostics.AssertMeasurementProbability> bir State $ \ket{\psı '} $ öğesinin $ \ket{\psı} $ değerine eşit olduğunu benzersiz şekilde tespit etmek için kullandığımyız.</span><span class="sxs-lookup"><span data-stu-id="30748-151">For example, $\ket{\psi} = (\ket{0} + e^{i \pi / 8} \ket{1}) / \sqrt{2}$ is not an eigenstate of any Pauli operator, such that we cannot use <xref:Microsoft.Quantum.Diagnostics.AssertMeasurementProbability> to uniquely determine that a state $\ket{\psi'}$ is equal to $\ket{\psi}$.</span></span>
<span data-ttu-id="30748-152">Bunun yerine, simülatımız tarafından desteklenen temel elemanlar kullanılarak doğrudan sınanabilen varsayımlar halinde $ \ket{\psı '} = \ket{\psi} $ onaylama onayını kaldırdık.</span><span class="sxs-lookup"><span data-stu-id="30748-152">Instead, we must decompose the assertion $\ket{\psi'} = \ket{\psi}$ into assumptions that can be directly tested using  the primitives supported by our simulator.</span></span>
<span data-ttu-id="30748-153">Bunu yapmak için $ \ket{\psı} = \Alpha {0} \tus+ \beta \ demet $ ' i {1} karmaşık sayılar için $ \Alpha = a \_ r + a \_ i i $ ve $ \beta $ $.</span><span class="sxs-lookup"><span data-stu-id="30748-153">To do so, let $\ket{\psi} = \alpha \ket{0} + \beta \ket{1}$ for complex numbers $\alpha = a\_r + a\_i i$ and $\beta$.</span></span>
<span data-ttu-id="30748-154">Bu ifadenin, \{ \_ \_ \_ \_ \} her bir karmaşık sayının gerçek ve sanal bir parçanın toplamı olarak ifade edileceği dört gerçek sayı olan $ a r, ı, b r, b i $ değerini belirtmesini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="30748-154">Note that this expression requires four real numbers $\{a\_r, a\_i, b\_r, b\_i\}$ to specify, as each complex number can be expressed as the sum of a real and imaginary part.</span></span>
<span data-ttu-id="30748-155">Ancak genel aşama nedeniyle, \_ tek bir tek qubit durumu belirtmek için yalnızca üç gerçek numaraya ihtiyacımız olacak şekilde $a i = $0 ' i seçebiliriz.</span><span class="sxs-lookup"><span data-stu-id="30748-155">Due to the global phase, however, we can choose $a\_i = 0$, such that we only need three real numbers to uniquely specify a single-qubit state.</span></span>

<span data-ttu-id="30748-156">Bu nedenle, beklediğimiz durumu belirlemek için birbirinden bağımsız olan üç onay belirtmemiz gerekir.</span><span class="sxs-lookup"><span data-stu-id="30748-156">Thus, we need to specify three assertions which are independent of each other in order to assert the state that we expect.</span></span>
<span data-ttu-id="30748-157">Bu `Zero` , $ \Alpha $ ve $ \beta $ ' ya verilen her Pauli ölçümü için gözlemleme olasılığını bularak her birini ayrı ayrı ele aldık.</span><span class="sxs-lookup"><span data-stu-id="30748-157">We do so by finding the probability of observing `Zero` for each Pauli measurement given $\alpha$ and $\beta$, and asserting each independently.</span></span>
<span data-ttu-id="30748-158">`Result`Sırasıyla Pauli $X $, $Y $ ve $Z $ ölçümleri için $x $, $y $ ve $z $ değerlerinin olmasına izin verin.</span><span class="sxs-lookup"><span data-stu-id="30748-158">Let $x$, $y$, and $z$ be `Result` values for Pauli $X$, $Y$, and $Z$ measurements respectively.</span></span>
<span data-ttu-id="30748-159">Ardından, hisse ölçümlerine yönelik olasılık işlevini kullanarak \begin{hizalaması} \Pr (x = \Texttt{dd} | \Alpha, \beta) & = \frac12 + a \_ r b \_ r + a \_ ı b \_ ı \\ \\ \Pr (y = \Texttt{dd} | \alpha, \beta) & = \frac12 + a \_ r b \_ ı-a \_ ı b \_ r \\ \\ \pr (z = \texttt{dd} | \Alpha, \beta) & = \frac12\left (1 + a r ^ 2 + a i ^ 2 + b \_ \_ \_ r ^ 2 + b \_ i ^ 2 \ sağda).</span><span class="sxs-lookup"><span data-stu-id="30748-159">Then, using the likelihood function for quantum measurements, \begin{align} \Pr(x = \texttt{Zero} | \alpha, \beta) & = \frac12 + a\_r b\_r + a\_i b\_i \\\\ \Pr(y = \texttt{Zero} | \alpha, \beta) & = \frac12 + a\_r b\_i - a\_i b\_r \\\\ \Pr(z = \texttt{Zero} | \alpha, \beta) & = \frac12\left( 1 + a\_r^2 + a\_i^2 + b\_r^2 + b\_i^2 \right).</span></span>
<span data-ttu-id="30748-160">\end{hizalaması}</span><span class="sxs-lookup"><span data-stu-id="30748-160">\end{align}</span></span>

<span data-ttu-id="30748-161"><xref:Microsoft.Quantum.Diagnostics.AssertQubitIsInStateWithinTolerance>İşlem bu onaylamaları, $ \Alpha $ ve $ \beta $ ' ın tür değerleri olarak verilen gösterimlerine uygular <xref:Microsoft.Quantum.Math.Complex> .</span><span class="sxs-lookup"><span data-stu-id="30748-161">The <xref:Microsoft.Quantum.Diagnostics.AssertQubitIsInStateWithinTolerance> operation implements these assertions given representations of $\alpha$ and $\beta$ as values of type <xref:Microsoft.Quantum.Math.Complex>.</span></span>
<span data-ttu-id="30748-162">Beklenen durum matematik olarak hesaplanabileceğinden bu faydalıdır.</span><span class="sxs-lookup"><span data-stu-id="30748-162">This is helpful when the expected state can be computed mathematically.</span></span>

### <a name="asserting-equality-of-quantum-operations"></a><span data-ttu-id="30748-163">Hisse Işlemlerinin eşitliğini ele</span><span class="sxs-lookup"><span data-stu-id="30748-163">Asserting Equality of Quantum Operations</span></span> ###

<span data-ttu-id="30748-164">Bu nedenle, belirli durumları hazırlamaya yönelik test işlemleriyle ilgilentik.</span><span class="sxs-lookup"><span data-stu-id="30748-164">Thus far, we have been concerned with testing operations which are intended to prepare particular states.</span></span>
<span data-ttu-id="30748-165">Ancak, genellikle bir işlemin tek bir sabit giriş yerine rastgele girişler için nasıl davrandığını öğreniyoruz.</span><span class="sxs-lookup"><span data-stu-id="30748-165">Often, however, we are interested in how an operation acts for arbitrary inputs rather than for a single fixed input.</span></span>
<span data-ttu-id="30748-166">Örneğin, `U : ((Double, Qubit[]) => () : Adjoint)` bir dizi Unitary işleçlerine karşılık gelen bir işlemi uyguladığımızda $U (t) $, ve kullanmak yerine açık bir blok sağladık `adjoint` `adjoint auto` .</span><span class="sxs-lookup"><span data-stu-id="30748-166">For example, suppose we have implemented an operation `U : ((Double, Qubit[]) => () : Adjoint)` corresponding to a family of unitary operators $U(t)$, and have provided an explicit `adjoint` block instead of using `adjoint auto`.</span></span>
<span data-ttu-id="30748-167">$T $ bir evlenme süresini temsil ediyorsa, bu $U ^ \hanger (t) = U (-t) $, beklenen şekilde ilgileniyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="30748-167">We may be interested in asserting that $U^\dagger(t) = U(-t)$, as expected if $t$ represents an evolution time.</span></span>

<span data-ttu-id="30748-168">Genel anlamda, iki işlem ve aynı şekilde hareket eden onaylama yaparken izleyebilmemiz için iki farklı strateji vardır `U` `V` .</span><span class="sxs-lookup"><span data-stu-id="30748-168">Broadly speaking, there are two different strategies that we can follow in making the assertion that two operations `U` and `V` act identically.</span></span>
<span data-ttu-id="30748-169">İlk olarak, `U(target); (Adjoint V)(target);` her durumu belirli bir temelinde koruyan denetliyoruz.</span><span class="sxs-lookup"><span data-stu-id="30748-169">First, we can check that `U(target); (Adjoint V)(target);` preserves each state in a given basis.</span></span>
<span data-ttu-id="30748-170">İkincisi, `U(target); (Adjoint V)(target);` entangled 'in yarısı üzerinde işlem yapan bu entanglement 'i korur.</span><span class="sxs-lookup"><span data-stu-id="30748-170">Second, we can check that `U(target); (Adjoint V)(target);` acting on half of an entangled state preserves that entanglement.</span></span>
<span data-ttu-id="30748-171">Bu stratejiler, Canon işlemleri <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlace> ve <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualReferenced> sırasıyla uygulanır.</span><span class="sxs-lookup"><span data-stu-id="30748-171">These strategies are implemented by the canon operations <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlace> and <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualReferenced>, respectively.</span></span>

> [!NOTE]
> <span data-ttu-id="30748-172">Yukarıda açıklanan başvurulan onaylama, $n $ qubits üzerindeki işlemleri $2n $ qubits 'teki bir durum ile ilişkilendiren bir matematik çerçevesi olan [CHOI – Jamiłkowski isomorphism](https://en.wikipedia.org/wiki/Channel-state_duality)temel alınarak çalışmaktadır.</span><span class="sxs-lookup"><span data-stu-id="30748-172">The referenced assertion discussed above works based on the [Choi–Jamiłkowski isomorphism](https://en.wikipedia.org/wiki/Channel-state_duality), a mathematical framework which relates operations on $n$ qubits to entangled states on $2n$ qubits.</span></span>
> <span data-ttu-id="30748-173">Özellikle, $n $ qubits üzerindeki kimlik işlemi, entangled State $ \ket{\ beta_ {00} } \mathrel{: =} (\ket {00} + \ demet {11} )/\sqrt $ öğesinin $n $ kopyaları tarafından temsil edilir {2} .</span><span class="sxs-lookup"><span data-stu-id="30748-173">In particular, the identity operation on $n$ qubits is represented by $n$ copies of the entangled state $\ket{\beta_{00}} \mathrel{:=} (\ket{00} + \ket{11}) / \sqrt{2}$.</span></span>
> <span data-ttu-id="30748-174">Bu işlem <xref:Microsoft.Quantum.Preparation.PrepareChoiState> , belirli bir işlemi temsil eden bir durum hazırlarken bu isomorphism uygular.</span><span class="sxs-lookup"><span data-stu-id="30748-174">The operation <xref:Microsoft.Quantum.Preparation.PrepareChoiState> implements this isomorphism, preparing a state that represents a given operation.</span></span>

<span data-ttu-id="30748-175">Kabaca, bu stratejiler bir zaman alanına göre ayırt edilir: Space zorunluluğunu getirir.</span><span class="sxs-lookup"><span data-stu-id="30748-175">Roughly, these strategies are distinguished by a time–space tradeoff.</span></span>
<span data-ttu-id="30748-176">Her giriş durumu için yineleme ek zaman alır, ancak başvuru olarak entanglement kullanılması ek qubit depolanmasını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="30748-176">Iterating through each input state takes additional time, while using entanglement as a reference requires storing additional qubits.</span></span>
<span data-ttu-id="30748-177">Bir işlemin yalnızca hesaplama tabanlı durumlarıyla ilgili davranışını ilgilentireceğiz gibi, tersine çevrilebilir bir işlem uyguladığı durumlarda, <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlaceCompBasis> Bu kısıtlanmış giriş kümesinde eşitliği sınar.</span><span class="sxs-lookup"><span data-stu-id="30748-177">In cases where an operation implements a reversible classical operation, such that we are only interested in its behavior on computational basis states, <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlaceCompBasis> tests equality on this restricted set of inputs.</span></span>

> [!TIP]
> <span data-ttu-id="30748-178">Giriş durumları üzerindeki yineleme, numaralandırma işlemleri ve tarafından işlenir <xref:Microsoft.Quantum.Canon.IterateThroughCartesianProduct> <xref:Microsoft.Quantum.Canon.IterateThroughCartesianPower> .</span><span class="sxs-lookup"><span data-stu-id="30748-178">The iteration over input states is handled by the enumeration operations <xref:Microsoft.Quantum.Canon.IterateThroughCartesianProduct> and <xref:Microsoft.Quantum.Canon.IterateThroughCartesianPower>.</span></span>
> <span data-ttu-id="30748-179">Bu işlemler, iki veya daha fazla küme arasındaki Kartezyen ürünün her bir öğesine bir işlem uygulamak için daha genel bir seçenektir.</span><span class="sxs-lookup"><span data-stu-id="30748-179">These operations are useful more generally for applying an operation to each element of the Cartesian product between two or more sets.</span></span>

<span data-ttu-id="30748-180">Ancak, bu iki yaklaşımlar İnceleme altındaki işlemlerin farklı özelliklerini test etmek.</span><span class="sxs-lookup"><span data-stu-id="30748-180">More critically, however, the two approaches test different properties of the operations under examination.</span></span>
<span data-ttu-id="30748-181">Yerinde onaylama işlemi her bir işlemi birden çok kez çağırarak her giriş durumu için bir kez tüm rastgele seçimler ve ölçüm sonuçları çağrılar arasında değişebilir.</span><span class="sxs-lookup"><span data-stu-id="30748-181">Since the in-place assertion calls each operation multiple times, once for each input state, any random choices and measurement results might change between calls.</span></span>
<span data-ttu-id="30748-182">Buna karşılık, başvurulan onaylama her işlemi tam olarak bir kez çağırır. bu şekilde, işlemlerin *tek bir görüntüsündeki* eşit olduğunu kontrol eder.</span><span class="sxs-lookup"><span data-stu-id="30748-182">By contrast, the referenced assertion calls each operation exactly once, such that it checks that the operations are equal *in a single shot*.</span></span>
<span data-ttu-id="30748-183">Bu testlerin her ikisi de hisse programlarının doğruluğunu sağlamak için yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="30748-183">Both of these tests are useful in ensuring the correctness of quantum programs.</span></span>


## <a name="further-reading"></a><span data-ttu-id="30748-184">Daha Fazla Bilgi</span><span class="sxs-lookup"><span data-stu-id="30748-184">Further Reading</span></span> ##

- <xref:microsoft.quantum.guide.testingdebugging>
- <xref:Microsoft.Quantum.Diagnostics>
