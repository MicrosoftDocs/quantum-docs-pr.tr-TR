---
title: Standart kitaplıklardaki veri yapıları Q#
description: Microsoft standart kitaplıklarında veri yapıları, Oracles ve dinamik oluşturucuları hakkında bilgi edinin Q# .
author: QuantumWriter
uid: microsoft.quantum.libraries.data-structures
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
no-loc:
- Q#
- $$v
ms.openlocfilehash: 222fa7d0d33d4ac6c15e9ee9e6e97f380867a145
ms.sourcegitcommit: 6bf99d93590d6aa80490e88f2fd74dbbee8e0371
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 08/06/2020
ms.locfileid: "87868534"
---
# <a name="data-structures-and-modeling"></a><span data-ttu-id="6b2ab-103">Veri yapıları ve modelleme</span><span class="sxs-lookup"><span data-stu-id="6b2ab-103">Data Structures and Modeling</span></span> #

## <a name="classical-data-structures"></a><span data-ttu-id="6b2ab-104">Klasik veri yapıları</span><span class="sxs-lookup"><span data-stu-id="6b2ab-104">Classical Data Structures</span></span> ##

<span data-ttu-id="6b2ab-105">Diğer bir deyişle, örneğin, hisse kavramlarını temsil eden Kullanıcı tanımlı türlerin yanı sıra, Canon 'nin aynı zamanda, hisse sistemleri denetiminde kullanılan klasik verilerle çalışmaya yönelik işlemler, işlevler ve türler de sağlar.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-105">Along with user-defined types for representing quantum concepts, the canon also provides operations, functions, and types for working with classical data used in the control of quantum systems.</span></span>
<span data-ttu-id="6b2ab-106">Örneğin, <xref:microsoft.quantum.arrays.reversed> işlev bir diziyi girdi olarak alır ve ters sırada aynı diziyi döndürür.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-106">For instance, the <xref:microsoft.quantum.arrays.reversed> function takes an array as input and returns the same array in reverse order.</span></span>
<span data-ttu-id="6b2ab-107">Bu daha sonra, `Qubit[]` tamsayıların hisse gösterimi arasında dönüştürme yaparken gereksiz $ \operatorname{Swap} $ kapıları uygulamak zorunda kalmamak için türünde bir dizide kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-107">This can then be used on an array of type `Qubit[]` to avoid having to apply unnecessary $\operatorname{SWAP}$ gates when converting between quantum representations of integers.</span></span>
<span data-ttu-id="6b2ab-108">Benzer şekilde, önceki bölümde form türlerinin `(Int, Int -> T)` rastgele erişim koleksiyonlarını temsil eden yararlı olduğunu gördük. bu nedenle, <xref:microsoft.quantum.arrays.lookupfunction> işlev dizi türlerinden bu tür türleri oluşturmak için kullanışlı bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-108">Similarly, we saw in the previous section that types of the form `(Int, Int -> T)` can be useful for representing random access collections, so the <xref:microsoft.quantum.arrays.lookupfunction> function provides a convenient way of constructing such types from array types.</span></span>

### <a name="pairs"></a><span data-ttu-id="6b2ab-109">Çiftine</span><span class="sxs-lookup"><span data-stu-id="6b2ab-109">Pairs</span></span> ###

<span data-ttu-id="6b2ab-110">Canon, çiftler için işlevsel stil gösterimini destekler, bu, parçalanmaya göre tanımlama gruplarına erişme işlemi tamamlanır:</span><span class="sxs-lookup"><span data-stu-id="6b2ab-110">The canon supports functional-style notation for pairs, complementing accessing tuples by deconstruction:</span></span>

```qsharp
let pair = (PauliZ, register); // type (Pauli, Qubit[])
ApplyToEach(H, Snd(pair)); // No need to deconstruct to access the register.
```

### <a name="arrays"></a><span data-ttu-id="6b2ab-111">Diziler</span><span class="sxs-lookup"><span data-stu-id="6b2ab-111">Arrays</span></span> ###

<span data-ttu-id="6b2ab-112">Canon, dizileri işlemek için çeşitli işlevler sağlar.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-112">The canon provides several functions for manipulating arrays.</span></span>
<span data-ttu-id="6b2ab-113">Bu işlevler tür parametreli parametreleridir ve bu nedenle herhangi bir türdeki dizilerle birlikte kullanılabilir Q# .</span><span class="sxs-lookup"><span data-stu-id="6b2ab-113">These functions are type-parameterized, and thus can be used with arrays of any Q# type.</span></span>
<span data-ttu-id="6b2ab-114">Örneğin, işlevi, <xref:microsoft.quantum.arrays.reversed> öğeleri girişinden ters sırada olan yeni bir dizi döndürür.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-114">For instance, the <xref:microsoft.quantum.arrays.reversed> function returns a new array whose elements are in reverse order from its input.</span></span>
<span data-ttu-id="6b2ab-115">Bu işlem, işlemler çağrılırken bir hisse kayıt 'nın nasıl temsil edileceğini değiştirmek için kullanılabilir:</span><span class="sxs-lookup"><span data-stu-id="6b2ab-115">This can be used to change how a quantum register is represented when calling operations:</span></span>

```qsharp
let leRegister = LittleEndian(register);
// QFT expects a BigEndian, so we can reverse before calling.
QFT(BigEndian(Reversed(leRegister!)));
// This is how the LittleEndianAsBigEndian function is implemented:
QFT(LittleEndianAsBigEndian(leRegister));
```

<span data-ttu-id="6b2ab-116">Benzer şekilde, <xref:microsoft.quantum.arrays.subarray> işlevi bir dizinin öğelerinin alt kümelerini düzenlemek veya almak için kullanılabilir:</span><span class="sxs-lookup"><span data-stu-id="6b2ab-116">Similarly, the <xref:microsoft.quantum.arrays.subarray> function can be used to reorder or take subsets of the elements of an array:</span></span>

```qsharp
// Applies H to qubits 2 and 5.
ApplyToEach(H, Subarray([2, 5], register));
```

<span data-ttu-id="6b2ab-117">Flow denetimiyle birleştirildiğinde, gibi dizi işleme işlevleri, <xref:microsoft.quantum.arrays.zip> bir hızlı program Express için güçlü bir yol sağlayabilir:</span><span class="sxs-lookup"><span data-stu-id="6b2ab-117">When combined with flow control, array manipulation functions such as <xref:microsoft.quantum.arrays.zip> can provide a powerful way to express quantum programs:</span></span>

```qsharp
// Applies X₃ Y₁ Z₇ to a register of any size.
ApplyToEach(
    ApplyPauli(_, register),
    Map(
        EmbedPauli(_, _, Length(register)),
        Zip([PauliX, PauliY, PauliZ], [3, 1, 7])
    )
);
```

## <a name="oracles"></a><span data-ttu-id="6b2ab-118">Oracles</span><span class="sxs-lookup"><span data-stu-id="6b2ab-118">Oracles</span></span> ##

<span data-ttu-id="6b2ab-119">[Aşama tahmini](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm) ve [genliği](https://en.wikipedia.org/wiki/Amplitude_amplification) yükseltme belgelerinin bir Oracle kavramı sık görülen bir şekilde görünür.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-119">In the [phase estimation](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm) and [amplitude amplification](https://en.wikipedia.org/wiki/Amplitude_amplification) literature the concept of an oracle appears frequently.</span></span>
<span data-ttu-id="6b2ab-120">Burada Oracle terimi, bir qubits kümesi üzerinde davranan ve yanıtı bir aşama olarak döndüren bir kara kutu hisse alt yordamını ifade eder.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-120">Here the term oracle refers to a blackbox quantum subroutine that acts upon a set of qubits and returns the answer as a phase.</span></span>
<span data-ttu-id="6b2ab-121">Bu alt yordam, genellikle Oracle 'ı kabul eden bir hisse algoritması girişi olarak düşünülebilir, diğer parametrelere ek olarak bir dizi hisse ve bir dizi işlem uygular ve bu hisse için bir çağrı, temel bir geçit gibi bir çağrı sağlar.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-121">This subroutine often can be thought of as an input to a quantum algorithm that accepts the oracle, in addition to some other parameters, and applies a series of quantum operations and treating a call to this quantum subroutine as if it were a fundamental gate.</span></span>
<span data-ttu-id="6b2ab-122">Kuşkusuz, büyük algoritmayı gerçekten uygulamak için, Oracle 'ın, temel kapıların somut bir şekilde ayrıştırma sağlanması gerekir, ancak Oracle 'ı çağıran algoritmayı anlamak için bu ayrıştırma gerekmez.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-122">Obviously, in order to actually implement the larger algorithm a concrete decomposition of the oracle into fundamental gates must be provided but such a decomposition is not needed in order to understand the algorithm that calls the oracle.</span></span>
<span data-ttu-id="6b2ab-123">' De Q# , bu soyutlama, bu işlemler ilk sınıf değerlerdir, örneğin, işlemler bir siyah kutu ile hisse algoritması uygulamalarına geçirilebilirler.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-123">In Q#, this abstraction is represented by using that operations are first-class values, such that operations can be passed to implementations of quantum algorithms in a black-box manner.</span></span>
<span data-ttu-id="6b2ab-124">Ayrıca, Kullanıcı tanımlı türler, farklı Oracle temsillerini tür açısından güvenli bir şekilde etiketlemek için kullanılır. bu sayede, farklı siyah kutu işlemlerini yanlışlıkla daha kolay hale getirmeyi zorlaştırır.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-124">Moreover, user-defined types are used to label the different oracle representations in a type-safe way, making it difficult to accidentally conflate different kinds of black box operations.</span></span>

<span data-ttu-id="6b2ab-125">Bu tür Oracles, [Grover 'in arama](https://en.wikipedia.org/wiki/Grover%27s_algorithm) ve hisse simülasyonu algoritmaları gibi çok sayıda örnek de dahil olmak üzere çeşitli bağlamlarda görünür.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-125">Such oracles appear in a number of different contexts, including famous examples such as [Grover's search](https://en.wikipedia.org/wiki/Grover%27s_algorithm) and quantum simulation algorithms.</span></span>
<span data-ttu-id="6b2ab-126">Burada yalnızca iki uygulama için gerekli olan Oracles odaklanıyoruz: genliği ve aşama tahmini.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-126">Here we focus on the oracles needed for just two applications: amplitude amplification and phase estimation.</span></span>
<span data-ttu-id="6b2ab-127">İlk olarak, aşama tahmine geçmeden önce geniz Oracles ' i tartışacağız.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-127">We will first discuss amplitude amplification oracles before proceeding to phase estimation.</span></span>

### <a name="amplitude-amplification-oracles"></a><span data-ttu-id="6b2ab-128">Genliği yükseltme Oracles</span><span class="sxs-lookup"><span data-stu-id="6b2ab-128">Amplitude Amplification Oracles</span></span> ###

<span data-ttu-id="6b2ab-129">Genize yükseltme algoritması, durumun bir listesini uygulayarak bir başlangıç durumu ve nihai durum arasında bir döndürme gerçekleştirmeye kadar amaçlar.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-129">The amplitude amplification algorithm aims to perform a rotation between an initial state and a final state by applying a sequence of reflections of the state.</span></span>
<span data-ttu-id="6b2ab-130">Algoritmanın çalışması için, bu durumların her ikisinde de bir belirtime ihtiyacı vardır.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-130">In order for the algorithm to function, it needs a specification of both of these states.</span></span>
<span data-ttu-id="6b2ab-131">Bu belirtimler iki Oracles tarafından verilir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-131">These specifications are given by two oracles.</span></span>
<span data-ttu-id="6b2ab-132">Bu Oracles, girdileri iki boşlukla, bir "hedef" alt alanı ve bir "ilk" alt alanı ile kopararak çalışır.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-132">These oracles work by breaking the inputs into two spaces, a "target" subspace and an "initial" subspace.</span></span>
<span data-ttu-id="6b2ab-133">Oracles, bu boşluklara bir $ \pm $1 aşaması uygulayarak Pauli işleçlerinin iki boşluğu nasıl tanımladığından benzer şekilde, bu tür alt boşlukları belirler.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-133">The oracles identify such subspaces, similar to how Pauli operators identify two spaces, by applying a $\pm 1$ phase to these spaces.</span></span>
<span data-ttu-id="6b2ab-134">Temel fark, bu boşlukların bu uygulamada yarı boşluk olmaması gerektiğidir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-134">The main difference is that these spaces need not be half-spaces in this application.</span></span>
<span data-ttu-id="6b2ab-135">Ayrıca, bu iki alt boşlukların genellikle birbirini dışlamadığını unutmayın: her iki boşluğun üyesi olan vektörler olacaktır.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-135">Also note that these two subspaces are not usually mutually exclusive: there will be vectors that are members of both spaces.</span></span>
<span data-ttu-id="6b2ab-136">Bu doğru değilse, genliği bir etkiye sahip olmaz; bu nedenle, hedef alt alanla sıfır olmayan bir örtüşmeye sahip olması için ilk alt alana ihtiyacımız var.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-136">If this were not true then amplitude amplification would have no effect so we need the initial subspace to have non-zero overlap with the target subspace.</span></span>

<span data-ttu-id="6b2ab-137">Aşağıdaki eyleme sahip olacak şekilde, geniz 'nin $P $0 olması için gereken ilk Oracle \_ 'ı göstereceğiz.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-137">We will denote the first oracle that we need for amplitude amplification to be $P\_0$, defined to have the following action.</span></span>  <span data-ttu-id="6b2ab-138">"İlk" alt alanındaki tüm durumlar $ \ket{x} $ $P \_ 0 \ket{x} =-\ket{x} $ ve bu alt alanda olmayan tüm durumlar $ \ket{yı} $, $P \_ 0 \ iş {yı} = \ket{yı} $.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-138">For all states $\ket{x}$ in the "initial" subspace $P\_0 \ket{x} = -\ket{x}$ and for all states $\ket{y}$ that are not in this subspace we have $P\_0 \ket{y} = \ket{y}$.</span></span>
<span data-ttu-id="6b2ab-139">$P _1 $ olan hedef alt boşluğu işaretleyen Oracle, tam olarak aynı formu alır.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-139">The oracle that marks the target subspace, $P_1$, takes exactly the same form.</span></span>
<span data-ttu-id="6b2ab-140">Hedef alt alanda $ \ket{x} $ tüm durumlar için (örneğin, algoritmanın çıkışını yapmak istediğiniz tüm durumlar için) $P _1 \ ayraç {x} =-\ket{x} $.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-140">For all states $\ket{x}$ in the target subspace (i.e., for all states that you'd like the algorithm to output), $P_1\ket{x} = -\ket{x}$.</span></span>
<span data-ttu-id="6b2ab-141">Benzer şekilde, hedef alt alanda olmayan tüm durumlar $ \ket{yı} $ $P _1 \ demet {y} = \ket{yı} $.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-141">Similarly, for all states $\ket{y}$ that are not in the target subspace $P_1\ket{y} = \ket{y}$.</span></span>
<span data-ttu-id="6b2ab-142">Bu iki yansıma, daha sonra, genel eksi işaretinin yalnızca denetimli uygulamalarda dikkate alınması açısından önemli olduğu, $Q =-P_0 P_1 $ gibi tek bir genafme adımını sunan bir operatör oluşturacak şekilde birleştirilir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-142">These two reflections are then combined to form an operator that enacts a single step of amplitude amplification, $Q = -P_0 P_1$, where the overall minus sign is only important to consider in controlled applications.</span></span>
<span data-ttu-id="6b2ab-143">Genüme daha sonra ilk alt alanda bulunan bir ilk durum olan $ \ket{\psı} $, sonra da $ \ket{\psı} \mapsto Q ^ d \ket{\psı} $ yerine geçer.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-143">Amplitude amplification then proceeds by taking an initial state, $\ket{\psi}$ that is in the initial subspace and then performs $\ket{\psi} \mapsto Q^m \ket{\psi}$.</span></span>
<span data-ttu-id="6b2ab-144">Böyle bir yineleme gerçekleştirildiğinde, bir tane, işaretlenen boşluk ile çakışan $ \sin ^ 2 (\teta) $ olan bir başlangıç durumuyla başlıyorsa, bu örtüşme $m $ \sin ^ 2 ([2m + 1] \ teta) $ olur.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-144">Performing such an iteration guarantees that if one starts with an initial state that has overlap $\sin^2(\theta)$ with the marked space then after $m$ iterations this overlap becomes $\sin^2([2m + 1] \theta)$.</span></span>
<span data-ttu-id="6b2ab-145">Bu nedenle genellikle $ [2m + 1] \teta = \ pi/2 $; gibi ücretsiz bir parametre olmak üzere $m $ öğesini seçmek istiyoruz. Ancak, bu tür rigıd seçimleri, sabit noktalı genlama gibi bazı genlama için önemli değildir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-145">We therefore typically wish to choose $m$ to be a free parameter such that $[2m+1]\theta = \pi/2$; however, such rigid choices are not as important for some forms of amplitude amplification such as fixed point amplitude amplification.</span></span>
<span data-ttu-id="6b2ab-146">Bu işlem, işaretleme işlevine quadkıtik sorguları ve tam olarak klasik bir cihazda mümkün olduğunca durum hazırlama işlevini kullanarak işaretli alt alanda bir durum hazırlamanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-146">This process allows us to prepare a state in the marked subspace using quadratically fewer queries to the marking function and the state preparation function than would be possible on a strictly classical device.</span></span>
<span data-ttu-id="6b2ab-147">Bu nedenle, çok sayıda hisse bilgi işlem uygulaması için önemli bir yapı bloğu budur.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-147">This is why amplitude amplification is a significant building block for many applications of quantum computing.</span></span>

<span data-ttu-id="6b2ab-148">Algoritmanın nasıl kullanılacağını anlamak için, Oracles yapımı veren bir örnek sağlamak yararlı olur.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-148">In order to understand how to use the algorithm, it is useful to provide an example that gives a construction of the oracles.</span></span>  <span data-ttu-id="6b2ab-149">Bu ayarda, veritabanı aramaları için Grover 'in algoritmasını gerçekleştirmeyi düşünün.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-149">Consider performing Grover's algorithm for database searches in this setting.</span></span>
<span data-ttu-id="6b2ab-150">Grover 'in aramasında, amaç $ \ket{+} ^ {\otimes n} = H ^ {\otimes n} \tus$ ' i {0} (potansiyel) çok sayıda işaretlenmiş durumdan birine dönüştürmektir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-150">In Grover's search the goal is to transform the state $\ket{+}^{\otimes n} = H^{\otimes n} \ket{0}$ into one of (potentially) many marked states.</span></span>
<span data-ttu-id="6b2ab-151">Daha fazla basitleşmesi için yalnızca tek işaretli durumun $ \ket $ olduğu duruma göz atalım {0} .</span><span class="sxs-lookup"><span data-stu-id="6b2ab-151">To further simplify, let's just look at the case where the only marked state is $\ket{0}$.</span></span>
<span data-ttu-id="6b2ab-152">Daha sonra iki Oracles tasarlıyoruz: yalnızca başlangıç durumu $ \ket{+} ^ {\otimes n} $ değerini eksi işareti ile işaretleyen ve işaretli durum $ \ket $ değerini eksi işaretiyle işaretleyen bir tane {0} .</span><span class="sxs-lookup"><span data-stu-id="6b2ab-152">Then we have design two oracles: one that only marks the initial state $\ket{+}^{\otimes n}$ with a minus sign and another that marks the marked state $\ket{0}$ with a minus sign.</span></span>
<span data-ttu-id="6b2ab-153">İkinci ağ geçidi, Canon içindeki denetim akışı işlemleri kullanılarak aşağıdaki işlem işlemi kullanılarak uygulanabilir:</span><span class="sxs-lookup"><span data-stu-id="6b2ab-153">The latter gate can be implemented using the following process operation, by using the control flow operations in the canon:</span></span>

```qsharp
operation ReflectAboutAllZeros(register : Qubit[]) : Unit 
is Adj + Ctl {

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);

    // Apply an $n-1$ controlled $Z$-gate to the $n^{\text{th}}$ qubit.
    // This gate will lead to a sign flip if and only if every qubit is
    // $1$, which happens only if each of the qubits were $0$ before step 1.
    Controlled Z(Most(register), Tail(register));

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);
}
```

<span data-ttu-id="6b2ab-154">Bu Oracle daha sonra işlemin özel bir durumdur ve bu da <xref:microsoft.quantum.canon.rall1> , yansıma durumu $ \phi = \pı $ yerine rastgele bir aşamaya göre döndürmeyi sağlar.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-154">This oracle is then a special case of the <xref:microsoft.quantum.canon.rall1> operation, which allows for rotating by an arbitrary phase instead of the reflection case $\phi = \pi$.</span></span>
<span data-ttu-id="6b2ab-155">Bu durumda, `RAll1` <xref:microsoft.quantum.intrinsic.r1> Prelude işlemine benzerdir. Bu, tek qubit durumu $ \ket $ yerine $ \ket{11\cdots1} $ hakkında daha fazla döner {1} .</span><span class="sxs-lookup"><span data-stu-id="6b2ab-155">In this case, `RAll1` is similar to the <xref:microsoft.quantum.intrinsic.r1> prelude operation, in that it rotates about $\ket{11\cdots1}$ instead of the single-qubit state $\ket{1}$.</span></span>

<span data-ttu-id="6b2ab-156">İlk alt boşluğu işaretleyen Oracle, benzer şekilde oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-156">The oracle that marks the initial subspace can be constructed similarly.</span></span>
<span data-ttu-id="6b2ab-157">Sözde kod içinde:</span><span class="sxs-lookup"><span data-stu-id="6b2ab-157">In pseudocode:</span></span>

1. <span data-ttu-id="6b2ab-158">Her qubit 'e $H $ Gates uygulayın.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-158">Apply $H$ gates to every qubit.</span></span>
2. <span data-ttu-id="6b2ab-159">Her qubit 'e $X $ Gates uygulayın.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-159">Apply $X$ gates to every qubit.</span></span>
3. <span data-ttu-id="6b2ab-160">^ {\Text{TH}} $ qubit $n $n-$1 denetimli $Z $-Gate uygulayın.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-160">Apply an $n-1$ controlled $Z$-gate to the $n^{\text{th}}$ qubit.</span></span>
4. <span data-ttu-id="6b2ab-161">Her qubit 'e $X $ Gates uygulayın.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-161">Apply $X$ gates to every qubit.</span></span>
5. <span data-ttu-id="6b2ab-162">Her qubit 'e $H $ Gates uygulayın.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-162">Apply $H$ gates to every qubit.</span></span>

<span data-ttu-id="6b2ab-163">Bu kez, <xref:microsoft.quantum.canon.applywith> yukarıda açıklanan işlemle birlikte kullanmayı da göstermektedir <xref:microsoft.quantum.canon.rall1> :</span><span class="sxs-lookup"><span data-stu-id="6b2ab-163">This time, we also demonstrate using <xref:microsoft.quantum.canon.applywith> together with the <xref:microsoft.quantum.canon.rall1> operation discussed above:</span></span>

```qsharp
operation ReflectAboutInitial(register : Qubit[]) : Unit
is Adj + Ctl {
    ApplyWithCA(ApplyToEach(H, _), ApplyWith(ApplyToEach(X, _), RAll1(_, PI()), _), register);
}
```

<span data-ttu-id="6b2ab-164">Daha sonra iki durum arasında bir değer döndürmek için bu iki Oracles birlikte birleştirilebiliyoruz ve $ {0} \sqrt{2 ^ n} ile orantılı olan Hadamard Gates katman sayısını kullanarak $ \ket{+} ^ {\otimes n} $ to $ \tus$ olarak $ (ie $m \propto \sqrt{2 ^ n} $), {0} sonuç $0 $ gözlemlene kadar ilk durum hazırlanarak ve ölçerek $ \ket $ durumunun belirleyici olmayan şekilde hazırlanması için gereken kabaca $2 ^ n $ katman karşılaştırması.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-164">We can then combine these two oracles together to rotate between the two states and deterministically transform $\ket{+}^{\otimes n}$ to $\ket{0}$ using a number of layers of Hadamard gates that is proportional to $\sqrt{2^n}$ (ie $m\propto \sqrt{2^n}$) versus the roughly $2^n$ layers that would be needed to non-deterministically prepare the $\ket{0}$ state by preparing and measuring the initial state until the outcome $0$ is observed.</span></span>

### <a name="phase-estimation-oracles"></a><span data-ttu-id="6b2ab-165">Aşama tahmini Oracles</span><span class="sxs-lookup"><span data-stu-id="6b2ab-165">Phase Estimation Oracles</span></span> ###

<span data-ttu-id="6b2ab-166">Aşama tahmini için Oracles biraz daha doğal bir şekilde yapılır.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-166">For phase estimation the oracles are somewhat more natural.</span></span>
<span data-ttu-id="6b2ab-167">Aşama tahmini amacı, bir Unitary matrisin eigendeğerlerinden örneklenebilecek bir altyordam tasarlayasağlamaktır.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-167">The aim in phase estimation is to design a subroutine that is capable of sampling from the eigenvalues of a unitary matrix.</span></span>
<span data-ttu-id="6b2ab-168">Bu yöntem, pmistry ve malzemeçlerinde çok sayıda fiziksel sorun olduğundan, bu eigenvalues 'ın, kudüler için malzeme ve reactıon Dynamics 'in aşama diyagramları hakkında değerli bilgiler sunan hisse ve ABD devlet enerjileri için olmazdır.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-168">This method is indispensable in quantum simulation because for many physical problems in chemistry and material science these eigenvalues give the ground-state energies of quantum systems which provides us valuable information about the phase diagrams of materials and reaction dynamics for molecules.</span></span>
<span data-ttu-id="6b2ab-169">Her aşama tahmini türü bir giriş Unitary gerektirir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-169">Every flavor of phase estimation needs an input unitary.</span></span>
<span data-ttu-id="6b2ab-170">Bu Unitary, geleneksel iki türden biri tarafından açıklanacaktır.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-170">This unitary is customarily described by one of two types of oracles.</span></span>

> [!TIP]
> <span data-ttu-id="6b2ab-171">Aşağıda açıklanan Oracle türlerinin her ikisi de örneklerde ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-171">Both of the oracle types described below are covered in the samples.</span></span>
> <span data-ttu-id="6b2ab-172">Sürekli sorgu Oracles hakkında daha fazla bilgi edinmek için lütfen [ **Phasetahmine** örnek](https://github.com/microsoft/Quantum/tree/master/samples/characterization/phase-estimation)bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-172">To learn more about continuous query oracles, please see the [**PhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/master/samples/characterization/phase-estimation).</span></span>
> <span data-ttu-id="6b2ab-173">Ayrık sorgu Oracles hakkında daha fazla bilgi edinmek için lütfen [ **ısingphasetahmine** örnek](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation)bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-173">To learn more about discrete query oracles, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span></span>

<span data-ttu-id="6b2ab-174">Oracle 'ın ayrı bir sorgusunu çağırdığımız ve Kullanıcı tanımlı türle temsil ettiğimiz Oracle 'ın ilk türü <xref:microsoft.quantum.oracles.discreteoracle> , yalnızca Unitary matrisini içerir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-174">The first type of oracle, which we call a discrete query oracle and represent with the user-defined type <xref:microsoft.quantum.oracles.discreteoracle>, simply involves a unitary matrix.</span></span>
<span data-ttu-id="6b2ab-175">$U $, eigenvalues değerlerini tahmin etmek istediğimiz Unitary ise, Oracle for $U $, $U $ uygulayan bir altyordam için yalnızca bir stand olur.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-175">If $U$ is the unitary whose eigenvalues we wish to estimate then the oracle for $U$ is simply a stand-in for a subroutine that implements $U$.</span></span>
<span data-ttu-id="6b2ab-176">Örneğin, bir tek $U $, genliği tahmin etmek için yukarıda tanımlanan Oracle $Q $ ' ı alabilir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-176">For example, one could take $U$ to be the oracle $Q$ defined above for amplitude estimation.</span></span>
<span data-ttu-id="6b2ab-177">Bu matrisin eigenvalues değeri, ilk ve hedef durumları arasındaki çakışmayı tahmin etmek için kullanılabilir, ancak daha az sayıda örnek kullanarak $ \sin ^ 2 (\teta) $, aksi halde bir kez daha gerekecektir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-177">The eigenvalues of this matrix can be used to estimate the overlap between the initial and target states, $\sin^2(\theta)$, using quadratically fewer samples than one would need otherwise.</span></span>
<span data-ttu-id="6b2ab-178">Bu, genal Oracle $Q $ ' i kullanarak, genlik tahmini adı giriş olarak bir aşama tahmini uygulamasını daha fazla edinir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-178">This earns the application of phase estimation using the Grover oracle $Q$ as input the moniker of amplitude estimation.</span></span>
<span data-ttu-id="6b2ab-179">Hisse Metroloji içinde yaygın olarak kullanılan başka bir ortak uygulama, küçük bir döndürme açısı tahmini içerir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-179">Another common application, widely used in quantum metrology, involves estimating a small rotation angle.</span></span>
<span data-ttu-id="6b2ab-180">Diğer bir deyişle, $R _z (\teta) $ biçiminde bilinmeyen bir döndürme kapısı için $ \teta $ değerini tahmin etmek istiyoruz.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-180">In other words, we wish to estimate $\theta$ for an unknown rotation gate of the form $R_z(\theta)$.</span></span>
<span data-ttu-id="6b2ab-181">Bu gibi durumlarda, ağ geçidi için bu sabit değer olan $ \teta $ değerini öğrenmek için etkileşimde yaptığımız altyordam $ $ \begin{hizalaması} U & = R_z (\teta) \\ \\ & = \begin{bmatrix} e ^ {-i \ teta/2} & 0 \\ \\ 0 & e ^ {ı \ teta/2} \end{bmatrix}.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-181">In such cases, the subroutine that we would interact with in order to learn this fixed value of $\theta$ for the gate is $$ \begin{align} U & = R_z(\theta) \\\\ & = \begin{bmatrix} e^{-i \theta / 2} & 0 \\\\ 0 & e^{i\theta/2} \end{bmatrix}.</span></span>
<span data-ttu-id="6b2ab-182">\end{hizalaması} $ $</span><span class="sxs-lookup"><span data-stu-id="6b2ab-182">\end{align} $$</span></span>

<span data-ttu-id="6b2ab-183">Aşama tahmini içinde kullanılan Oracle 'ın ikinci türü, türü tarafından temsil edilen sürekli sorgu Oracle ' dır <xref:microsoft.quantum.oracles.continuousoracle> .</span><span class="sxs-lookup"><span data-stu-id="6b2ab-183">The second type of oracle used in phase estimation is the continuous query oracle, represented by the <xref:microsoft.quantum.oracles.continuousoracle> type.</span></span>
<span data-ttu-id="6b2ab-184">Aşama tahmini için Oracle sürekli sorgusu, $U (t) $, $t $ ' in sınıfda bilinen gerçek bir sayıdır.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-184">A continuous query oracle for phase estimation takes the form $U(t)$ where $t$ is a classically known real number.</span></span>
<span data-ttu-id="6b2ab-185">$U $ 'in sabit bir Unitary olmasına izin vermemiz halinde sürekli sorgu Oracle, $U (t) = U ^ t $ biçimini alır.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-185">If we let $U$ be a fixed unitary then the continuous query oracle takes the form $U(t) = U^t$.</span></span>
<span data-ttu-id="6b2ab-186">Bu, farklı sorgu modelinde doğrudan uygulanmayan $ \sqrt{U} $ gibi matrisleri sorgulamanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-186">This allows us to query matrices such as $\sqrt{U}$, which could not be implemented directly in the discrete query model.</span></span>

<span data-ttu-id="6b2ab-187">Bu tür Oracle, belirli bir Unitary 'u araştırmadığınızda, ancak Unitary oluşturucusunun özelliklerini öğrenmek istemeniz halinde değerlidir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-187">This type of oracle is valuable when you're not probing a particular unitary, but rather wish to learn the properties of the generator of the unitary.</span></span>
<span data-ttu-id="6b2ab-188">Örneğin, dinamik hisse simülasyonu ' nde amaç, hermitian matris için $U (t) = e ^ {-i H s} $ $H $ ve evlenme süresi $t $.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-188">For example, in dynamical quantum simulation the goal is to devise quantum circuits that closely approximate $U(t)=e^{-i H t}$ for a Hermitian matrix $H$ and evolution time $t$.</span></span>
<span data-ttu-id="6b2ab-189">$U (t) $ öğesinin eigenvalues değeri, $H $ öğesinin eigenvalues ile doğrudan ilgilidir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-189">The eigenvalues of $U(t)$ are directly related to the eigenvalues of $H$.</span></span>
<span data-ttu-id="6b2ab-190">Bunu görmek için $H $: $H \ket{E} = E\ket {E} $ ' nin eigenbir vektörünü düşünün; bu durumda $U (t) \ket{E} = e ^ {i\phi} \ demet {E} = e ^ {-iEt} \ket{E} $ olan matris üstel değerinin güç serisi tanımından kolayca görüyoruz.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-190">To see this, consider an eigenvector of $H$: $H \ket{E} = E\ket{E}$ then it is easy to see from the power-series definition of the matrix exponential that $U(t) \ket{E} = e^{i\phi}\ket{E}= e^{-iEt}\ket{E}$.</span></span>
<span data-ttu-id="6b2ab-191">Bu nedenle $U (t) $ eigenphase tahmini, eigenvector $ \ket{E} $ 'ın aşama tahmin algoritmasına giriş olduğunu varsayarak eigenvalue $E $ değerini verir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-191">Thus estimating the eigenphase of $U(t)$ gives the eigenvalue $E$ assuming the eigenvector $\ket{E}$ is input into the phase estimation algorithm.</span></span>
<span data-ttu-id="6b2ab-192">Ancak, bu durumda $t $ değeri yeterince küçük olan $t $ eigenvalue $E $, $E =-\ Phi/t $ aracılığıyla benzersiz bir şekilde ters çevrilenebilir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-192">However, in this case the value $t$ can be chosen at the user's discretion since for any sufficiently small value of $t$ the eigenvalue $E$ can be uniquely inverted through $E=-\phi/t$.</span></span>
<span data-ttu-id="6b2ab-193">Hisse simülasyonu yöntemleri kısmi bir evlenme gerçekleştirme özelliği sunduğundan, bu, özellikle de ayrık sorgu modelinin tamsayı $j $U $ $U ^ j $ biçimindeki yalnızca birimlere izin vermesi durumunda, tek $t yapmanız gereken, bir dizi tahmin algoritmasına Unitary 'ı sorgularken ek bir serbestlik verir</span><span class="sxs-lookup"><span data-stu-id="6b2ab-193">Since quantum simulation methods provide the ability to perform a fractional evolution, this grants phase estimation algorithms an additional freedom when querying the unitary, specifically while the discrete query model allows only unitaries of the form $U^j$ to applied for integer $j$ the continuous query oracle allows us to approximate unitaries of the form $U^t$ for any real valued $t$.</span></span>
<span data-ttu-id="6b2ab-194">Bu, $E $; hakkında en fazla bilgi sağlayacak olan denemeyi tam olarak seçmemizi sağladığından, son derece tahmin algoritmalarının her birinin en son verimliliğini sıkıştırmanız açısından önemlidir. ayrı sorguları temel alan yöntemler, algoritmadaki sorguların en iyi tamsayı sayısını seçerek ödün vermelidir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-194">This is important to squeeze every last ounce of efficiency out of phase estimation algorithms because it allows us to choose precisely the experiment that would provide the most information about $E$; whereas methods based on discrete queries must make do with compromising by choosing the best integer number of queries in the algorithm.</span></span>

<span data-ttu-id="6b2ab-195">Bunun somut bir örneği olarak, bir ağ geçidinin döndürme açısını değil, bir dönen hisse sisteminin işlem sıklığını tahmin etme sorununu göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-195">As a concrete example of this, consider the problem of estimating not the rotation angle of a gate but the procession frequency of a rotating quantum system.</span></span>
<span data-ttu-id="6b2ab-196">Bu tür hisse dinamikleri tanımlayan Unitary, evlenme süresi $t $ ve bilinmeyen sıklık $ \omega $ için $U (t) = R_z (2 \ Omega t) $ şeklindedir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-196">The unitary that describes such quantum dynamics is $U(t)=R_z(2\omega t)$ for evolution time $t$ and unknown frequency $\omega$.</span></span>
<span data-ttu-id="6b2ab-197">Bu bağlamda, tek bir $R _z $ kapısı kullanarak herhangi bir $t $ için $U (t) $ benzetimi yapabiliriz ve bu nedenle kendimize yalnızca Unitary ile ayrı sorgularla sınırlandırması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-197">In this context, we can simulate $U(t)$ for any $t$ using a single $R_z$ gate and as such do not need to restrict ourselves to only discrete queries to the unitary.</span></span>
<span data-ttu-id="6b2ab-198">Benzer bir şekilde, bu tür bir sürekli model, diğer bir deyişle, Logaritmik sorgular kullanan aşama tahmin işlemlerinden, diğer bir deyişle $t $ ' nin yorumsuz değerler üzerinde gerçekleştirilen denemeleri sonuçlarından ortaya çıkacak olan bir özellik elde edebilir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-198">Such a continuous model also has the property that frequencies greater than $2\pi$ can be learned from phase estimation processes that use continuous queries because phase information that would otherwise be masked by the branch-cuts of the logarithm function can be revealed from the results of experiments performed on non-commensurate values of $t$.</span></span>
<span data-ttu-id="6b2ab-199">Bu nedenle, bu sürekli sorgu modelleri gibi sorunlar için Oracle yalnızca uygun değildir ancak ayrık sorgu modeli için de tercih edilir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-199">Thus for problems such as this continuous query models for the phase estimation oracle are not only appropriate but are also preferable to the discrete query model.</span></span>
<span data-ttu-id="6b2ab-200">Bu nedenle, Q# her iki sorgu formu için de işlevselliğe sahiptir ve ihtiyaçlarını karşılamak için bir aşama tahmin algoritması ve kullanılabilir Oracle türü hakkında karar vermek için kullanıcıya bırakın.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-200">For this reason Q# has functionality for both forms of queries and leave it to the user to decide upon a phase estimation algorithm to fit their needs and the type of oracle that is available.</span></span>

## <a name="dynamical-generator-modeling"></a><span data-ttu-id="6b2ab-201">Dynamical Oluşturucu modelleme</span><span class="sxs-lookup"><span data-stu-id="6b2ab-201">Dynamical Generator Modeling</span></span> ##

<span data-ttu-id="6b2ab-202">Zamanın oluşturanlar, durumların zaman içinde nasıl geliştüini açıklamaktadır.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-202">Generators of time-evolution describe how states evolve through time.</span></span> <span data-ttu-id="6b2ab-203">Örneğin, bir hisse adı $ \ket{\psı} $, Schrödinger denklemi $ $ \begin{hizalaması} ı\frac {d \ket{\psı (t)}} {d t} & = H \ket{\psı (t)} öğesine tabidir. \end{hizalaması} $ $ $ $, hermitian matrisi $H $, Hamiltonian olarak bilinen, hareket Oluşturucu olarak bilinir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-203">For instance, the dynamics of a quantum state $\ket{\psi}$ is governed by the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ with a Hermitian matrix $H$, known as the Hamiltonian, as the generator of motion.</span></span> <span data-ttu-id="6b2ab-204">İlk durum $ \ket{\psı (0)} $ $t = $0, zaman içinde bu denklemin resmi çözümü $t $ olabilir, ilke içinde, matris üstel $U (t) = e ^ {-i H t} $ ' nin Unitary zaman-gelişme işleci olarak bilinmediği $ $ \begin{hizalaması} \ket{\psı (t)} = U (t) \ket{\psı (0)}, \end{hizalaması} $ $ yazılmıştır.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-204">Given an initial state $\ket{\psi(0)}$ at time $t=0$, the formal solution to this equation at time $t$ may be, in principle, written $$ \begin{align} \ket{\psi(t)} = U(t)\ket{\psi(0)}, \end{align} $$ where the matrix exponential $U(t)=e^{-i H t}$ is known as the unitary time-evolution operator.</span></span> <span data-ttu-id="6b2ab-205">Aşağıdaki şekilde bu formun bazı oluşturuculara odaklanıyoruz ancak, kavramı açık hisse sistemleri benzetimi veya daha fazla soyut fark denklemleri gibi daha geniş bir şekilde uygulanacağını vurgularız.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-205">Though we focus on generators of this form in the following, we emphasize that the concept applies more broadly, such as to the simulation of open quantum systems, or to more abstract differential equations.</span></span>

<span data-ttu-id="6b2ab-206">Dinamik simülasyonu 'nin birincil amacı, bir hisse bilgisayarının qubit durumunda kodlanmış bazı hisse alma işlecini uygulamaktır.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-206">A primary goal of dynamical simulation is to implement the time-evolution operator on some quantum state encoded in qubits of a quantum computer.</span></span>  <span data-ttu-id="6b2ab-207">Birçok durumda Hamiltonian bazı $d $ daha basit terimlerin toplamına ayrılabilir</span><span class="sxs-lookup"><span data-stu-id="6b2ab-207">In many cases, the Hamiltonian may be broken into a sum of some $d$ simpler terms</span></span>

<span data-ttu-id="6b2ab-208">$ $ \begin{hizalaması} H & = \sum ^ {d-1} _ {j = 0} H_j, \end{hizalaması} $ $</span><span class="sxs-lookup"><span data-stu-id="6b2ab-208">$$ \begin{align} H & = \sum^{d-1}_{j=0} H_j, \end{align} $$</span></span>

<span data-ttu-id="6b2ab-209">her dönemin zaman gelişiminde, her dönem için tek bir bilgisayar için kolayca uygulanması kolaydır.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-209">where time-evolution by each term alone is easy to implement on a quantum computer.</span></span> <span data-ttu-id="6b2ab-210">Örneğin, $H _j $, qubit yazmacın 1. ve 2. öğelerinde işlem gören bir Pauli $X _1X_2 $ operatöründür `qubits` . Bu, her zaman için, imzası olan işlem çağırarak $t $ uygulanabilir `Exp([PauliX,PauliX], t, qubits[1..2])` `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="6b2ab-210">For instance, if $H_j$ is a Pauli $X_1X_2$ operator acting on the 1st and 2nd elements of the qubit register `qubits`, time-evolution by it for any time $t$ may be implemented simply by calling the operation `Exp([PauliX,PauliX], t, qubits[1..2])`, which has signature `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)`.</span></span> <span data-ttu-id="6b2ab-211">Hamiltonian benzetiminde daha sonra anlatıldığı gibi, bir çözüm daha basit işlemler dizisiyle $H $ ile zaman gelişmede yaklaşık olarak</span><span class="sxs-lookup"><span data-stu-id="6b2ab-211">As discussed later in Hamiltonian Simulation, one solution then is to approximate time-evolution by $H$ with a sequence of simpler operations</span></span>

<span data-ttu-id="6b2ab-212">$ $ \begin{hizalaması} U (t) & = \left (e ^ {-iH \_ 0 t/r} e ^ {-ih \_ 1 t/r} \cnoktalar e ^ {-ih \_ {d-1} t/r} \right) ^ {r} + \mathcal{O} (d ^ 2 \ max_j \\ | H \_ j \\ | ^ 2 t ^ 2/r), \end{hizalaması} $ $</span><span class="sxs-lookup"><span data-stu-id="6b2ab-212">$$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j \\|H\_j\\|^2 t^2/r), \end{align} $$</span></span>

<span data-ttu-id="6b2ab-213">$r > $0 tamsayısı, yaklaşık hatayı denetler.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-213">where the integer $r > 0$ controls the approximation error.</span></span>

<span data-ttu-id="6b2ab-214">Dinamik Oluşturucu modelleme kitaplığı, karmaşık oluşturucuları daha basit bir şekilde kodlamak için bir çerçeve sağlar.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-214">The dynamical generator modeling library provides a framework for systematically encoding complicated generators in terms of simpler generators.</span></span> <span data-ttu-id="6b2ab-215">Bu tür bir açıklama daha sonra, otomatik olarak ele alınan birçok ayrıntıyı içeren bir simülasyon algoritması için zaman gelişini uygulamak üzere benzetim kitaplığı 'na iletilebilir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-215">Such a description may then be passed to, say, the simulation library to implement time-evolution by a simulation algorithm of choice, with many details automatically taken care of.</span></span>

> [!TIP]
> <span data-ttu-id="6b2ab-216">Aşağıda açıklanan dinamik Oluşturucu kitaplığı, örneklerde ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-216">The dynamical generator library described below is covered in the samples.</span></span> <span data-ttu-id="6b2ab-217">Şaşırtıcı modele dayalı bir örnek için lütfen [ **ııngators** 'ın örneğine](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/generators)bakın.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-217">For an example based on the Ising model, please see the [**IsingGenerators** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/generators).</span></span>
> <span data-ttu-id="6b2ab-218">Bir örnek için, [**H2SimulationCmdLine**](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line) ve [**H2SimulationGUI**](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/gui) örneklerine bakın.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-218">For an example based on molecular Hydrogen, please see the [**H2SimulationCmdLine**](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line) and [**H2SimulationGUI**](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/gui) samples.</span></span>

### <a name="complete-description-of-a-generator"></a><span data-ttu-id="6b2ab-219">Oluşturucunun tüm açıklaması</span><span class="sxs-lookup"><span data-stu-id="6b2ab-219">Complete Description of a Generator</span></span> ###

<span data-ttu-id="6b2ab-220">En üst düzeyde, bir Hamiltonian 'nin tam bir açıklaması, `EvolutionGenerator` iki bileşeni olan Kullanıcı tanımlı türde bulunur.:</span><span class="sxs-lookup"><span data-stu-id="6b2ab-220">At the top level, a complete description of a Hamiltonian is contained in the `EvolutionGenerator` user-defined type which has two components.:</span></span>

```qsharp
newtype EvolutionGenerator = (EvolutionSet, GeneratorSystem);
```

<span data-ttu-id="6b2ab-221">`GeneratorSystem`Kullanıcı tanımlı tür, Hamiltonian 'nin klasik bir açıklamasıdır.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-221">The `GeneratorSystem` user-defined type is a classical description of the Hamiltonian.</span></span>

```qsharp
newtype GeneratorSystem = (Int, (Int -> GeneratorIndex));
```

<span data-ttu-id="6b2ab-222">`Int`Kayıt düzeninin ilk öğesi Hamiltonian içinde $d $ terim sayısını depolar ve ikinci öğe, `(Int -> GeneratorIndex)` $ \{ 0, 1,..., d-1 $ içinde bir tamsayı dizinini, \} `GeneratorIndex` Hamiltonian içindeki her temel terimi benzersiz bir şekilde tanımlayan Kullanıcı tanımlı bir türe eşleyen bir işlevdir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-222">The first element `Int` of the tuple stores the number of terms $d$ in the Hamiltonian, and the second element `(Int -> GeneratorIndex)` is a function that maps an integer index in $\{0,1,...,d-1\}$ to a `GeneratorIndex` user-defined type which uniquely identifies each primitive term in the Hamiltonian.</span></span> <span data-ttu-id="6b2ab-223">Hamiltonian içindeki terimlerin koleksiyonunu dizi yerine bir işlev olarak ifade ederek `GeneratorIndex[]` , bu, `GeneratorIndex` özellikle de çok sayıda terim içeren Hamiltonians tarif edildiğinde yararlı olan, işlem içi hesaplama için izin verir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-223">Note that by expressing the collection of terms in the Hamiltonian as a function rather than as an array `GeneratorIndex[]`, this allows for on-the-fly computation of the `GeneratorIndex` which is especially useful when describing Hamiltonians with a large number of terms.</span></span>

<span data-ttu-id="6b2ab-224">Crucially, tarafından tanımlanan temel terimlerin kolay benzetimini yapma konusunda bir kural sunmamalıdır `GeneratorIndex` .</span><span class="sxs-lookup"><span data-stu-id="6b2ab-224">Crucially, we do not impose a convention on what primitive terms identified by the `GeneratorIndex` are easy-to-simulate.</span></span> <span data-ttu-id="6b2ab-225">Örnek olarak, temel terimler yukarıda açıklanan Pauli işleçleri olabilir, ancak aynı zamanda hisse maç simülasyonu ve oluşturma işleçlerini yaygın olarak ücretçde olabilecek bir şekilde da kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-225">For instance, primitive terms could be Pauli operators as discussed above, but they could also be Fermionic annihilation and creation operators commonly used in quantum chemistry simulation.</span></span> <span data-ttu-id="6b2ab-226">Tek başına,, `GeneratorIndex` işaret ettiği dönem tarafından bir hisse akı devresi olarak uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-226">By itself, a `GeneratorIndex` is meaningless as it does not describe how time-evolution by the term it points to may be implemented as a quantum circuit.</span></span>

<span data-ttu-id="6b2ab-227">Bu, `EvolutionSet` herhangi bir `GeneratorIndex` kurallı kümeden çizilmiş, bir Unitary işlecine, `EvolutionUnitary` bir hisse türü olarak ifade edilen bir Kullanıcı tanımlı tür belirtilerek çözümlenir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-227">This is resolved by specifying an `EvolutionSet` user-defined type that maps any `GeneratorIndex`, drawn from some canonical set, to a unitary operator, the `EvolutionUnitary`, expressed as a quantum circuit.</span></span> <span data-ttu-id="6b2ab-228">, `EvolutionSet` Bir öğesinin nasıl `GeneratorIndex` yapılandırıldığını ve ayrıca mümkün olan bir kümesini tanımlar `GeneratorIndex` .</span><span class="sxs-lookup"><span data-stu-id="6b2ab-228">The `EvolutionSet` defines the convention of how a `GeneratorIndex` is structured, and also defines the set of possible `GeneratorIndex`.</span></span>

```qsharp
newtype EvolutionSet = (GeneratorIndex -> EvolutionUnitary);
```

### <a name="pauli-operator-generators"></a><span data-ttu-id="6b2ab-229">Pauli Işleç oluşturucuları</span><span class="sxs-lookup"><span data-stu-id="6b2ab-229">Pauli Operator Generators</span></span> ###

<span data-ttu-id="6b2ab-230">Somut ve yararlı bir örnek, her biri farklı bir katsayı değeri olan Pauli işleçlerinin toplamı olan Hamiltonians.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-230">A concrete and useful example of generators are Hamiltonians that are a sum of Pauli operators, each possibly with a different coefficient.</span></span>
<span data-ttu-id="6b2ab-231">$ $ \begin{hizalaması} H & = \sum ^ {d-1} _ {j = 0} a_j H_j, \end{hizalaması} $ $; burada her $ \hat H_j $, Pauli grubundan çizilmiştir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-231">$$ \begin{align} H & = \sum^{d-1}_{j=0} a_j H_j, \end{align} $$ where each $\hat H_j$ is now drawn from the Pauli group.</span></span> <span data-ttu-id="6b2ab-232">Bu tür sistemler için, `PauliEvolutionSet()` `EvolutionSet` aşağıdaki imzaya sahip bir Pauli Group 'un ve bir katsayı öğesinin bir öğesi tarafından nasıl belirlenebileceği için bir kural tanımlayan türü sağlıyoruz `GeneratorIndex` .</span><span class="sxs-lookup"><span data-stu-id="6b2ab-232">For such systems, we provide the `PauliEvolutionSet()` of type `EvolutionSet` that defines a convention for how an element of the Pauli group and a coefficient may be identified by a `GeneratorIndex`, which has the following signature.</span></span>

```qsharp
newtype GeneratorIndex = ((Int[], Double[]), Int[]);
```

<span data-ttu-id="6b2ab-233">Kodlarımızda ilk parametre, `Int[]` $ \Stai\estarrow $0, $ \Hat x\sağtarrow $1, $ \Hat yı\estarrow $2 ve $ \Hat Z\sağtarrow $3 şeklinde bir Pauli String belirtir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-233">In our encoding, the first parameter `Int[]` specifies a Pauli string, where $\hat I\rightarrow 0$, $\hat X\rightarrow 1$, $\hat Y\rightarrow 2$, and $\hat Z\rightarrow 3$.</span></span> <span data-ttu-id="6b2ab-234">İkinci parametre, `Double[]` Hamiltonian Içinde Pauli dizesinin katsayısını depolar.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-234">The second parameter `Double[]` stores the coefficient of the Pauli string in the Hamiltonian.</span></span> <span data-ttu-id="6b2ab-235">Bu dizinin yalnızca ilk öğesi kullanıldığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-235">Note that only the first element of this array is used.</span></span> <span data-ttu-id="6b2ab-236">Üçüncü parametre, `Int[]` Bu Pauli dizesinin üzerinde hareket eden qubits 'leri dizinleyen ve yinelenen öğe içermemelidir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-236">The third parameter `Int[]` indexes the qubits that this Pauli string acts on, and must have no duplicate elements.</span></span> <span data-ttu-id="6b2ab-237">Bu nedenle, Hamiltonian Term $0,4 \hat X_0 \hat Y_8 \hat I_2 \hat Z_1 $ şöyle gösterilebilir</span><span class="sxs-lookup"><span data-stu-id="6b2ab-237">Thus the Hamiltonian term $0.4 \hat X_0 \hat Y_8\hat I_2\hat Z_1$ may be represented as</span></span>

```qsharp
let generatorIndexExample = GeneratorIndex(([1,2,0,3], [0.4]]), [0,8,2,1]);
```

<span data-ttu-id="6b2ab-238">, `PauliEvolutionSet()` `GeneratorIndex` Bu formdan herhangi birini aşağıdaki imzayla bir ile eşleyen bir işlevdir `EvolutionUnitary` .</span><span class="sxs-lookup"><span data-stu-id="6b2ab-238">The `PauliEvolutionSet()` is a function that maps any `GeneratorIndex` of this form to an `EvolutionUnitary` with the following signature.</span></span>

```qsharp
newtype EvolutionUnitary = ((Double, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="6b2ab-239">İlk parametre, Unitary evrimi 'nin içindeki katsayı ile çarpılacak bir zaman süresini temsil eder `GeneratorIndex` .</span><span class="sxs-lookup"><span data-stu-id="6b2ab-239">The first parameter represents a time-duration, that will be multiplied by the coefficient in the `GeneratorIndex`, of unitary evolution.</span></span> <span data-ttu-id="6b2ab-240">İkinci parametre, Unitary 'ın üzerinde davrandığı qubit kayıt ' dir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-240">The second parameter is the qubit register the unitary acts on.</span></span> 

### <a name="time-dependent-generators"></a><span data-ttu-id="6b2ab-241">Zamana bağımlı oluşturucular</span><span class="sxs-lookup"><span data-stu-id="6b2ab-241">Time-Dependent Generators</span></span> ###

<span data-ttu-id="6b2ab-242">Birçok durumda, zamana bağlı oluşturanlar arasında modellemeyi de ilgileniyoruz, Schrödinger denklemi $ $ \begin{hizalaması} ı\frac {d \ket{\psı (t)}} {d t} & = \hat H (t) \ket{\psı (t)}, \end{hizalaması} $ $, Oluşturucu $ \hat H (t) $ ' ın artık zamana bağımlı olduğu gibi olabilir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-242">In many cases, we are also interested in modelling time-dependent generators, as might occur in the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = \hat H(t) \ket{\psi(t)}, \end{align} $$ where the generator $\hat H(t)$ is now time-dependent.</span></span> <span data-ttu-id="6b2ab-243">Bu durum için yukarıdaki zamana bağımsız oluşturuculardan uzantı basittir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-243">The extension from the time-independent generators above to this case is straightforward.</span></span> <span data-ttu-id="6b2ab-244">`GeneratorSystem`$T $, her zaman Için Hamiltonian 'ın açıklanmasına sahip olmak yerine, Kullanıcı tanımlı türe sahip olmamız gerekir `GeneratorSystemTimeDependent` .</span><span class="sxs-lookup"><span data-stu-id="6b2ab-244">Rather than having a fixed `GeneratorSystem` describing the Hamiltonian for all times $t$, we instead have the `GeneratorSystemTimeDependent` user-defined type.</span></span>

```qsharp
newtype GeneratorSystemTimeDependent = (Double -> GeneratorSystem);
```

<span data-ttu-id="6b2ab-245">İlk parametre, \ [0, 1] $ içindeki bir sürekli zamanlama parametresidir $s ve bu türdeki işlevler bu zamanlama için bir döndürür `GeneratorSystem` .</span><span class="sxs-lookup"><span data-stu-id="6b2ab-245">The first parameter is a continuous schedule parameter $s\in [0,1]$, and functions of this type return a `GeneratorSystem` for that schedule.</span></span> <span data-ttu-id="6b2ab-246">Zamanlama parametresinin, bazı simülasyon $T $, bazı toplam süre için $s = t/T $ gibi fiziksel zaman parametresiyle ilişkili olabileceğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-246">Note that the schedule parameter may be linearly related to the physical time parameter e.g. $s = t / T$, for some total time of simulation $T$.</span></span> <span data-ttu-id="6b2ab-247">Genellikle, bu durum böyle değildir.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-247">In general however, this need not be the case.</span></span>

<span data-ttu-id="6b2ab-248">Benzer şekilde, bu oluşturucunun tam bir açıklaması bir gerektirir `EvolutionSet` ve bu nedenle `EvolutionSchedule` Kullanıcı tanımlı bir tür tanımlıyoruz.</span><span class="sxs-lookup"><span data-stu-id="6b2ab-248">Similarly, a complete description of this generator requires an `EvolutionSet`, and so we define an `EvolutionSchedule` user-defined type.</span></span>

```qsharp
newtype EvolutionSchedule = (EvolutionSet, GeneratorSystemTimeDependent);
```
