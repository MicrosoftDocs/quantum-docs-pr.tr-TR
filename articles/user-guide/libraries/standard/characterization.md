---
title: Hisse ve istatistik
description: Aşamalarda bulunan Ölçüm istatistiklerinin, hisse harcamalarda elde edilen sonuç değerlerini tahmin etmek için nasıl kullanıldığını öğrenin.
author: bradben
uid: microsoft.quantum.libraries.characterization
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
no-loc:
- Q#
- $$v
ms.openlocfilehash: 8dddc15354c32808e7ad1310bce233ee3dc93fe8
ms.sourcegitcommit: 9b0d1ffc8752334bd6145457a826505cc31fa27a
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/21/2020
ms.locfileid: "90835647"
---
# <a name="quantum-characterization-and-statistics"></a><span data-ttu-id="8a99f-103">Hisse ve Istatistik</span><span class="sxs-lookup"><span data-stu-id="8a99f-103">Quantum Characterization and Statistics</span></span> #

<span data-ttu-id="8a99f-104">Yararlı hisse algoritmaları geliştirmek için işlemlerin etkilerini niteleyen kritik öneme sahiptir.</span><span class="sxs-lookup"><span data-stu-id="8a99f-104">It is critical to be able to characterize the effects of operations in order to develop useful quantum algorithms.</span></span>
<span data-ttu-id="8a99f-105">Bu, bir hisse sisteminin her ölçümü en fazla bir bilgi elde ettiği için bu zor bir değer.</span><span class="sxs-lookup"><span data-stu-id="8a99f-105">This is challenging because every measurement of a quantum system yields at most one bit of information.</span></span>
<span data-ttu-id="8a99f-106">Bir eigenvalue öğrenmek için, tek başına bir hisse alım durumunda, kullanıcının bu kavramları temsil etmek için gereken pek çok bilgi bitini bir araya getirmek için birçok ölçüm sonucunun birlikte kullanılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="8a99f-106">In order to learn an eigenvalue, let alone a quantum state, the results of many measurements must be stitched together so that the user can glean the many bits of information needed to represent these concepts.</span></span>
<span data-ttu-id="8a99f-107">Her [şey, bu](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) durum kopyasının tek bir kopyasından rastgele bir hisse alım durumu öğrenmenin bir yolu olmadığını ve bu nedenle durumun kopyalarını oluşturmanıza olanak sağladığından, hisse alma işlemleri özellikle sanal olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="8a99f-107">Quantum states are especially vexing because the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) states that there is no way to learn an arbitrary quantum state from a single copy of the state, because doing so would let you make copies of the state.</span></span>
<span data-ttu-id="8a99f-108">Bu hisse Sayın Kullanıcı tarafından bu şekilde gösterilmesi, Q# bir durumun hisse amayan programlar için ne olduğunu ortaya çıkaran ya da tanımlamayan bir *is* olgusuna yansıtılmıştır.</span><span class="sxs-lookup"><span data-stu-id="8a99f-108">This obfuscation of the quantum state from the user is reflected in the fact that Q# does not expose or even define what a state *is* to quantum programs.</span></span>
<span data-ttu-id="8a99f-109">Bu nedenle, işlemleri ve durumları siyah kutu olarak düşünerek hisse uygun hale getirme yaklaşıyoruz; Bu yaklaşım, hisse uygun, doğrulama ve doğrulamanın (QCVV) deneysel uygulaması ile ortak olarak çok daha yaygın bir şekilde paylaşır.</span><span class="sxs-lookup"><span data-stu-id="8a99f-109">We thus approach quantum characterization by treating operations and states as black-box; this approach shares much in common with the experimental practice of quantum characterization, verification and validation (QCVV).</span></span>

<span data-ttu-id="8a99f-110">Daha önce ele alınan diğer kitaplıkların birçoğu karakter ayırma farklıdır.</span><span class="sxs-lookup"><span data-stu-id="8a99f-110">Characterization is distinct from many of the other libraries discussed previously.</span></span>
<span data-ttu-id="8a99f-111">Burada, bir durum vektörü üzerinde Unitary dönüştürmesi gerçekleştirmek yerine, sistem hakkında klasik bilgilerin öğrenmesinin daha az olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="8a99f-111">The aim here is less to learn classical information about the system, rather than to perform a unitary transformation on a state vector.</span></span>
<span data-ttu-id="8a99f-112">Bu kitaplıkların bu nedenle hem klasik hem de hisse bilgisi işlemesini Blend gerekir.</span><span class="sxs-lookup"><span data-stu-id="8a99f-112">These libraries must therefore blend both classical and quantum information processing.</span></span>


## <a name="iterative-phase-estimation"></a><span data-ttu-id="8a99f-113">Yinelemeli aşama tahmini</span><span class="sxs-lookup"><span data-stu-id="8a99f-113">Iterative Phase Estimation</span></span> ##

<span data-ttu-id="8a99f-114">Hisse kullanım açısından hisse programlama, hisse miktarı tahmini için yararlı bir alternatif önerir.</span><span class="sxs-lookup"><span data-stu-id="8a99f-114">Viewing quantum programming in terms of quantum characterization suggests a useful alternative to quantum phase estimation.</span></span>
<span data-ttu-id="8a99f-115">Diğer bir deyişle, bir $n $-qubit kaydı hazırlamak yerine, aşamanın, hisse alma tahminiyle aynı şekilde bir ikili temsilini içermesi için, bir *Klasik* aracının ölçümler aracılığıyla bir hisse alma sisteminin özelliklerini öğrendiği işlem olarak görüntüleyebiliriz.</span><span class="sxs-lookup"><span data-stu-id="8a99f-115">That is, instead of preparing an $n$-qubit register to contain a binary representation of the phase as in quantum phase estimation, we can view phase estimation as the process by which a *classical* agent learns properties of a quantum system through measurements.</span></span>
<span data-ttu-id="8a99f-116">Bir siyah kutu işleminin uygulamalarını bilinmeyen bir açıda bir değere dönüştürmek için KickBack öğesini kullanarak ücretlendiriyoruz, ancak dönüşün hemen ardından her adımda döndürtiğimiz ansınla quge 'yı ölçecek.</span><span class="sxs-lookup"><span data-stu-id="8a99f-116">We proceed as in the quantum case by using phase kickback to turn applications of a black-box operation into rotations by an unknown angle, but will measure the ancilla qubit that we rotate at each step immediately following the rotation.</span></span>
<span data-ttu-id="8a99f-117">Bu, her adımın bir yinelemeli bir şekilde açıklandığı aşamayı daha sonra öğrendiğimiz için, bu aşamada yalnızca bir adet ek qubit olması gereken avantajdan yararlanır.</span><span class="sxs-lookup"><span data-stu-id="8a99f-117">This has the advantage that we only require a single additional qubit to perform the phase kickback described in the quantum case, as we then learn the phase from the measurement results at each step in an iterative fashion.</span></span>  
<span data-ttu-id="8a99f-118">Aşağıda önerilen yöntemlerin her biri, aşamayı öğrenmek için denemeleri ve farklı veri işleme yöntemleri tasarlamak üzere farklı bir strateji kullanır.</span><span class="sxs-lookup"><span data-stu-id="8a99f-118">Each of the methods proposed below uses a different strategy for designing experiments and different data processing methods to learn the phase.</span></span>  <span data-ttu-id="8a99f-119">Bunların her biri, ciddi bir hata sınırlarına sahip olmanın, önceki bilgileri birleştirme, hataları tolerans veya bellek için kabul edilen klasik bilgisayarlarda çalıştırma yeteneklerine kadar benzersiz bir avantajı vardır.</span><span class="sxs-lookup"><span data-stu-id="8a99f-119">They each have unique advantage ranging from having rigorous error bounds, to the abilities to incorporate prior information, tolerate errors or run on memory limitted classical computers.</span></span>

<span data-ttu-id="8a99f-120">Yinelemeli aşama tahminlerini tartışmak için, bir siyah kutu işlemi olarak verilen bir Unitary $U $ ' i düşüneceğiz.</span><span class="sxs-lookup"><span data-stu-id="8a99f-120">In discussing iterative phase estimation, we will consider a unitary $U$ given as a black-box operation.</span></span>
<span data-ttu-id="8a99f-121">[Veri yapılarında](xref:microsoft.quantum.libraries.data-structures)Oracles bölümünde açıklandığı gibi, Q# Canon, <xref:microsoft.quantum.oracles.discreteoracle> kayıt türü tarafından tanımlanan Kullanıcı tanımlı türe göre bu işlemleri modelleyerek `((Int, Qubit[]) => Unit : Adjoint, Controlled)` .</span><span class="sxs-lookup"><span data-stu-id="8a99f-121">As described in the section on oracles in [data structures](xref:microsoft.quantum.libraries.data-structures), the Q# canon models such operations by the <xref:microsoft.quantum.oracles.discreteoracle> user-defined type, defined by the tuple type `((Int, Qubit[]) => Unit : Adjoint, Controlled)`.</span></span>
<span data-ttu-id="8a99f-122">`U : DiscreteOracle`Daha sonra, `U(m)` için $U ^ m $ uygular `m : Int` .</span><span class="sxs-lookup"><span data-stu-id="8a99f-122">Concretely, if `U : DiscreteOracle`, then `U(m)` implements $U^m$ for `m : Int`.</span></span>

<span data-ttu-id="8a99f-123">Bu tanım söz konusu olduğunda, yinelemeli aşama tahmininin her adımı, $ \ket{+} $ durumunda bir yardımcı qubit, $U (m) $ ' nin [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) ' i olduğunu varsaydığımız ilk durum olan $ \ket{\phi} $, ör. $U (m) \ket{\phi} = e ^ {im\phi} \ demet {\ Fi} $.</span><span class="sxs-lookup"><span data-stu-id="8a99f-123">With this definition in place, each step of iterative phase estimation proceeds by preparing an auxiliary qubit in the $\ket{+}$ state along with the initial state $\ket{\phi}$ that we assume is an [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) of $U(m)$, i.e. $U(m)\ket{\phi}= e^{im\phi}\ket{\phi}$.</span></span>  
<span data-ttu-id="8a99f-124">Daha sonra kontrollü bir uygulama, `U(m)` $ \left (R \_ 1 (m \ Fi) \ket{+} \right) \ket{\phi} $ durumunu hazırlayan kullanılır.</span><span class="sxs-lookup"><span data-stu-id="8a99f-124">A controlled application of `U(m)` is then used which prepares the state $\left(R\_1(m \phi) \ket{+}\right)\ket{\phi}$.</span></span>
<span data-ttu-id="8a99f-125">Hisse vakine benzer şekilde, Oracle 'ın denetlenen uygulamasının etkisi, `U(m)` Bu daha basit bir şekilde $U $ ' in etkilerini anlayabilmemiz gibi, $ \ket{+} $ üzerinde bilinmeyen aşama için $R _1 $ ' ı uygulamanın etkileriyle aynı şekilde aynıdır.</span><span class="sxs-lookup"><span data-stu-id="8a99f-125">As in the quantum case, the effect of a controlled application of the oracle `U(m)` is precisely the same as the effect of applying $R_1$ for the unknown phase on $\ket{+}$, such that we can describe the effects of $U$ in this simpler fashion.</span></span>
<span data-ttu-id="8a99f-126">İsteğe bağlı olarak, algoritma $ \ket{\psı} = \left (R \_ 1 (m [\phi-\teta]) \ket{+} \right) \ket{\phi} $ $ değerini elde etmek için $R _1 (-m\teta) $ değerini uygulayarak denetim qubit 'i döndürür.</span><span class="sxs-lookup"><span data-stu-id="8a99f-126">Optionally, the algorithm then rotates the control qubit by applying $R_1(-m\theta)$ to obtain a state $\ket{\psi}=\left(R\_1(m [\phi-\theta]) \ket{+}\right)\ket{\phi}$$.</span></span>
<span data-ttu-id="8a99f-127">Denetim olarak kullanılan yardımcı qubit, `U(m)` tek bir klasik elde etmek için $X $ temelinde ölçülür `Result` .</span><span class="sxs-lookup"><span data-stu-id="8a99f-127">The auxiliary qubit used as a control for `U(m)` is then measured in the $X$ basis to obtain a single classical `Result`.</span></span>

<span data-ttu-id="8a99f-128">Bu noktada, `Result` yinelemeli aşama tahmini aracılığıyla elde edilen değerlerden aşamayı yeniden oluşturmak, klasik istatistiksel çıkarım sorunudur.</span><span class="sxs-lookup"><span data-stu-id="8a99f-128">At this point, reconstructing the phase from the `Result` values obtained through iterative phase estimation is a classical statistical inference problem.</span></span>
<span data-ttu-id="8a99f-129">Sabit bir çıkarım yöntemi verildiğinde elde edilen bilgileri en üst düzeye çıkaran $m $ değerini bulmak, istatistikte yalnızca bir sorundur.</span><span class="sxs-lookup"><span data-stu-id="8a99f-129">Finding the value of $m$ that maximizes the information gained, given a fixed inference method, is simply a problem in statistics.</span></span>
<span data-ttu-id="8a99f-130">Bunu, bu Q# Klasik çıkarım sorununu çözmek için Canon 'de sunulan istatistiksel algoritmaları tanımlamaya devam etmeden önce, bu hatayı, bir teorik olarak, Bayema parametresi tahmin formalronu 'de bir teorik olarak, en çok bir teorik olarak, bir teorik</span><span class="sxs-lookup"><span data-stu-id="8a99f-130">We emphasize this by briefly describing iterative phase estimation at a theoretical level in the Bayesian parameter estimation formalism before proceeding to describe the statistical algorithms provided in the Q# canon for solving this classical inference problem.</span></span>

### <a name="iterative-phase-estimation-without-eigenstates"></a><span data-ttu-id="8a99f-131">Idgenstates olmadan yinelemeli aşama tahmini</span><span class="sxs-lookup"><span data-stu-id="8a99f-131">Iterative Phase Estimation Without Eigenstates</span></span> ###

<span data-ttu-id="8a99f-132">Eğer $U (m) \ket{\phi \_ j} = e ^ {im\phi \_ j} $ olduğunda, aşama tahmini süreci her bir enerji egeninin doğru şekilde hisse ansız bir şekilde rehberlik eden bir giriş durumu sağlanırsa</span><span class="sxs-lookup"><span data-stu-id="8a99f-132">If an input state is provided that is not an eigenstate, which is to say that if $U(m)\ket{\phi\_j} = e^{im\phi\_j}$ then the process of phase estimation non-deterministically guides the quantum state towards a single energy eigenstate.</span></span>  <span data-ttu-id="8a99f-133">Son olarak, gözegenlerin oluşma olasılığı en yüksek olan eigenstate `Result` .</span><span class="sxs-lookup"><span data-stu-id="8a99f-133">The eigenstate it ultimately converges to is the eigenstate that is most likely to produce the observed `Result`.</span></span>

<span data-ttu-id="8a99f-134">Özellikle, tek bir adım, şu Unitary olmayan dönüştürmeyi bir durum olan \begin{hizalaması} \ sum_j \sqrt{\Pr (\phi \_ j)} \ket{\phi \_ j} \mapsto \sum \_ j\frac {\ sqrt {\ PR (\phi \_ j)} \sqrt{\Pr (\text{Result} | \phi \_ j)} \ket{\phi \_ j}} {\sqrt{\pr (\phj \_ ) \Sum \_ j \pr (\Text{Result} | \phi \_ j)}}.</span><span class="sxs-lookup"><span data-stu-id="8a99f-134">Specifically, a single step of PE performs the following non-unitary transformation on a state \begin{align} \sum_j \sqrt{\Pr(\phi\_j)} \ket{\phi\_j} \mapsto \sum\_j\frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}.</span></span>
<span data-ttu-id="8a99f-135">\end{hizalaması} bu işlem birden çok değer üzerinde yinelendiğinden `Result` , $ \ prod_k \Pr (\text{Result} \_ k | \phi j) $ değerinin maxhayvan değeri olmayan eigenstates, \_ katlanarak bastırılır.</span><span class="sxs-lookup"><span data-stu-id="8a99f-135">\end{align} As this process is iterated over multiple `Result` values, eigenstates that do not have maximal values of $\prod_k\Pr(\text{Result}\_k|\phi\_j)$ will be exponentially suppressed.</span></span>
<span data-ttu-id="8a99f-136">Sonuç olarak, denemeleri düzgün şekilde seçildiyse, çıkarım işlemi tek bir eigenvalue ile duruma yakınsama eğilimi gösterir.</span><span class="sxs-lookup"><span data-stu-id="8a99f-136">As a result, the inference process will tend to converge to states with a single eigenvalue if the experiments are chosen properly.</span></span>

<span data-ttu-id="8a99f-137">Bayes ' teoreminin, aşama tahmininizden elde edilen durumun \begin{hizalaması} \frac{\sqrt{\pr ( \_ \phj)} \sqrt{\pr (\Text{Result} | \_ \phj)} \ket{\biçiminde yazılmasını önerir. Phi \_ j}} {\sqrt{\pr (\phi \_ j) \sum \_ j \pr (\Text{Result} | \phi \_ j)}} = \ sum_j \sqrt{\pr (\phi \_ j | \Text{Result})} \ket{\phi \_ j}.</span><span class="sxs-lookup"><span data-stu-id="8a99f-137">Bayes' theorem further suggests that the state that results from phase estimation be written in the form \begin{align} \frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}=\sum_j \sqrt{\Pr(\phi\_j|\text{Result})} \ket{\phi\_j}.</span></span>
<span data-ttu-id="8a99f-138">\end{hizalaması} burada $ \Pr (\phi \_ j | \text{Result}) $, verilen eigenstates hakkında her bir varsayıma neden olacağı olasılığını göz önüne alabilir:</span><span class="sxs-lookup"><span data-stu-id="8a99f-138">\end{align} Here $\Pr(\phi\_j|\text{Result})$ can be interpretted as the probability that one would ascribe to each hypothesis about the eigenstates given:</span></span>

1. <span data-ttu-id="8a99f-139">ölçümden önceki hisse bilgisi hakkında bilgi,</span><span class="sxs-lookup"><span data-stu-id="8a99f-139">knowledge of the quantum state prior to measurement,</span></span>
2. <span data-ttu-id="8a99f-140">$U $ ve ' nin eigendurumları hakkında bilgi</span><span class="sxs-lookup"><span data-stu-id="8a99f-140">knowledge of the eigenstates of $U$ and,</span></span>
3. <span data-ttu-id="8a99f-141">$U $ öğesinin eigenvalues hakkında bilgi.</span><span class="sxs-lookup"><span data-stu-id="8a99f-141">knowledge of the eigenvalues of $U$.</span></span>

<span data-ttu-id="8a99f-142">Bu üç şeyi öğrenirken, klasik bir bilgisayarda genellikle üstel olarak çok daha zordur.</span><span class="sxs-lookup"><span data-stu-id="8a99f-142">Learning these three things is often exponentially hard on a classical computer.</span></span>
<span data-ttu-id="8a99f-143">Aşama tahmini yardımcı programı, küçük bir ölçüde bu şekilde, bu tür bir hisse öğrenme görevinin hiçbirini bilmeden gerçekleştirebilmesinin farkında olmadan ortaya çıkar.</span><span class="sxs-lookup"><span data-stu-id="8a99f-143">The utility of phase estimation arises, to no small extent, from the fact that it can perform such a quantum learning task without knowing any of them.</span></span>
<span data-ttu-id="8a99f-144">Bu nedene yönelik aşama tahmini, üstel hızlı bir şekilde bir dizi algoritmalarda bulunur.</span><span class="sxs-lookup"><span data-stu-id="8a99f-144">Phase estimation for this reason appears within a number of quantum algorithms that provide exponential speedups.</span></span>

### <a name="bayesian-phase-estimation"></a><span data-ttu-id="8a99f-145">Bayeme aşaması tahmini</span><span class="sxs-lookup"><span data-stu-id="8a99f-145">Bayesian Phase Estimation</span></span> ###

> [!TIP]
> <span data-ttu-id="8a99f-146">Uygulamada Bayeme aşaması tahmini hakkında daha fazla bilgi için lütfen [**Phasetahmine**](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation) örnek bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="8a99f-146">For more details on Bayesian phase estimation in practice, please see the [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation) sample.</span></span>

<span data-ttu-id="8a99f-147">Bayeme aşaması tahmini fikri basittir.</span><span class="sxs-lookup"><span data-stu-id="8a99f-147">The idea of Bayesian phase estimation is simple.</span></span>
<span data-ttu-id="8a99f-148">Aşama tahmini protokolünden Ölçüm istatistiklerini toplar ve ardından Bayeme çıkarımı kullanarak sonuçları işleyin ve bir tahmin parametresi sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8a99f-148">You collect measurement statistics from the phase estimation protocol and then you process the results using Bayesian inference and provide an estimate of the parameter.</span></span>
<span data-ttu-id="8a99f-149">Bu işleme, bu tahmine ilişkin kesin bir değer elde etmek için eigenvalue ve belirsizlik sağlar.</span><span class="sxs-lookup"><span data-stu-id="8a99f-149">This processing gives you an estimate of the eigenvalue as well as the uncertainty in that estimate.</span></span>
<span data-ttu-id="8a99f-150">Ayrıca, uyarlamalı denemeleri gerçekleştirmenizi ve önceki bilgileri kullanmanızı da sağlar.</span><span class="sxs-lookup"><span data-stu-id="8a99f-150">It also allows you to perform adaptive experiments and utilize prior information.</span></span>
<span data-ttu-id="8a99f-151">Yöntemlerin prendezavantajları, hesaplama açısından yoğun hale gelir.</span><span class="sxs-lookup"><span data-stu-id="8a99f-151">The methods' principle drawback is that it is computationally demanding.</span></span>

<span data-ttu-id="8a99f-152">Bu Bayete çıkarım işleminin nasıl çalıştığını anlamak için, tek bir sonucu işleme durumunu göz önünde bulundurun `Zero` .</span><span class="sxs-lookup"><span data-stu-id="8a99f-152">To understand how this Bayesian inference process works, consider the case of processing a single `Zero` result.</span></span>
<span data-ttu-id="8a99f-153">$X = \ket{+} \bra{+}- {-} \tus\bra {-} $, örneğin $ \ket{+} $, öğesine karşılık gelen $X $ öğesinin tek pozitif eigenstate olduğunu unutmayın `Zero` .</span><span class="sxs-lookup"><span data-stu-id="8a99f-153">Note that $X = \ket{+}\bra{+} - \ket{-}\bra{-}$, such that $\ket{+}$ is the only positive eigenstate of $X$ corresponding to `Zero`.</span></span>
<span data-ttu-id="8a99f-154">`Zero`İlk qubit üzerinde bir [ `PauliX` ölçümü](xref:microsoft.quantum.concepts.pauli) bir giriş durumu olan $ \ket{\psi}\ket{\phi} $ için gözlemleme olasılığı, bu nedenle \begin{Equation} \Pr (\Texttt{dd} | \psı) = \left | \braket{+ | \psı} \ Right | ^ 2.</span><span class="sxs-lookup"><span data-stu-id="8a99f-154">The probability of observing `Zero` for a [`PauliX` measurement](xref:microsoft.quantum.concepts.pauli) on the first qubit given an input state $\ket{\psi}\ket{\phi}$ is thus \begin{equation} \Pr(\texttt{Zero} | \psi) = \left| \braket{+ | \psi} \right|^2.</span></span>
<span data-ttu-id="8a99f-155">\end{Equation} yinelemeli aşama tahmini durumunda, $ \ket{\psı} = R_1 (d [\phi-\teta]) \ket{+} $, \begin{hizalaması} \Pr (\Texttt{sıfırlaması} | \fi; e, \teta) & = \left | \braket{+ | R_1 (d [\phi-\teta]) | +} \ Right | ^ 2 \\ \\ & = \left | \frac12 \left (\bra {0} + \bra {1} \ sağ) \left (\ket {0} + e ^ {ı. [\phi-\teta]} \ayraç {1} \ right) \ doğru | ^ 2 \\ \\ & = \ Left | \frac{1 + e ^ {i m [\phi-\teta]}} {2} \ Right | ^ 2 \\ \\ & = \cos ^ 2 (m [\phi-\teta]/2) \tag{★} \label{EQ: Phase-EST-olasılık}.</span><span class="sxs-lookup"><span data-stu-id="8a99f-155">\end{equation} In the case of iterative phase estimation, we have that $\ket{\psi} = R_1(m [\phi-\theta]) \ket{+}$, such that \begin{align} \Pr(\texttt{Zero} | \phi; m,\theta) & = \left| \braket{+ | R_1(m [\phi-\theta]) | +} \right|^2 \\\\ & = \left| \frac12 \left( \bra{0} + \bra{1} \right) \left( \ket{0} + e^{i m [\phi-\theta]} \ket{1} \right) \right|^2 \\\\ & = \left| \frac{1 + e^{i m [\phi-\theta]}}{2} \right|^2 \\\\ & = \cos^2(m [\phi-\theta] / 2) \tag{★} \label{eq:phase-est-likelihood}.</span></span>
<span data-ttu-id="8a99f-156">\end{hizalaması} diğer bir deyişle, yinelemeli aşama tahmini, bir sinusoidal işlevinin salınlation sıklığını öğrenmeden ve bu sinusoıd tarafından verilen bir ölçüle bir para ile bir para alanı çevirmenize olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="8a99f-156">\end{align} That is, iterative phase estimation consists of learning the oscillation frequency of a sinusoidal function, given the ability to flip a coin with a bias given by that sinusoid.</span></span>
<span data-ttu-id="8a99f-157">Geleneksel klasik terminolojiye göre, $ \eqref{EQ: Phase-EST-olasılık} $ yinelemeli aşama tahmini için *olasılık işlevini* çağırıyoruz.</span><span class="sxs-lookup"><span data-stu-id="8a99f-157">Following traditional classical terminology, we call $\eqref{eq:phase-est-likelihood}$ the *likelihood function* for iterative phase estimation.</span></span>

<span data-ttu-id="8a99f-158">`Result`Yinelemeli aşama tahmini olasılığı işlevinden bir gözlemleniyorsa, bu gözlemyi takip eden aşamayı ne kadar düşünmemiz gerektiğini görmek Için Bayes kuralını kullanabiliriz.</span><span class="sxs-lookup"><span data-stu-id="8a99f-158">Having observed a `Result` from the iterative phase estimation likelihood function, we can then use Bayes' rule to prescribe what we should believe the phase to be following that observation.</span></span>
<span data-ttu-id="8a99f-159">Concreary, \begin{Equation} \Pr (\phi | d) = \frac{\Pr (d | \fi) \Pr (\fi)} {\int \Pr (d | \fi) \Pr (\fi) {\mathrm d} \phi} \Pr (\fi), \end{Equation} burada $d \in \\ {\Texttt{dd}, \texttt{One} \\ } $ bir `Result` ' dır ve $ \pr (\fi) $ hakkında önceki inanılmaz EFS 'yi $ \phi $ hakkında açıklar.</span><span class="sxs-lookup"><span data-stu-id="8a99f-159">Concretely, \begin{equation} \Pr(\phi | d) = \frac{\Pr(d | \phi) \Pr(\phi)}{\int \Pr(d | \phi) \Pr(\phi){\mathrm d}\phi} \Pr(\phi), \end{equation} where $d \in \\{\texttt{Zero}, \texttt{One}\\}$ is a `Result`, and where $\Pr(\phi)$ describes our prior beliefs about $\phi$.</span></span>
<span data-ttu-id="8a99f-160">Böylece, posterior Distribution $ \Pr (\phi | d) $, bir sonraki gözlemmize hemen önce inanılmaz EFS 'yi tanımlar `Result` .</span><span class="sxs-lookup"><span data-stu-id="8a99f-160">This then makes the iterative nature of iterative phase estimation explicit, as the posterior distribution $\Pr(\phi | d)$ describes our beliefs immediately preceding our observation of the next `Result`.</span></span>

<span data-ttu-id="8a99f-161">Bu yordam sırasında herhangi bir noktada, klasik denetleyici tarafından gösterilen $ \hat{\phi} $ aşamasını \begin{Equation} \hat{\phi} \mathrel{olarak bildirebiliriz: =} \beklenir [\phi | \Text{Data}] = \int \phi \Pr (\phi | \Text{Data}) {\mathrm d} \phi, \end{Equation}; burada $ \Text{Data} $, elde edilen tüm değerlerin tüm kayıtlarını temsil eder `Result` .</span><span class="sxs-lookup"><span data-stu-id="8a99f-161">At any point during this procedure, we can report the phase $\hat{\phi}$ inferred by the classical controller as \begin{equation} \hat{\phi} \mathrel{:=} \expect[\phi | \text{data}] = \int \phi \Pr(\phi | \text{data}) {\mathrm d}\phi, \end{equation} where $\text{data}$ stands for the entire record of all `Result` values obtained.</span></span>

<span data-ttu-id="8a99f-162">Tam Bayeme çıkarımı, uygulama ıntrackingtable içinde.</span><span class="sxs-lookup"><span data-stu-id="8a99f-162">Exact Bayesian inference is in practice intractable.</span></span>
<span data-ttu-id="8a99f-163">Bu Imagine, bir $n $ bit değişkeni $x $ öğrenmek istiyoruz.</span><span class="sxs-lookup"><span data-stu-id="8a99f-163">To see this imagine we wish to learn an $n$-bit variable $x$.</span></span>
<span data-ttu-id="8a99f-164">Önceki dağıtım $ \Pr (x) $, $x $ değerinin $2 ^ n $ kuramsal değerlerini destekler.</span><span class="sxs-lookup"><span data-stu-id="8a99f-164">The prior distribution $\Pr(x)$ has support over $2^n$ hypothetical values of $x$.</span></span>
<span data-ttu-id="8a99f-165">Bu, $x $ tam olarak doğru bir tahmine ihtiyaç duyduğumuz için Bayeme aşaması tahmininde, yüksek bellek ve işlem süresine ihtiyaç duyabileceği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="8a99f-165">This means that if we need a highly accurate estimate of $x$ then Bayesian phase estimation may need prohibitive memory and processing time.</span></span>
<span data-ttu-id="8a99f-166">Örneğin, hisse kaybı benzetimi gibi bazı uygulamalar için, bu tür yöntemler, Shor 'ın algoritması gibi diğer uygulamaların, aşama tahmini adımı içinde tam Bayeduyma çıkarımı kullanamaz.</span><span class="sxs-lookup"><span data-stu-id="8a99f-166">While for some applications, such as quantum simulation, the limitted accuracy required does not preclude such methods other applications, such as Shor's algorithm, cannot use exact Bayesian inference within its phase estimation step.</span></span>  <span data-ttu-id="8a99f-167">Bu nedenle, [rastgele yürüme aşaması Tahmini (RWPE)](xref:microsoft.quantum.research.characterization.randomwalkphaseestimation) gibi yaklaşık bayeme yöntemlerine ve ayrıca [sağlam aşama tahmini](xref:microsoft.quantum.characterization.robustphaseestimation)gibi baysuz olmayan yaklaşımlara yönelik uygulamalar sunuyoruz.</span><span class="sxs-lookup"><span data-stu-id="8a99f-167">For this reason, we also provide implementations for approximate Bayesian methods such as [random walk phase estimation (RWPE)](xref:microsoft.quantum.research.characterization.randomwalkphaseestimation) and also non-Bayesian approaches such as [robust phase estimation](xref:microsoft.quantum.characterization.robustphaseestimation).</span></span>

### <a name="robust-phase-estimation"></a><span data-ttu-id="8a99f-168">Sağlam aşama tahmini</span><span class="sxs-lookup"><span data-stu-id="8a99f-168">Robust Phase Estimation</span></span> ###

<span data-ttu-id="8a99f-169">Ölçüm sonuçlarından bir aşamanın tahmin edilmesi için en büyük *bir posteriori* bayeder yeniden oluşturma, en kötü durum durumunda üstel olarak zordur.</span><span class="sxs-lookup"><span data-stu-id="8a99f-169">A maximum *a posteriori* Bayesian reconstruction of a phase estimate from measurement results is exponentially hard in the worst-case.</span></span> <span data-ttu-id="8a99f-170">Bu nedenle, en pratik aşama tahmin algoritmaları, daha sonra, polynomially ' nin yapılan ölçüm sayısıyla ölçeklendirirken, bir miktar klasik post işleme için Exchange 'de yeniden oluşturma işleminin bazı kalitesini Fede bırakmıştır.</span><span class="sxs-lookup"><span data-stu-id="8a99f-170">Thus most practical phase estimation algorithms sacrifice some quality in the reconstruction, in exchange for an amount of classical post-processing that instead scales polynomially with the number of measurements made.</span></span>

<span data-ttu-id="8a99f-171">Bu tür bir örnek, etkin bir klasik işleme sonrası adımı, imzası ve yukarıda bahsedilen girdileri olan [güçlü aşama tahmini algoritmasıdır](https://arxiv.org/abs/1502.02677).</span><span class="sxs-lookup"><span data-stu-id="8a99f-171">One such example with an efficient classical post-processing step is the [robust phase estimation algorithm](https://arxiv.org/abs/1502.02677), with its signature and inputs mentioned above.</span></span> <span data-ttu-id="8a99f-172">$U $ giriş Unitary siyah kutularının tür olarak paketlenildiği `DiscreteOracle` ve bu nedenle yalnızca denetlenen-$U $ tamsayı üslerini sorgulayan varsayılır.</span><span class="sxs-lookup"><span data-stu-id="8a99f-172">It assumes that input unitary black-boxes $U$ are packaged as `DiscreteOracle` type, and therefore only queries integer powers of controlled-$U$.</span></span> <span data-ttu-id="8a99f-173">Kayıttaki giriş durumu `Qubit[]` bir egenstate $U \ket{\psı} = e ^ {i\phi} \ demet {\ PSI} $ ise, güçlü aşama tahmin algoritması bir tahmin $ \hat{\phi}\in [-\pi, \pı) $ değerini $ \phi $ olarak döndürür `Double` .</span><span class="sxs-lookup"><span data-stu-id="8a99f-173">If the input state in the `Qubit[]` register is an eigenstate $U\ket{\psi}=e^{i\phi}\ket{\psi}$, the robust phase estimation algorithm returns an estimate $\hat{\phi}\in[-\pi,\pi)$ of $\phi$ as a `Double`.</span></span>

<span data-ttu-id="8a99f-174">En önemli kapsamlı aşama tahmini özelliği, diğer birçok yararlı çeşitlerle paylaşılır. $ \hat{\phi} $ öğesinin yeniden yapım kalitesi, bazı sense Heıenberg-Limited ' dir.</span><span class="sxs-lookup"><span data-stu-id="8a99f-174">The most important feature of robust phase estimation, which is shared with most other useful variants, is that the reconstruction quality of $\hat{\phi}$ is in some sense Heisenberg-limited.</span></span> <span data-ttu-id="8a99f-175">Yani, $ \hat{\phi} $ değerinin gerçek değerden $ \sigma $ sapmasıdır, sonra $ \sigma $ ölçeklendirirken, denetlenen-$U $, yani $ \sigma = \mathcal{O} (1/Q) $ ' a yapılan toplam sorgu sayısı ile orantılı olarak $Q.</span><span class="sxs-lookup"><span data-stu-id="8a99f-175">This means that if the deviation of $\hat{\phi}$ from the true value is $\sigma$, then $\sigma$ scales inversely-proportional to the total number of queries $Q$ made to controlled-$U$, i.e. $\sigma=\mathcal{O}(1/Q)$.</span></span> <span data-ttu-id="8a99f-176">Şimdi, sapma tanımı farklı tahmin algoritmaları arasında farklılık gösterir.</span><span class="sxs-lookup"><span data-stu-id="8a99f-176">Now, the definition of deviation varies between different estimation algorithms.</span></span> <span data-ttu-id="8a99f-177">Bazı durumlarda, en az $ \mathcal{O} (1) $ olasılık, tahmin hatası $ | \hat{\phi}-\phi | \_ anlamına gelebilir. \circ\le \sigma $ bir dairesel ölçüde $ \circ $.</span><span class="sxs-lookup"><span data-stu-id="8a99f-177">In some cases, it may mean that with at least $\mathcal{O}(1)$ probability, the estimation error $|\hat{\phi}-\phi|\_\circ\le \sigma$ on some circular measure $\circ$.</span></span> <span data-ttu-id="8a99f-178">Sağlam aşama tahmini için, sapma tam olarak $ \sigma ^ 2 = \mathbb{E} \_ \hat{\phi} [(\mod \_ {2 \ PI} (\hat{\phi}-\phi + \pi)-\pi) ^ 2] $, düzenli aşamaları tek sonlu bir Aralık $ (-\pı</span><span class="sxs-lookup"><span data-stu-id="8a99f-178">For robust phase estimation, deviation is precisely the variance $\sigma^2 = \mathbb{E}\_\hat{\phi}[(\mod\_{2\pi}(\hat{\phi}-\phi +\pi)-\pi)^2]$ if we unwrap periodic phases onto a single finite interval $(-\pi,\pi]$.</span></span> <span data-ttu-id="8a99f-179">Daha kesin olarak, güçlü aşama tahmininde standart sapma, ınekaliteleri karşılar $ $ \begin{hizalaması} 2,0 \pı/Q \ Le \ Sigma \le 2 \ pi/2 ^ {n} \le 10.7 \ Pi/Q, \end{hizalaması} $ $, asentotik büyük $Q $ sınırında alt sınıra ulaşıldığında ve üst sınır küçük örnek boyutları için de garanti edilir.</span><span class="sxs-lookup"><span data-stu-id="8a99f-179">More precisely, the standard deviation in robust phase estimation satisfies the inequalities $$ \begin{align} 2.0 \pi / Q \le \sigma \le 2\pi / 2^{n} \le 10.7\pi / Q, \end{align} $$ where the lower bound is reached in the limit of asymptotically large $Q$, and the upper bound is guaranteed even for small sample sizes.</span></span>  <span data-ttu-id="8a99f-180">$N $ seçili olduğunu belirten `bitsPrecision` $Q $ öğesini örtülü olarak tanımlayan unutmayın.</span><span class="sxs-lookup"><span data-stu-id="8a99f-180">Note that $n$ selected by the `bitsPrecision` input, which implicitly defines $Q$.</span></span>

<span data-ttu-id="8a99f-181">İlgili diğer ayrıntılar, yalnızca $1 $ anileri La qubit 'in küçük alan ek yükünü ya da yordamın Uyarlamalı olduğu anlamına gelir. bu da, gerekli hisse denemeleri dizisi ara ölçü sonuçlarının bağımsızdır.</span><span class="sxs-lookup"><span data-stu-id="8a99f-181">Other relevant details include, say, the small space overhead of just $1$ ancilla qubit, or that the procedure is non-adaptive, meaning the required sequence of quantum experiments is independent of the intermediate measurement outcomes.</span></span> <span data-ttu-id="8a99f-182">Bu ve daha sonra, aşama tahmin algoritması seçiminin önemli olduğu durumlarda, bir diğeri gibi belgelere @"microsoft.quantum.characterization.robustphaseestimation" ve ilgili yayınlar hakkında daha fazla bilgi ve uygulama için başvuru yapmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="8a99f-182">In this and forthcoming examples where the choice of phase estimation algorithm is important, one should one should refer to the documentation such as @"microsoft.quantum.characterization.robustphaseestimation" and the referenced publications therein for more information and for their the implementation.</span></span>

> [!TIP]
> <span data-ttu-id="8a99f-183">Sağlam aşama tahmini kullanıldığı birçok örnek vardır.</span><span class="sxs-lookup"><span data-stu-id="8a99f-183">There are many samples where robust phase estimation is used.</span></span> <span data-ttu-id="8a99f-184">Çeşitli fiziksel sistemin zemin durumu enerji düzeyini çıkartarak aşama tahmini için, lütfen [ **H2 simülasyon** örneğine](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line), [ **simplefon** örneğe](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/simple)ve [ **Hubbard model** örneğine](https://github.com/microsoft/Quantum/tree/main/samples/simulation/hubbard)bakın.</span><span class="sxs-lookup"><span data-stu-id="8a99f-184">For phase estimation in extracting the ground state energy of various physical system, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line), the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/simple), and the [**Hubbard model** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/hubbard).</span></span>


### <a name="continuous-oracles"></a><span data-ttu-id="8a99f-185">Sürekli Oracles</span><span class="sxs-lookup"><span data-stu-id="8a99f-185">Continuous Oracles</span></span> ###

<span data-ttu-id="8a99f-186">Ayrıca, Canon türüne göre modellenen sürekli zamanlı Oracles izin vermek için yukarıda kullanılan Oracle modelinden genelleştireceğiz <xref:microsoft.quantum.oracles.continuousoracle> .</span><span class="sxs-lookup"><span data-stu-id="8a99f-186">We can also generalize from the oracle model used above to allow for continuous-time oracles, modeled by the canon type <xref:microsoft.quantum.oracles.continuousoracle>.</span></span>
<span data-ttu-id="8a99f-187">Tek bir Unitary işleci yerine $U $, $U (t) U (s) $ = $U (t + s) $ gibi $t \\mathbb{R} $ için bir Unitary işleçleri $U (t) $ olduğunu düşünün.</span><span class="sxs-lookup"><span data-stu-id="8a99f-187">Consider that instead of a single unitary operator $U$, we have a family of unitary operators $U(t)$ for $t \in \mathbb{R}$ such that $U(t) U(s)$ = $U(t + s)$.</span></span>
<span data-ttu-id="8a99f-188">Bu, ayrık bir durumdur çünkü <xref:microsoft.quantum.oracles.discreteoracle> \, bazı bir fixed $ \delta t $ için $t = d \ Delta t $ ' ı kısıtlayarak bir oluşturabileceğiz.</span><span class="sxs-lookup"><span data-stu-id="8a99f-188">This is a weaker statement than in the discrete case, since we can construct a <xref:microsoft.quantum.oracles.discreteoracle> by restricting $t = m\,\delta t$ for some fixed $\delta t$.</span></span>
<span data-ttu-id="8a99f-189">[Stone 'ın Theokal](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U (t) = \exp (i H t) $ işleci, $H $, burada $ \exp $, [Gelişmiş matrislerde](xref:microsoft.quantum.concepts.matrix-advanced)açıklanan matris üstel.</span><span class="sxs-lookup"><span data-stu-id="8a99f-189">By [Stone's theorem](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U(t) = \exp(i H t)$ for some operator $H$, where $\exp$ is the matrix exponential as described in [advanced matrices](xref:microsoft.quantum.concepts.matrix-advanced).</span></span>
<span data-ttu-id="8a99f-190">$H \ket{\phi} = \phi \ket{\phi} $ gibi bir eigenstate $ \ket{\phi} $H $, ayrıca tüm $t $ için bir $U (t) $, \begin{Equation} U (t) \ket{\phi} = e ^ {ı \phi t} \ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="8a99f-190">An eigenstate $\ket{\phi}$ of $H$ such that $H \ket{\phi} = \phi \ket{\phi}$ is then also an eigenstate of $U(t)$ for all $t$, \begin{equation} U(t) \ket{\phi} = e^{i \phi t} \ket{\phi}.</span></span>
<span data-ttu-id="8a99f-191">\end{Equation}</span><span class="sxs-lookup"><span data-stu-id="8a99f-191">\end{equation}</span></span>

<span data-ttu-id="8a99f-192">[Bayeduyma aşaması tahmini](#bayesian-phase-estimation) için ele alınan tam aynı analiz uygulanabilir ve bu daha genel Oracle modeli için olasılık işlevi tam olarak aynıdır: $ $ \pr (\Texttt{sıfırlaması} | \fi; t, \teta) = \cos ^ 2 \ Left (\frac{t [\phi-\teta]} {2} \right).</span><span class="sxs-lookup"><span data-stu-id="8a99f-192">The exact same analysis discussed for [Bayesian phase estimation](#bayesian-phase-estimation) can be applied, and the likelihood function is the precisely the same for this more general oracle model: $$ \Pr(\texttt{Zero} | \phi; t,\theta)=\cos^2\left(\frac{t[\phi -\theta]}{2}\right).</span></span>
<span data-ttu-id="8a99f-193">$ $ Üstelik, $U $ bir dinamik oluşturucusunun simülasyonu ise, [Hamiltonian simülasyonu](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation)gibi, $ \phi $ değerini enerji olarak yorumlarız.</span><span class="sxs-lookup"><span data-stu-id="8a99f-193">$$ Moreover, if $U$ is a simulation of a dynamical generator, as is the case for [Hamiltonian simulation](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), we interpret $\phi$ as an energy.</span></span>
<span data-ttu-id="8a99f-194">Bu nedenle, sürekli sorgular ile aşama tahmini kullanmak, $t $ ' ın bir tamsayı olmasını gerektirerek denemeleri seçimimizi tehlikeye duymadan, [kupacules](https://arxiv.org/abs/quant-ph/0604193), [malzemeler](https://arxiv.org/abs/1510.03859) veya [alan](https://arxiv.org/abs/1111.3633v2) törlerinin sanal enerji yelpazesini öğrenmemizi sağlar.</span><span class="sxs-lookup"><span data-stu-id="8a99f-194">Thus, using phase estimation with continuous queries allows us to learn the simulated [energy spectrum of molecules](https://arxiv.org/abs/quant-ph/0604193), [materials](https://arxiv.org/abs/1510.03859) or [field theories](https://arxiv.org/abs/1111.3633v2) without having to compromise our choice of experiments by requiring $t$ to be an integer.</span></span>

### <a name="random-walk-phase-estimation"></a><span data-ttu-id="8a99f-195">Rastgele yürüme aşaması tahmini</span><span class="sxs-lookup"><span data-stu-id="8a99f-195">Random Walk Phase Estimation</span></span> ###

<span data-ttu-id="8a99f-196">Q# yinelemeli aşama tahmininizden elde edilen veri kaydı üzerinde rastgele bir adım adım şekilde çalışan hisse için yakın bir işlem tahmini olan Bayeme aşaması tahminimizin yararlı bir şekilde kullanılmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="8a99f-196">Q# provides a useful approximation of Bayesian phase estimation designed for use close to quantum devices that operates by conditioning a random walk on the data record obtained from iterative phase estimation.</span></span>
<span data-ttu-id="8a99f-197">Bu yöntem hem Uyarlamalı hem de tamamen belirleyici olduğundan, tahmini aşama $ \hat{\phi} $ içindeki hataların neredeyse en iyi şekilde ölçeklendirilmesine olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="8a99f-197">This method is both adaptive and entirely deterministic, allowing for near-optimal scaling of errors in the estimated phase $\hat{\phi}$ with very low memory overheads.</span></span>

<span data-ttu-id="8a99f-198">Protokol, önceki dağıtımın Gauss olduğunu varsayan yaklaşık bir Bayeme çıkarım yöntemi kullanır.</span><span class="sxs-lookup"><span data-stu-id="8a99f-198">The protocol uses an approximate Bayesian inference method that assumes the prior distribution is Gaussian.</span></span>
<span data-ttu-id="8a99f-199">Bu Gauss varsayım, posterior farkını en aza indiren deneme için bir analitik formül kullanmamızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="8a99f-199">This Gaussian assumption allows us to use an analytical formula for the experiment that minimizes the posterior variance.</span></span>
<span data-ttu-id="8a99f-200">Daha sonra bu deneme sonucuna bağlı olarak, $ \phi $ ' ın tahminini, önceden belirlenen bir miktara göre kaydırır ve varyansı önceden belirlenen bir miktara küçültür.</span><span class="sxs-lookup"><span data-stu-id="8a99f-200">The algorithm then, based on the outcome of that experiment, shifts the estimate of $\phi$ left or right by a pre-determined amount and shrinks the variance by a pre-determined amount.</span></span>
<span data-ttu-id="8a99f-201">Bu ortalama ve varyans, sonraki deneyinin $ \phi $ ' den önceki bir Gauss belirtmek için gereken tüm bilgileri verir.</span><span class="sxs-lookup"><span data-stu-id="8a99f-201">This mean and variance give all the information that is needed to specify a Gaussian prior on $\phi$ for the next experiment.</span></span>
<span data-ttu-id="8a99f-202">Beklenmeyen ölçüm hatası sayısı veya bunun öncesinde başlangıçtaki uçlar üzerinde olan gerçek sonuç, bu yöntemin başarısız olmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="8a99f-202">Unexpected measurement failures, or the true result being on the tails of the initial prior, can cause this method to fail.</span></span>
<span data-ttu-id="8a99f-203">Geçerli ortalama ve standart sapmanın sistem için uygun olup olmadığını test etmek için denemeleri gerçekleştirerek hata durumundan kurtarır.</span><span class="sxs-lookup"><span data-stu-id="8a99f-203">It recovers from failure by performing experiments to test whether the current mean and standard deviation are appropriate for the system.</span></span>
<span data-ttu-id="8a99f-204">Aksi takdirde, algoritma izlenecek bir ters adım yapar ve işlem devam eder.</span><span class="sxs-lookup"><span data-stu-id="8a99f-204">If they are not, then the algorithm does an inverse step of the walk and the process continues.</span></span>
<span data-ttu-id="8a99f-205">Geriye doğru ilerleyebilme özelliği, ilk önceki standart sapma inapropriately küçük olsa bile algoritmanın öğrenmesi için de izin verir.</span><span class="sxs-lookup"><span data-stu-id="8a99f-205">The ability to step backwards also allows the algorithm to learn even if the initial prior standard deviation is inapropriately small.</span></span>

## <a name="calling-phase-estimation-algorithms"></a><span data-ttu-id="8a99f-206">Aşama tahmini algoritmaları çağırma</span><span class="sxs-lookup"><span data-stu-id="8a99f-206">Calling Phase Estimation Algorithms</span></span> ##

<span data-ttu-id="8a99f-207">Canon ile birlikte sunulan her aşama tahmin işlemi, Q# son tahmin $ \hat{\phi} $ ' i talep ettiğimiz kaliteyi karşılayan farklı bir giriş kümesi alır.</span><span class="sxs-lookup"><span data-stu-id="8a99f-207">Each phase estimation operation provided with the Q# canon takes a different set of inputs parameterizing the quality that we demand out of the final estimate $\hat{\phi}$.</span></span>
<span data-ttu-id="8a99f-208">Bununla birlikte, bu çeşitli girişler ortak bir şekilde yaygın bir şekilde yapılır, bu da kalite parametrelerinin üzerindeki kısmi uygulama ortak bir imzaya neden olur.</span><span class="sxs-lookup"><span data-stu-id="8a99f-208">These various inputs, however, all share several inputs in common, such that partial application over the quality parameters results in a common signature.</span></span>
<span data-ttu-id="8a99f-209">Örneğin, <xref:microsoft.quantum.characterization.robustphaseestimation> sonraki bölümde ele alınan işlem aşağıdaki imzaya sahiptir:</span><span class="sxs-lookup"><span data-stu-id="8a99f-209">For example, the <xref:microsoft.quantum.characterization.robustphaseestimation> operation discussed in the next section has the following signature:</span></span>

```qsharp
operation RobustPhaseEstimation(bitsPrecision : Int, oracle : DiscreteOracle, eigenstate : Qubit[])  : Double
```

<span data-ttu-id="8a99f-210">`bitsPrecision`Giriş, `RobustPhaseEstimation` ,, `oracle` ve `eigenstate` ortak olarak benzersizdir.</span><span class="sxs-lookup"><span data-stu-id="8a99f-210">The `bitsPrecision` input is unique to `RobustPhaseEstimation`, while `oracle` and `eigenstate` are in common.</span></span>
<span data-ttu-id="8a99f-211">Bu nedenle, **H2Sample**' de görüldüğü gibi bir işlem, `(DiscreteOracle, Qubit[]) => Unit` bir kullanıcının rastgele aşama tahmin algoritmaları belirtmesini sağlamak için formun bir girişi ile yinelemeli bir aşama tahmini algoritması kabul edebilir:</span><span class="sxs-lookup"><span data-stu-id="8a99f-211">Thus, as seen in **H2Sample**, an operation can accept an iterative phase estimation algorithm with an input of the form `(DiscreteOracle, Qubit[]) => Unit` to allow a user to specify arbitrary phase estimation algorithms:</span></span>

```qsharp
operation H2EstimateEnergy(
    idxBondLength : Int,
    trotterStepSize : Double,
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double
```

<span data-ttu-id="8a99f-212">Bu sayısız aşaması tahmin algoritmaları, hedef uygulama için en iyi seçimi yapmak üzere anlaşılması gereken farklı özellikler ve giriş parametreleri için iyileştirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="8a99f-212">These myriad phase estimation algorithms are optimized for different properties and input parameters, which must be understood to make the best choice for the target application.</span></span> <span data-ttu-id="8a99f-213">Örneğin, bazı aşama tahmin algoritmaları Uyarlamalı olur. Bu, gelecekteki adımların önceki adımların ölçüm sonuçlarıyla ilgili olarak daha önce kontrol edilebileceği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="8a99f-213">For instance, some phase estimation algorithms are adaptive, meaning that future steps are classically controlled by the measurement results of previous steps.</span></span> <span data-ttu-id="8a99f-214">Bazıları, siyah kutu Unitary Oracle 'ı rastgele gerçek üslere göre üslendirir ve diğerleri yalnızca tamsayı gücüne ihtiyaç duyar, ancak yalnızca bir aşama tahmin mod $2 \ PI $ ' ı çözümleyebilir.</span><span class="sxs-lookup"><span data-stu-id="8a99f-214">Some require the ability to exponentiate its black-box unitary oracle by arbitrary real powers, and others only require integer powers but are only able to resolve a phase estimate modulo $2\pi$.</span></span> <span data-ttu-id="8a99f-215">Bazıları çok sayıda yardımcı qubit gerektirir ve diğerleri yalnızca bir tane gerektirir.</span><span class="sxs-lookup"><span data-stu-id="8a99f-215">Some require many auxiliary qubits, and others require only one.</span></span>

<span data-ttu-id="8a99f-216">Benzer şekilde, rastgele yürüme aşaması tahmini, Canon ile sunulan diğer algoritmalarda çok benzer şekilde devam eder:</span><span class="sxs-lookup"><span data-stu-id="8a99f-216">Similarly, using random walk phase estimation proceeds in much the same way as for other algorithms provided with the canon:</span></span>

```qsharp
operation ApplyExampleOracle(
    eigenphase : Double,
    time : Double,
    register : Qubit[])
: Unit is Adj + Ctl {
    Rz(2.0 * eigenphase * time, register[0]);
}

operation EstimateBayesianPhase(eigenphase : Double) : Double {
    let oracle = ContinuousOracle(ApplyExampleOracle(eigenphase, _, _));
    using (eigenstate = Qubit()) {
        X(eigenstate);
        // The additional inputs here specify the mean and variance of the prior, the number of
        // iterations to perform, how many iterations to perform as a maximum, and how many
        // steps to roll back on an approximation failure.
        let est = RandomWalkPhaseEstimation(0.0, 1.0, 61, 100000, 1, oracle, [eigenstate]);
        Reset(eigenstate);
        return est;
    }
}
```
