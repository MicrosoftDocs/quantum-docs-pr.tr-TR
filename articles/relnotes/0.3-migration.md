---
title: QDK 0,3 dil Inceleme ve geçiş kılavuzu
author: beheim
uid: microsoft.quantum.relnotes.migration-0-3
ms.author: bettina.heim@microsoft.com
ms.date: 10/29/2018
ms.topic: article
ms.openlocfilehash: 6c19f31970ff5440432c5bb3d00e6a7d0eba1e80
ms.sourcegitcommit: aa5e6f4a2deb4271a333d3f1b1eb69b5bb9a7bad
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/02/2019
ms.locfileid: "73442180"
---
# <a name="qdk-03-language-release-notes-and-migration-guide"></a><span data-ttu-id="f0b6b-102">QDK 0,3 dil sürüm notları ve geçiş kılavuzu</span><span class="sxs-lookup"><span data-stu-id="f0b6b-102">QDK 0.3 language release notes and migration guide</span></span>

<span data-ttu-id="f0b6b-103">Hisse geliştirme paketine en yeni güncelleştirmeyi tanıtmak için heyecanlıyız.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-103">We are excited to introduce the newest update to the Quantum Development Kit.</span></span>  <span data-ttu-id="f0b6b-104">Bu sayfa, yeni Q # dil özelliklerine genel bir bakış sağlar ve var olan Q # programlarını yeni sözdizimine nasıl [geçirebileceğinizi](#Migration) açıklar.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-104">This page gives an overview of the new Q# language features and describes how to [migrate](#Migration) existing Q# programs to the new syntax.</span></span>  <span data-ttu-id="f0b6b-105">[Burada](xref:microsoft.quantum.language.intro)Q # dilinin tam açıklaması için tam belgelerimize bakın.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-105">See our complete documentation for the full description of the Q# language [here](xref:microsoft.quantum.language.intro).</span></span>


## <a name="whats-new"></a><span data-ttu-id="f0b6b-106">Yenilikler</span><span class="sxs-lookup"><span data-stu-id="f0b6b-106">What's New</span></span> 

<span data-ttu-id="f0b6b-107">0,3 güncelleştirmesi bir dizi yeni dil ve düzenleyici özelliği ile birlikte gelir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-107">The 0.3 update comes with a range of new language and editor features.</span></span>

### <a name="overview-of-features"></a><span data-ttu-id="f0b6b-108">Özelliklere genel bakış</span><span class="sxs-lookup"><span data-stu-id="f0b6b-108">Overview of Features</span></span>

- <span data-ttu-id="f0b6b-109">Visual Studio ve Visual Studio Code için gelişmiş geliştirme aracı tümleştirmesi, aşağıdakiler dahil:</span><span class="sxs-lookup"><span data-stu-id="f0b6b-109">Enhanced development tool integration for Visual Studio and Visual Studio Code, including:</span></span>
    - <span data-ttu-id="f0b6b-110">Yazarken canlı derleme ve geri bildirim (*deyişle*</span><span class="sxs-lookup"><span data-stu-id="f0b6b-110">Live compilation and feedback on typing (*a.k.a.*</span></span> <span data-ttu-id="f0b6b-111">dalgalı alt çizgi).</span><span class="sxs-lookup"><span data-stu-id="f0b6b-111">squiggly underlining).</span></span>
    - <span data-ttu-id="f0b6b-112">Belge özetleri ve tür imzaları dahil olmak üzere üzerine gelme bilgileri.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-112">Hover information including documentation summaries and type signatures.</span></span>
    - <span data-ttu-id="f0b6b-113">Tanıma Git desteği.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-113">Support for go to definition.</span></span>
    - <span data-ttu-id="f0b6b-114">Ad alanı, işlem, işlev ve tür bildirimlerine kolay gezinme.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-114">Easy navigation to namespace, operation, function, and type declarations.</span></span>
    - <span data-ttu-id="f0b6b-115">İyileştirilmiş tanılama iletileri.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-115">Improved diagnostic messages.</span></span>
- <span data-ttu-id="f0b6b-116">Dil geliştirmeleri</span><span class="sxs-lookup"><span data-stu-id="f0b6b-116">Language improvements</span></span>
    - <span data-ttu-id="f0b6b-117">Tek qubit ve tanımlama grubu, kullanma ve ödünç alma içinde başlatmaları</span><span class="sxs-lookup"><span data-stu-id="f0b6b-117">Single qubit and tuple initializations within using and borrowing</span></span>
    - <span data-ttu-id="f0b6b-118">Tüm atamalar üzerinde demet oluşturmayı kaldırma</span><span class="sxs-lookup"><span data-stu-id="f0b6b-118">Tuple deconstruction on all assignments</span></span>
    - <span data-ttu-id="f0b6b-119">Diziler üzerinde yineleme</span><span class="sxs-lookup"><span data-stu-id="f0b6b-119">Iteration over arrays</span></span>
    - <span data-ttu-id="f0b6b-120">Koşullu ifadeler</span><span class="sxs-lookup"><span data-stu-id="f0b6b-120">Conditional expressions</span></span>
    - <span data-ttu-id="f0b6b-121">Varsayılan-işlemler için özelleştirme kısaltması</span><span class="sxs-lookup"><span data-stu-id="f0b6b-121">Default-specialization abbreviation for operations</span></span>
    - <span data-ttu-id="f0b6b-122">Otomatik olarak oluşturulan tür oluşturucuları</span><span class="sxs-lookup"><span data-stu-id="f0b6b-122">Auto-generated type constructors</span></span>
    - <span data-ttu-id="f0b6b-123">İfade değiştiricileri</span><span class="sxs-lookup"><span data-stu-id="f0b6b-123">Expression modifiers</span></span>


## <a name="editor-features"></a><span data-ttu-id="f0b6b-124">Düzenleyici özellikleri</span><span class="sxs-lookup"><span data-stu-id="f0b6b-124">Editor Features</span></span>

<span data-ttu-id="f0b6b-125">Hisse geliştirme kiti artık Q # için bir dil sunucusu ve ayrıca Visual Studio için istemci tümleştirmeleri ve Visual Studio Code içerir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-125">The Quantum Development Kit now includes a language server for Q#, as well as the client integrations for Visual Studio and Visual Studio Code.</span></span>
<span data-ttu-id="f0b6b-126">Bu, hata ve uyarıların dalgalı alt çizgileri biçiminde yazmaya yönelik canlı geri bildirimin yanı sıra yeni IntelliSense özellikleriyle yazma olanağı tanır.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-126">This enables a new set of IntelliSense features along with live feedback on typing in form of squiggly underlinings of errors and warnings.</span></span>
<span data-ttu-id="f0b6b-127">Özellikle, tanım ' a git desteklenir ve tür bilgilerinin yanı sıra, belgeleme açıklamalarından bilgiler içeren, üzerine gelme bilgileri görüntülenir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-127">In particular, go to definition is now supported and hover information is displayed containing type information as well as information from documenting comments.</span></span> <span data-ttu-id="f0b6b-128">Ayrıca, tanımlı ad alanları, işlemler, işlevler ve türler ile ilgili sembol bilgileri mevcuttur ve bildirimlerle hızlı bir şekilde gezinmenize olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-128">Additionally, symbol information about defined namespaces, operations, functions, and types is available and allows to quickly navigate to declarations.</span></span>    
<span data-ttu-id="f0b6b-129">Bu güncelleştirme, tanılama için kolay gezinti ve hassas aralıklar ve öğenin üzerine gelindiğinde gösterilen ek ayrıntılar ile tanılama iletilerini büyük ölçüde geliştirir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-129">This update greatly improves diagnostic messages in general, with easy navigation to and precise ranges for diagnostics and additional details in the displayed hover information.</span></span> 

<span data-ttu-id="f0b6b-130">Bu 0,3 sürümü için, hisse geliştirme kiti 'Ne dahil edilen dil sunucusu birden çok çalışma alanını desteklemez.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-130">For this 0.3 release, the language server included with the Quantum Development Kit does not support multiple workspaces.</span></span>
<span data-ttu-id="f0b6b-131">VS Code bir projeyle çalışmak için, projenin kendisini içeren kök klasörü ve tüm başvurulan projeleri açın.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-131">In order to work with a project in VS Code, open the root folder containing the project itself and all referenced projects.</span></span>
<span data-ttu-id="f0b6b-132">Visual Studio Code’da bir çözüm üzerinde çalışmak için çözümde yer alan tüm projelerin çözüm ile aynı klasörde veya bunun bir alt klasöründe olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-132">In order to work with a solution in Visual Studio, all projects contained in the solution need to be in the same folder as the solution or in one of its subfolders.</span></span>

## <a name="language-features"></a><span data-ttu-id="f0b6b-133">Dil özellikleri</span><span class="sxs-lookup"><span data-stu-id="f0b6b-133">Language Features</span></span>

<span data-ttu-id="f0b6b-134">Dil özellikleri açısından, bu güncelleştirme bir dil desenleri aralığının kullanımını birleştirir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-134">In terms of language features, this update unifies the treatment of a range of language patterns.</span></span>
<span data-ttu-id="f0b6b-135">Tür oluşturucuları, örnek olarak, her kullanıcı tanımlı tür için oluşturulur ve herhangi bir diğer işlev gibi kısmen uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-135">Type constructors, as an example, are generated for each user defined type and can be partially applied much like any other function.</span></span>
<span data-ttu-id="f0b6b-136">Diğer bir örnek, artık tüm atamalar içinde tam olarak desteklenen demet oluşturma ' dır.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-136">Another example is tuple deconstruction, which is now fully supported within all assignments.</span></span> <span data-ttu-id="f0b6b-137">Bu, yalnızca Let-, kesilebilir-ve set deyimlerinin yanı sıra, for-döngüleri içindeki yineleme değişkenini ve ayrıca, ve ödünç alınan ayırmaları de içerir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-137">This includes not only let-, mutable-, and set-statements, but also the iteration variable in for-loops as well as using- and borrowing-allocations.</span></span> <span data-ttu-id="f0b6b-138">Ayrıca, kısmi ayrıştırmaları, 0,3 güncelleştirmesiyle yeni desteklenir; ayrıştırmaları içindeki alt çizgiler, yoksayılacak değerin parçalarını gösterir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-138">Additionally, partial deconstructions are newly supported with the 0.3 update; underscores in deconstructions indicate parts of the value that are to be ignored.</span></span> 

<span data-ttu-id="f0b6b-139">Aşağıdaki kod yeni özelliklerden bazılarını göstermektedir:</span><span class="sxs-lookup"><span data-stu-id="f0b6b-139">The following code illustrates some of the new features:</span></span>
```qsharp
    let tuples = [(1, 0), (0, 1)];
    mutable res = (0, 0, 0);

    // For-loops can iterate over arrays, and can destructure tuples.
    for ((i1, i2) in tuples) {

        // Mutable assignments can now destructure and ignore parts of tuples,
        // using the same syntax as let-bindings.
        mutable (r1, r2, _) = res;
        set (r1, r2) = (r1 ||| i1, r2 &&& i2);

        let (_, _, s) = res;
        // The new conditional operator can be used inside expressions, avoiding
        // the need for extraneous if-statements.
        set res = (r1, r2, r1 == r2 ? s | s + 1);
    }
```
<span data-ttu-id="f0b6b-140">Son küme deyimi, Koşullu ifadeleri desteklemek için 0,3 güncelleştirmesiyle birlikte sunulan yeni bir üçlü operatör kullanır.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-140">The last set statement uses a new ternary operator that is introduced with the 0.3 update to support conditional expressions.</span></span>
<span data-ttu-id="f0b6b-141">Koşullu ifade `condition ? caseTrue | caseFalse`formun bir ifadesidir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-141">A conditional expression is an expression of the form `condition ? caseTrue | caseFalse`.</span></span>
<span data-ttu-id="f0b6b-142">Yukarıdaki örnekte görünebileceğini de, diziler üzerinde yineleme de desteklenir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-142">As can be seen from the example above, iteration over arrays is now also supported.</span></span>

<span data-ttu-id="f0b6b-143">`using` ve `borrowing` içindeki ayırmalar, tek qubits, qubit dizileri ve iç içe geçmiş tanımlama alanları için yeni bir olanaklardır:</span><span class="sxs-lookup"><span data-stu-id="f0b6b-143">Allocations within `using` and `borrowing` are newly possible for single qubits, qubit arrays, and nested tuples thereof:</span></span>
```qsharp
    using (q = Qubit()) {
        // q contains a single qubit
    }

    borrowing ((cs, q) = (Qubit[3], Qubit())) {
        // cs contains an array of three qubits, and q contains a single qubit
    }
```

<span data-ttu-id="f0b6b-144">İki yeni özelleşme yönergesi `invert` ve `distribute` `auto` ek olarak, functor uzmanlıklarıyla olan denetim düzeyini artırmak için sunulmuştur.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-144">Two new specialization generator directives `invert` and `distribute` in addition to `auto` are introduced to increase control over how functor specializations are generated.</span></span>
<span data-ttu-id="f0b6b-145">İşlemler içindeki varsayılan `body` özelleştirmenin açık bildirimi artık zorunlu değildir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-145">An explicit declaration of the default `body` specialization within operations is no longer mandatory.</span></span>
<span data-ttu-id="f0b6b-146">İşlevlere benzer şekilde, işlem içinde başka bir özelleştirme bildirilemediği takdirde, deyimlere benzer şekilde doğrudan işlem bildirimine eklenebilir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-146">Similar to functions, statements may be directly added to the operation declaration itself if no other specialization is declared within the operation.</span></span>
<span data-ttu-id="f0b6b-147">Sürüme, mevcut kodu geçirmeye ve yeni dil özelliklerinden faydalanmasına yardımcı olmak için bir geçiş betiği eklenmiştir ( [geçiş betiğinin bölümüne](#MigrationScript)bakın).</span><span class="sxs-lookup"><span data-stu-id="f0b6b-147">A migration script is included in the release to help migrating existing code and taking advantage of new language features (see the [section on the migration script](#MigrationScript)).</span></span>

<span data-ttu-id="f0b6b-148">Kullanıcı tanımlı türlerin 0,3 güncelleştirmesiyle birlikte kabul edildiği önemli bir değişiklik.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-148">A major change in how user-defined types are treated comes with the 0.3 update.</span></span> <span data-ttu-id="f0b6b-149">Önceki yayınlar, Kullanıcı tanımlı türleri kendi temel türlerinin alt türleri olarak kabul ederken, bu durum artık iletme durumunda değildir (Ayrıca, değişiklikler Yukarıdaki [bölüme](#BreakingChanges)bakın).</span><span class="sxs-lookup"><span data-stu-id="f0b6b-149">While prior releases treated user defined types as subtypes of their underlying type, this is no longer the case going forward (see also the [section on breaking changes](#BreakingChanges)).</span></span>  
<span data-ttu-id="f0b6b-150">Bu değişikliğin bir parçası olarak, belirli ifadelere uygulanabilen ifade değiştiricileri sunuyoruz.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-150">As part of this change we introduce expression modifiers that can be applied to certain expressions.</span></span> <span data-ttu-id="f0b6b-151">Değiştiricilerin uygulandığı "atomik" ifadeler, tanımlayıcılar, dizi öğesi ifadeleri ve parametre sayısı-1 tanımlama grupları olabilir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-151">The "atomic" expressions that modifiers can be applied to are identifiers, array item expressions, and arity-1 tuples.</span></span>
<span data-ttu-id="f0b6b-152">Değiştiriciler, Combinator başka bir ifadeden daha sıkı bağlar ve `(` `)`çağrı ifadesi Combinator.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-152">Modifiers bind tighter than any other expression combinator, and in particular tighter than the call-expression combinator `(` `)`.</span></span> 
<span data-ttu-id="f0b6b-153">`Adjoint`, `Controlled`ve yeni bir "sarmalama" sonek işleci `!` ifade değiştiricileri olarak değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-153">`Adjoint`, `Controlled`, and a new "unwrap" postfix operator `!` are treated as expression modifiers.</span></span> <span data-ttu-id="f0b6b-154">`Adjoint` ve `Controlled` ifade değiştiricileri olarak davranma, çok sayıda durum için parantez gereksinimini ortadan kaldırır.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-154">Treating `Adjoint` and `Controlled` as expression modifiers eliminates the need for parenthesis for a lot of cases.</span></span> <span data-ttu-id="f0b6b-155">Örneğin, aşağıdaki ifadeler `Op`, bir unitöğeli işlem `opArr` bir Unitary işlemleri dizisi ve uygun bir bağımsız değişken `arg` için geçerlidir:</span><span class="sxs-lookup"><span data-stu-id="f0b6b-155">The expressions below for example are valid going forward for `Op`, a unitary operation, `opArr` an array of unitary operations, and `arg` a suitable argument:</span></span> 
```qsharp
    Adjoint Op (arg);
    Controlled opArr[i] (arg);
```
<span data-ttu-id="f0b6b-156">Geçiş betiği, gereksiz parantezleri büyük bir kısmını bırakacak ve yeni özelliklerden tam olarak yararlanacaktır.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-156">The migration script will drop most of the unnecessary parenthesis and take full advantage of the new features.</span></span> <span data-ttu-id="f0b6b-157">Ancak, betiğin kodu yorumlamaması ve nadir olarak `Controlled` functor (yalnızca kısmi uygulamalarla birlikte ilgili) için farklı bir şekilde yorumlanmayacak şekilde hesaba sahip olmaması önerilir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-157">However, be advised that the script does not interpret the code, and will not account for the different interpretation of the `Controlled` functor in rare cases (only relevant in combination with partial applications).</span></span>

<span data-ttu-id="f0b6b-158">Yeni değiştirici `!` kendi temel türüne Kullanıcı tanımlı bir tür yayınlar.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-158">The new modifier `!` casts a user-defined type to its underlying type.</span></span> <span data-ttu-id="f0b6b-159">Bu atama önceki sürümlerde bir upcast olarak kabul edildi ve otomatik olarak yürütüldü.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-159">This cast has been considered an upcast in previous releases and was executed automatically.</span></span> <span data-ttu-id="f0b6b-160">Kullanıcı tanımlı türlerin yeni yorumu ile bu durum artık böyle değildir ve dönüştürmenin açık yapılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-160">With the new interpretation of user defined types this is no longer the case and the cast needs to be made explicit.</span></span>    
<span data-ttu-id="f0b6b-161">Aşağıdaki örnek, yeni değiştiricinin nasıl kullanılacağını göstermektedir:</span><span class="sxs-lookup"><span data-stu-id="f0b6b-161">The following example illustrates how to use the new modifier:</span></span> 
```qsharp
    newtype Unitary = (Qubit => Unit: Adjoint, Controlled);

    operation Foo (unitaries : Unitary[], q : Qubit) : Unit {

        for (unitary in unitaries[1 .. Length(unitaries)-1]) {
            // Each element of unitaries is an instance of the user-defined
            // type Unitary, so unitary! unwraps each element to an operation
            // type that we can call.
            unitary! (q);
            // The unwrap operator can also be used as a part of functor
            // expressions and when indexing into arrays.
            Adjoint unitary! (q);
            Adjoint unitaries[0]! (q);
        }
    }
```
<span data-ttu-id="f0b6b-162">Örnekte görüldüğü gibi, `!` `Controlled` ve `Adjoint`gibi önek değiştiricilerinden daha sıkı bir şekilde bağlanır.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-162">As can be seen from the example, `!` binds tighter than prefix modifiers, like `Controlled` and `Adjoint`.</span></span>

## <a name="BreakingChanges"></a><span data-ttu-id="f0b6b-163">Son değişiklikler</span><span class="sxs-lookup"><span data-stu-id="f0b6b-163">Breaking Changes</span></span> 

<span data-ttu-id="f0b6b-164">0,3 güncelleştirmesi yeni bir derleyici ile birlikte gelir ve bir çok büyük değişiklikler içerir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-164">The 0.3 update comes with a new compiler and contains a handful of breaking changes.</span></span>
<span data-ttu-id="f0b6b-165">Derleyici, var olan kodun güncelleştirilmesini kolaylaştırmak için geçerli veya geçersiz kodu derlenen bir biçimlendirme seçeneği de sağlar ve oluşturulan derlemeye göre biçimlendirilmiş Q # kodunu yayar.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-165">To facilitate updating existing code, the compiler also provides a formatting option that compiles valid or invalid code and emits formatted Q# code based on the built compilation.</span></span>
<span data-ttu-id="f0b6b-166">Tüm sözdizimi değişiklikleri, belirtilen araç tarafından otomatik olarak işlenecek.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-166">All syntax changes will be processed automatically by the provided tool.</span></span> <span data-ttu-id="f0b6b-167">Ancak, geçerli kodun yorumlandığı (anlamsal değişiklikler) değişikliklerin el ile yapılması gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-167">However, changes in how valid code is interpreted (semantic changes) may need to be made manually.</span></span> 

<span data-ttu-id="f0b6b-168">Aşağıda listelenen değişikliklere ek olarak, `__*__`, \* öğesinin boşluk olmayan karakterlerin herhangi bir dizisi iç kullanım için ayrılmıştır ve sembol adı olarak kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-168">In addition to the changes listed below, the pattern `__*__` where \* is any sequence of non-whitespace characters is reserved for internal use and cannot be used as a symbol name.</span></span>  

## <a name="syntax-changes"></a><span data-ttu-id="f0b6b-169">Söz dizimi değişiklikleri</span><span class="sxs-lookup"><span data-stu-id="f0b6b-169">Syntax Changes</span></span> 

- <span data-ttu-id="f0b6b-170">Sürüm 0,3 ' den başlayarak, dizi öğeleri artık noktalı virgülle ayrılır, ancak bunun yerine virgülle ayrılır.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-170">Starting with the version 0.3, array items are no longer separated by semicolons, but are separated by commas instead.</span></span>
- <span data-ttu-id="f0b6b-171">Özelleştirme bildirimleri için otomatik oluşturma yönergesinden sonra diğer taraftan noktalı virgül gerekir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-171">A semicolon on the other hand is required after an auto-generation directive for specialization declarations.</span></span>
- <span data-ttu-id="f0b6b-172">İf-, Elif-ve Until-yan tümcelerinde koşullar parantez içinde kapsüllenmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-172">Conditions in if-, elif-, and until-clauses need to be encapsulated in parenthesis.</span></span> 

<span data-ttu-id="f0b6b-173">Diğer tüm sözdizimi değişiklikleri için derleyici, eski sözdizimi kullanılırsa yalnızca bir uyarı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-173">For all other syntax changes the compiler will simply generate a warning if the old syntax is used.</span></span>     
<span data-ttu-id="f0b6b-174">Böyle bir değişiklik için bir örnek, Kullanıcı tanımlı uzmanlıkdaki sembol tanımlama grubu ' dir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-174">One example for such a change is the symbol tuple in user-defined specializations.</span></span> <span data-ttu-id="f0b6b-175">Önceki sürümlerde denetlenen veya denetlenen-adjoint özelleştirmesi bildirimi tek bir symbol bağımsız değişkeni belirtti, 0,3 ' `...` den başlayarak, derleyicinin gerekirse, simgelerin çağrılabilir bildiriminden geçirilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-175">While in previous releases a controlled or controlled-adjoint specialization declaration specified a single symbol argument, starting in 0.3 it is encouraged to provide such a symbol tuple for all specialization with `...` indicating that the compiler should migrate the symbols from the callable declaration if needed.</span></span> 

## <a name="semantic-changes"></a><span data-ttu-id="f0b6b-176">Anlamsal değişiklikler</span><span class="sxs-lookup"><span data-stu-id="f0b6b-176">Semantic Changes</span></span> 

<span data-ttu-id="f0b6b-177">0,3 sürümünün en etkili kıran bölünmesi, Kullanıcı tanımlı türlerin tür sistemiyle tümleştirildiği bir sürümdür.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-177">The most impactful breaking for the 0.3 release is how user-defined types are integrated into the type system.</span></span> <span data-ttu-id="f0b6b-178">Önceki sürümlerde Kullanıcı tanımlı türler, temel alınan türünün bir alt türü olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-178">In prior releases user defined types were considered to be a subtype of their underlying type.</span></span> <span data-ttu-id="f0b6b-179">Bu sürümle devam edin ve bu durum artık böyle değildir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-179">With this release and going forward this is no longer the case.</span></span> <span data-ttu-id="f0b6b-180">Kullanıcı tanımlı türler artık kendi farklı türleri olduğu kabul edilir ve Kullanıcı tanımlı tür ve temel alınan türü arasında otomatik atama yoktur.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-180">User defined types are now considered to be their own distinct type, and no automatic cast between a user defined type and its underlying type exists.</span></span> <span data-ttu-id="f0b6b-181">Tüm kullanıcıların bir "sarmalama" işleci `!`açıkça açık olması gerekir ve Kullanıcı tanımlı türdeki bir nesnenin içeriğine erişmek için özel olarak bir dönüştürme gerekir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-181">All casts need to be made explicit via an "unwrap" operator `!`, and a cast is needed in particular to access the content of a object of user defined type.</span></span>  

<span data-ttu-id="f0b6b-182">Tür sisteminde yapılan değişiklikler, dizilerin fark davranışını ve parametreli nesne türü kullanımını da içerir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-182">The modifications to the type system also include the variance behavior of arrays, and the treatment of type parameterized objects.</span></span> <span data-ttu-id="f0b6b-183">0,3 ' den başlayarak, hem kesilebilir hem de sabit diziler sabittir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-183">Starting in 0.3, both mutable and immutable arrays are invariant.</span></span> <span data-ttu-id="f0b6b-184">Ayrıca, çağrılabilir öğesine geçirilen bağımsız değişkenler tür parametreli olamaz.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-184">Additionally, arguments passed to a callable cannot be type parameterized.</span></span> <span data-ttu-id="f0b6b-185">Bu gibi durumlarda, tür bağımsız değişkenlerinin tanımlayıcı ile birlikte geçirilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-185">In these cases, type arguments must be passed along with the identifer.</span></span>

<span data-ttu-id="f0b6b-186">Q # derleyicisinin önceki sürümleri, işlev değeri doğru giriş ve çıkış türlerine sahip olduğu sürece bir işlem değerinin beklenildiği bir işlev değeri sağlanmasını sağladı.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-186">Previous releases of the Q# compiler allowed a function value to be provided where an operation value was expected, as long as the function value had the correct input and output types.</span></span> <span data-ttu-id="f0b6b-187">Bu, Q # dil belirtiminde belirtilmeyen bir davranışta değil.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-187">This was unintended behavior that is not specified in the Q# language specification.</span></span>
<span data-ttu-id="f0b6b-188">0,3 derleyicisinde, işlev değerlerinin artık işlem değerleri olarak değerlendirilmemesi için bu davranışı kaldırdık.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-188">In the 0.3 compiler, we have removed this behavior so that function values are no longer considered operation values.</span></span>
<span data-ttu-id="f0b6b-189">Bu hatayla ilgili varolan kodun kesintisini en aza indirmek için, aynı giriş ve çıkış türlerine sahip bir işlevi açıkça bir işleme dönüştürecek Microsoft. hisse. Canon ad alanına ToOperation işlevini ekledik.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-189">To minimize the disruption to existing code that relied on this bug, we have added the ToOperation function in the Microsoft.Quantum.Canon namespace that will explicitly convert a function into an operation with the same input and output types.</span></span>

<span data-ttu-id="f0b6b-190">Aşağıdaki örnek, bir işlev `Square` bir işlem `op`değiştirmek için `ToOperation` işlevinin nasıl kullanılacağını gösterir:</span><span class="sxs-lookup"><span data-stu-id="f0b6b-190">The following example illustrates how to use the `ToOperation` function to change a function `Square` to an operation `op`:</span></span> 
```qsharp
namespace Microsoft.Quantum.Tests {
    open Microsoft.Quantum.Primitive;
    open Microsoft.Quantum.Canon;

    function Square(x : Int) : Int {
        return x * x;
    }

    operation ApplyOp<'T, 'U>(op : ('T => 'U), input : 'T) : 'U {
        return op(input);
    }

    operation ToOperationTest() : Unit {
        let op = ToOperation(Square);
        AssertIntEqual(ApplyOp(op, 3), 9, "ToOperation failed with Square.");
    }
}
```

## <a name="requirements"></a><span data-ttu-id="f0b6b-191">Gereksinimler</span><span class="sxs-lookup"><span data-stu-id="f0b6b-191">Requirements</span></span> 

<span data-ttu-id="f0b6b-192">Yayın, Windows 10 için Visual Studio 2017 sürüm 15,8 veya üzeri sürümlerde ve Windows 10, macOS ve Linux için Visual Studio Code Version 1.27.2 veya üzeri sürümlerde desteklenir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-192">The release is supported on Visual Studio 2017 version 15.8 or later for Windows 10, and on Visual Studio Code version 1.27.2 or later for Windows 10, macOS, and Linux.</span></span>

<span data-ttu-id="f0b6b-193">Hisse geliştirme seti .NET Core SDK (2,0 veya üzeri) kullanır.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-193">The Quantum Development Kit uses the .NET Core SDK (2.0 or later).</span></span>

## <a name="installation"></a><span data-ttu-id="f0b6b-194">Yükleme</span><span class="sxs-lookup"><span data-stu-id="f0b6b-194">Installation</span></span>  

<span data-ttu-id="f0b6b-195">Yükleme yönergelerini [buradan](../install-guide/index.md)izleyin.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-195">Follow the installation instructions [here](../install-guide/index.md).</span></span>

<span data-ttu-id="f0b6b-196">Geçerli .NET Core SDK sürümünüz güncel değilse, uyarılar ("" System. Reflection. Metadata "farklı sürümleri arasında çakışmalar bulundu.") görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-196">You may see warnings ("Found conflicts between different versions of "System.Reflection.Metadata" that could not be resolved.") if your current version of .NET Core SDK is not up to date.</span></span>  <span data-ttu-id="f0b6b-197">Ancak, .NET Core SDK kullanıyorsanız (2,0 veya üzeri), bu uyarılar yoksayılabilir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-197">However, if you are using .NET Core SDK (2.0 or later), these warnings may be ignored.</span></span>


- <span data-ttu-id="f0b6b-198">Yayın, hem hisse geliştirme setinin var olan özelliklerinin hem de bu sürümle kullanılabilen yeni özelliklerin nasıl kullanılacağını gösteren bir dizi farklı örnek ile birlikte sağlanır.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-198">The release is provided along with a number of different samples showing how to use both existing features of the Quantum Development Kit, and the new features available with this release.</span></span> <span data-ttu-id="f0b6b-199">Bu örnekler, GitHub 'da [Microsoft/hisse](https://github.com/Microsoft/Quantum) deposunda bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-199">These samples can be can be found on GitHub at the [Microsoft/Quantum](https://github.com/Microsoft/Quantum) repository.</span></span>


## <a name="Migration"></a><span data-ttu-id="f0b6b-200">Mevcut projeleri Q # 0,3 ' a geçirme</span><span class="sxs-lookup"><span data-stu-id="f0b6b-200">Migrating Existing Projects to Q# 0.3</span></span> 

<span data-ttu-id="f0b6b-201">Hisse geliştirme seti 'nin 0,2 sürümüne sahip olan Q # projelerine sahipseniz, bu projeleri en yeni sürüme geçirme adımları aşağıda verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-201">If you have existing Q# projects from version 0.2 of the Quantum Development Kit, the following are the steps to migrate those projects to the newest version.</span></span> <span data-ttu-id="f0b6b-202">Ayrıca, işlem için size yardımcı olacak bir [geçiş betiği](#MigrationScript) sunuyoruz.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-202">We also provide a [migration script](#MigrationScript) to help you with the process.</span></span>

> [!NOTE]
> <span data-ttu-id="f0b6b-203">Projelerin sırayla yükseltilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-203">Projects need to be upgraded in order.</span></span> <span data-ttu-id="f0b6b-204">Birden çok projenin bulunduğu bir çözümünüz varsa, her bir projeyi başvurulduğu sırada güncelleştirin.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-204">If you have a solution with multiple projects update each project in the order they are referenced.</span></span>


1. <span data-ttu-id="f0b6b-205">Mevcut tüm ikilileri ve ara dosyaları kaldırmak için komut satırında `dotnet clean` komutunu çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-205">From a command line, Run `dotnet clean` to remove all existing binaries and intermediate files.</span></span>
2. <span data-ttu-id="f0b6b-206">Bir metin düzenleyicisinde, "Microsoft. hisse" `PackageReference` sürümünü sürüm 0.3.1811.2802-Preview olarak değiştirmek için. csproj dosyasını düzenleyin, örneğin:</span><span class="sxs-lookup"><span data-stu-id="f0b6b-206">In a text editor, edit the .csproj file to change the version of all the "Microsoft.Quantum" `PackageReference` to version 0.3.1811.2802-preview, for example:</span></span>
```xml
    <PackageReference Include="Microsoft.Quantum.Canon" Version="0.3.1811.2802" />
    <PackageReference Include="Microsoft.Quantum.Development.Kit" Version="0.3.1811.2802" />
```
4. <span data-ttu-id="f0b6b-207">Komut satırından, bu komutu çalıştırarak tüm sözdizimi değişikliklerini karşılamak için komut satırı derleyicisi ile tümleştirilmiş biçimlendirme aracını kullanın: `dotnet msbuild /t:qsharpformat`</span><span class="sxs-lookup"><span data-stu-id="f0b6b-207">From the command line, use the formatting tool integrated into the command line compiler to address all syntax changes by running this command: `dotnet msbuild /t:qsharpformat`</span></span>  
    - <span data-ttu-id="f0b6b-208">Dosyalarınız yerinde geçirilecek.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-208">Your files will be migrated in-place.</span></span> <span data-ttu-id="f0b6b-209">Tüm özgün dosyaların bir yedeklemesi `obj\qsharp\.backup` kopyalanacak</span><span class="sxs-lookup"><span data-stu-id="f0b6b-209">A backup of all the original files will be copied to `obj\qsharp\.backup`</span></span>
    - <span data-ttu-id="f0b6b-210">Biçimlendirme Aracı, tüm derleme hatalarını yoksayarak projeyi derler ve derleme derlemesini temel alan biçimlendirilmiş Q # kodu oluşturur.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-210">The formatting tool will compile the project ignoring all compilation errors and generate formatted Q# code based on the build compilation.</span></span> 
       <span data-ttu-id="f0b6b-211">Tanınmayan bir sembol (örn. tanımsız değişken adı), biçimlendirmeden sonra el ile değiştirilmeleri gereken bir yer tutucu metinle değiştirilmelidir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-211">Any unrecognized symbol (e.g. an undefined variable name) will be replaced by a placeholder text that needs to be replaced manually after formatting.</span></span> <span data-ttu-id="f0b6b-212">Bu durumda, etkilenen dosya için uyarı oluştururken biçimlendirme başarılı olur.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-212">In this case, the formatting succeeds while generating a warning for the affected file.</span></span>     
    - <span data-ttu-id="f0b6b-213">Biçimlendirme ve dosyadaki tüm boşluklar, yayınlanan kodda değişecektir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-213">The formatting and in particular any white space in the file will be changed in the emitted code.</span></span> <span data-ttu-id="f0b6b-214">Açıklamalar korunacaktır.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-214">Comments will be preserved.</span></span>   
5. <span data-ttu-id="f0b6b-215">Bunu çalıştırdıktan sonra, kodun anlam yorumu değiştiği durumlarda anlamsal değişiklikleri el ile ele almanız gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-215">After running this, you might still need to manually address semantic changes in cases where the semantic interpretation of the code has changed.</span></span> <span data-ttu-id="f0b6b-216">Bu hatalar, Visual Studio veya Visual Studio Code IntelliSense tarafından bildirilir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-216">All these errors will be reported by IntelliSense in Visual Studio or Visual Studio Code.</span></span>
    - <span data-ttu-id="f0b6b-217">Projenin kök klasörünü veya Visual Studio 2017 veya Visual Studio Code içeren çözümü açın.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-217">Open the root folder of the project or the containing solution in Visual Studio 2017 or Visual Studio Code.</span></span>
    - <span data-ttu-id="f0b6b-218">Düzenleyicide bir .qs dosyasını açtıktan sonra, çıkış penceresinde Q# dili uzantısının çıkışını görmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-218">After opening a .qs file in the editor, you should see the output of the Q# language extension in the output window.</span></span>
    - <span data-ttu-id="f0b6b-219">Proje başarıyla yüklendikten sonra (çıkış penceresinde gösterilir), her dosyayı açıp kalan tüm sorunları el ile düzeltin.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-219">After the project has loaded successfully (indicated in the output window) open each file and manually to address all remaining issues.</span></span>


> [!NOTE]
> * <span data-ttu-id="f0b6b-220">0,3 sürümü için, hisse geliştirme paketine dahil edilen dil sunucusu birden çok çalışma alanını desteklemez.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-220">For the 0.3 release, the language server included with the Quantum Development Kit does not support multiple workspaces.</span></span>
> * <span data-ttu-id="f0b6b-221">Visual Studio Code’da bir proje üzerinde çalışmak için projeyi içeren kök klasörü ve başvurulan tüm projeleri açın.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-221">In order to work with a project in Visual Studio Code, open the root folder containing the project itself and all referenced projects.</span></span>   
> * <span data-ttu-id="f0b6b-222">Visual Studio Code’da bir çözüm üzerinde çalışmak için çözümde yer alan tüm projelerin çözüm ile aynı klasörde veya bunun bir alt klasöründe olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-222">In order to work with a solution in Visual Studio, all projects contained in the solution need to be in the same folder as the solution or in one of its subfolders.</span></span>  
> * <span data-ttu-id="f0b6b-223">0,3 ve üzeri sürümlere geçirilen projeler ve eski paket sürümlerini kullanan projeler arasındaki **Başvurular desteklenmez.**</span><span class="sxs-lookup"><span data-stu-id="f0b6b-223">References between projects migrated to 0.3 and higher and projects using older package versions are **not** supported.</span></span>




## <a name="MigrationScript"></a><span data-ttu-id="f0b6b-224">Geçiş betiği</span><span class="sxs-lookup"><span data-stu-id="f0b6b-224">Migration script</span></span> 

<span data-ttu-id="f0b6b-225">Proje geçişini kolaylaştırmak için, [buradan](https://raw.githubusercontent.com/Microsoft/Quantum/release/v0.3.1810/utilities/qdk-migrate.ps1)indirilebilecek bir PowerShell betiği sağlanır.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-225">In order to facilitate project migration, a PowerShell script is provided that can be downloaded [here](https://raw.githubusercontent.com/Microsoft/Quantum/release/v0.3.1810/utilities/qdk-migrate.ps1).</span></span>
<span data-ttu-id="f0b6b-226">Bu betik, 0,2 sürümünü 0,3 kullanmak için hisse geliştirme setinin sürümünden projelerin geçişini sağlar.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-226">This script helps migrate projects from version 0.2 of the Quantum Development Kit to use version 0.3.</span></span>

> [!NOTE]
> <span data-ttu-id="f0b6b-227">Geçiş betiği için Windows PowerShell veya PowerShell Core 'un çalıştırılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-227">The migration script requires Windows PowerShell or PowerShell Core to run.</span></span>
> <span data-ttu-id="f0b6b-228">Windows PowerShell, Windows 10 ' da önceden yüklenmiş olarak gelir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-228">Windows PowerShell comes pre-installed with Windows 10.</span></span>
> <span data-ttu-id="f0b6b-229">https://github.com/PowerShell/PowerShell adresinden Windows, macOS veya Linux için PowerShell Core 'u indirin.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-229">Download PowerShell Core for Windows, macOS, or Linux at https://github.com/PowerShell/PowerShell.</span></span>

<span data-ttu-id="f0b6b-230">Betik aşağıdaki dört adımı yürütür:</span><span class="sxs-lookup"><span data-stu-id="f0b6b-230">The script executes the following four steps:</span></span>

- <span data-ttu-id="f0b6b-231">Bu proje, geçişin başarılı olma olasılığını sağlamak için hisse geliştirme setinin önceki sürümüyle oluşturulmuştur.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-231">The project is built with the previous version of the Quantum Development Kit to ensure that migration is likely to succeed.</span></span> <span data-ttu-id="f0b6b-232">Bu adım, betiğe `-Force` parametresi kullanılarak atlanabilir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-232">This step can be skipped by using the `-Force` parameter to the script.</span></span>
- <span data-ttu-id="f0b6b-233">Yeni proje şablonları yüklendi.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-233">New project templates are installed.</span></span>
- <span data-ttu-id="f0b6b-234">Proje, hisse geliştirme setinin geçerli sürümünü kullanacak şekilde güncelleştirilir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-234">The project is updated to use the current version of the Quantum Development Kit.</span></span>
- <span data-ttu-id="f0b6b-235">Hisse geliştirme setinin 0,3 sürümü ile birlikte sunulan biçimlendirme Aracı, yukarıda belgelenen en büyük değişikliklerin çoğunu otomatik olarak çözmek için uygulanır.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-235">The formatting tool provided with version 0.3 of the Quantum Development Kit is applied to automatically address most of the breaking changes documented above.</span></span>

<span data-ttu-id="f0b6b-236">Bu dört adım tamamlandıktan sonra, el ile işlenmesi gereken bazı geçiş sorunları olabilir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-236">After these four steps complete, there may be some remaining migration issues which must be handled manually.</span></span>
<span data-ttu-id="f0b6b-237">Visual Studio 2017 ve Visual Studio Code için hisse geliştirme seti uzantılarının en son sürümünü kullanmak bu sorunları kolayca bulmaya yardımcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-237">Using the latest version of the Quantum Development Kit extensions for Visual Studio 2017 and Visual Studio Code can help find these issues easily.</span></span>

<span data-ttu-id="f0b6b-238">Betiğe ilişkin belgeler, komut dosyasının bulunduğu klasörde aşağıdaki komutlardan biri çalıştırılarak elde edilebilir:</span><span class="sxs-lookup"><span data-stu-id="f0b6b-238">The documentation for the script can be obtained by running one of the following commands in the folder where the script is located:</span></span>

```powershell
Get-Help ./qdk-migrate.ps1
Get-Help -Online ./qdk-migrate.ps1
```

> [!NOTE]
> <span data-ttu-id="f0b6b-239">Varsayılan olarak, Windows tüm betiklerin güvenlik önlemi olarak yürütülmesini engeller.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-239">By default, Windows prevents the execution of any scripts as a security measure.</span></span>
> <span data-ttu-id="f0b6b-240">`qdk-migrate.ps1` gibi betiklerin Windows üzerinde çalışmasına izin vermek için, yürütme ilkesini değiştirmeniz gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-240">To allow scripts such as `qdk-migrate.ps1` to run on Windows, you may need to change the execution policy.</span></span>
> <span data-ttu-id="f0b6b-241">Bunu yapmak için `Set-ExecutionPolicy` komutunu çalıştırın:</span><span class="sxs-lookup"><span data-stu-id="f0b6b-241">To do so, run the `Set-ExecutionPolicy` command:</span></span>
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope Process
> ```
> <span data-ttu-id="f0b6b-242">Daha sonra, PowerShell 'den çıktığınızda yürütme ilkesi geri döndürülür.</span><span class="sxs-lookup"><span data-stu-id="f0b6b-242">The execution policy will then be reverted when you exit PowerShell.</span></span>
> <span data-ttu-id="f0b6b-243">Yürütme ilkesini kaydetmek istiyorsanız `-Scope`için farklı bir değer kullanın:</span><span class="sxs-lookup"><span data-stu-id="f0b6b-243">If you would like to save the execution policy, use a different value for `-Scope`:</span></span>
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
> ```

