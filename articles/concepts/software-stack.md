---
title: Yazılım yığını | Microsoft Docs
description: Yazılım yığını
author: QuantumWriter
uid: microsoft.quantum.concepts.software-stack
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: f97dfacf6cde5fa92e1f368efaae36554a5c944d
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/28/2019
ms.locfileid: "73184738"
---
# <a name="software-stack-for-quantum-computing"></a><span data-ttu-id="76a2d-103">Hisse bilgi işlem için yazılım yığını</span><span class="sxs-lookup"><span data-stu-id="76a2d-103">Software stack for quantum computing</span></span>
<span data-ttu-id="76a2d-104">Normal olarak, bir bilgisayarı, uygulamayı çalıştıran tek bir cihaz hakkında düşündük, ancak modern bilgi işlem ortamları çok daha karmaşık ve gelişmiş.</span><span class="sxs-lookup"><span data-stu-id="76a2d-104">Normally when we think of a computer we envision a single device running an application, but modern computing environments are much more complex and advanced.</span></span> <span data-ttu-id="76a2d-105">İle etkileşimde bulunduğumuz uygulama, genellikle uygulamanın donanım düzeyine kadar yürütülmesini sağlayan birden çok yazılım katmanına göre bekletildiğinde.</span><span class="sxs-lookup"><span data-stu-id="76a2d-105">The application we interact with typically rests on multiple layers of software that provide for the application's execution down to the hardware level.</span></span> <span data-ttu-id="76a2d-106">Bu yazılım katmanları, tüm bilgi işlem sisteminin temeldeki karmaşıklığından bir uygulama çözümünün geliştirilmesini soyutlamak için gereklidir.</span><span class="sxs-lookup"><span data-stu-id="76a2d-106">These software layers are necessary to abstract the development of an application solution from the underlying complexity of the complete computing system.</span></span> <span data-ttu-id="76a2d-107">Bir geliştiricinin basit bir smartphone uygulaması yazarken veri yolu, önbellek mimarileri, iletişim protokolleri ve daha fazlasını düşünmesi gerekiyorsa, görev çok daha karmaşık hale gelir.</span><span class="sxs-lookup"><span data-stu-id="76a2d-107">If a developer had to think about bus, cache architectures, communication protocols, and more while writing a simple smartphone app, the task would become much more complex.</span></span>  <span data-ttu-id="76a2d-108">*Yazılım yığınının* kavramı, bu sorunları gidermek için klasik bilgi işlem 'da geliştirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="76a2d-108">The concept of a *software stack* was developed in classical computing to address these issues.</span></span>  <span data-ttu-id="76a2d-109">Klasik kavramdan ödünç alınan bir yazılım yığını, Ayrıca, Q # ile hisse satışınızın arkasındaki vizyonın önemli bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="76a2d-109">Borrowing from the classical concept, a software stack is also a key part of the vision behind quantum computing with Q#.</span></span>

## <a name="conventional-stack"></a><span data-ttu-id="76a2d-110">Geleneksel yığın</span><span class="sxs-lookup"><span data-stu-id="76a2d-110">Conventional stack</span></span>
<span data-ttu-id="76a2d-111">Yazılım yığınının arkasındaki önemli fikir özyinelemedir.</span><span class="sxs-lookup"><span data-stu-id="76a2d-111">The key idea behind a software stack is recursion.</span></span>  <span data-ttu-id="76a2d-112">Bu, cihazın alt seviyelerinin ayrıntılarını geliştiriciden uzağa soyutlamak için birkaç iç içe arabirimler katmanından oluşur.</span><span class="sxs-lookup"><span data-stu-id="76a2d-112">It consists of several nested layers of interfaces that abstract the details of the lower levels of the device away from the developer.</span></span>  <span data-ttu-id="76a2d-113">Örneğin, yaygın olarak kullanılan bir yazılım yığını, Windows Server üzerinde çalışan Internet Information Services (bir Web Server) üzerinde çalışan SQL Server (ilişkisel veritabanı yönetim sistemi) üzerinde çalışan ASP.NET (bir programlama dili) çalıştırmayı içerir (bir işletim sistemi), bilgisayar donanımını sürücüler.</span><span class="sxs-lookup"><span data-stu-id="76a2d-113">For example, a commonly used software stack involves running ASP.NET (a programming language), on top of SQL server (a relational database management system), which runs on top of Internet Information Services (a web server), which runs on top of Windows server (an operating system), which drives the computer hardware.</span></span>  <span data-ttu-id="76a2d-114">Yazılım bir hiyerarşi olarak inceleyerek, bu yazılımın altındaki tüm yazılımların alt düzey ayrıntılarını anlamak zorunda kalmadan, ASP.NET 'e yazılım yazabilir.</span><span class="sxs-lookup"><span data-stu-id="76a2d-114">By looking at software as a hierarchy, one can write software in ASP.NET without needing to understand the low-level details of all the software below it.</span></span>

## <a name="quantum-stack"></a><span data-ttu-id="76a2d-115">Hisse yığını</span><span class="sxs-lookup"><span data-stu-id="76a2d-115">Quantum stack</span></span>

<span data-ttu-id="76a2d-116">Bilgi işlem ortamında yazılım yığını farklı değildir ve uygulamada geleneksel yığınlardan daha düşük bir düzeyde çalışır.</span><span class="sxs-lookup"><span data-stu-id="76a2d-116">The software stack in quantum computing is no different in principle, and in practice operates at a lower level than traditional stacks.</span></span>  <span data-ttu-id="76a2d-117">Hisse yığını nasıl görünür?</span><span class="sxs-lookup"><span data-stu-id="76a2d-117">What does a quantum stack look like?</span></span>  <span data-ttu-id="76a2d-118">Hisse bilgisayar geleneksel (genellikle klasik olarak adlandırılır) bilgisayarlar için bir değiştirme değildir.</span><span class="sxs-lookup"><span data-stu-id="76a2d-118">A quantum computer is not a replacement for traditional (often called classical) computers.</span></span>  <span data-ttu-id="76a2d-119">Aslında, hisse bilgisayarları, hesaplama sorunlarını çözmek için klasik bilgisayarlarla birlikte neredeyse tamamen çalışır.</span><span class="sxs-lookup"><span data-stu-id="76a2d-119">In fact, quantum computers will almost certainly work in tandem with classical computers to solve computational problems.</span></span>  <span data-ttu-id="76a2d-120">Bunun için, kırılganlığına of hisse verisi nedeniyle bu oluşur.</span><span class="sxs-lookup"><span data-stu-id="76a2d-120">In part, this arises because of the fragility of quantum data.</span></span>  <span data-ttu-id="76a2d-121">Bu durumda, gözlemlenecek bilgilere neredeyse tamamen zarar verseniz bile bu, en fazla bilgi.</span><span class="sxs-lookup"><span data-stu-id="76a2d-121">Quantum data is so fragile that if you even look at it you almost certainly damage the information being observed.</span></span>  <span data-ttu-id="76a2d-122">Bu nedenle, fiziksel ortamlarındaki boş olan etkileşimlerin bilgi ve hesaplama istenmeden zarar vermemesi için hisse gerekmediğini göz önünde bulundurmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="76a2d-122">Quantum computers will thus need to be designed with quantum error correction in mind so that stray interactions from its physical environment do not inadvertently damage the information and computation.</span></span> <span data-ttu-id="76a2d-123">Bu nedenle, Q # için doğal bir hedef, hisse maların bir listesini (ağ geçitleri veya ağ geçidi işlemleri olarak adlandırılır) kabul eden bir hata düzeltilmiş hisse bilgisayarı (genellikle *hataya dayanıklı* bir hisse bilgisayar) olarak adlandırılır ve bu yönergeleri hisse adına uygular içinde depolanan veriler.</span><span class="sxs-lookup"><span data-stu-id="76a2d-123">For this reason, a natural target for Q# is an error-corrected quantum computer (often called a *fault-tolerant* quantum computer) that accepts a list of quantum instructions (called gates or gate operations) and applies those instructions to the quantum data stored within it.</span></span>  <span data-ttu-id="76a2d-124">Bir hisse algoritması veya programdaki qubits ve geçit işlemlerinin sayısı yeterince küçükse, hata düzeltmesinin kesinlikle gerekli olamayacağını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="76a2d-124">Note that if the number of qubits and gate operations in a quantum algorithm or program is small enough, error correction may not be absolutely necessary.</span></span>  <span data-ttu-id="76a2d-125">Ancak, qubits ve ağ geçidi işlemlerinin sayısı arttıkça, daha büyük bir gereklilik olacaktır, bu nedenle yazılım yığınımızın ve Q # 'ları, hata düzeltmesini ve etkili bir şekilde idare etmek ve ölçeklenebilir, hataya dayanıklı hisse bilgi işlem işlemlerini etkinleştirmek için mimarilerimizi sağlar.</span><span class="sxs-lookup"><span data-stu-id="76a2d-125">However as the number of qubits and gate operations grow, it will more certainly be a requirement, thus we architect our software stack and Q# to aptly and efficiently handle error correction and enable scalable, fault-tolerant quantum computing.</span></span>

### <a name="error-correction"></a><span data-ttu-id="76a2d-126">Hata Düzeltme</span><span class="sxs-lookup"><span data-stu-id="76a2d-126">Error correction</span></span>
<span data-ttu-id="76a2d-127">Hata düzeltmesi hızlı ve güvenilir bir klasik bilgisayarın, hisse hesaplamada bulunan hataları düzeltmek için, hisse ve güvenilir bir klasik bilgisayarın, bu hataların bulunduğu sorunları giderecek şekilde çalışmasını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="76a2d-127">Error correction requires a fast and reliable classical computer to be run in concert with the quantum computer to correct errors as they appear in the quantum computation.</span></span>  <span data-ttu-id="76a2d-128">Pratikte, alan-programlanabilir kapı dizileri (FPGAs) veya hızlı Cryogenic işlemciler gibi bileşenler, bu hataların doğal olarak bir arada birikdikleri sayıdan daha hızlı belirlenmesi ve düzeltilmesi için gerekli olabilir.</span><span class="sxs-lookup"><span data-stu-id="76a2d-128">In practice, components such as field-programmable gate arrays (FPGAs) or fast cryogenic processors may be needed to identify and correct the errors faster than they naturally accumulate in the quantum computer.</span></span>  <span data-ttu-id="76a2d-129">Sonuç olarak, bir hisse bilgisayarı, çok çeşitli çok sayıda sıcaklıklar üzerinde çalışan birkaç farklı hesaplama cihazlarından oluşan karma bir makinedir.</span><span class="sxs-lookup"><span data-stu-id="76a2d-129">As a result, a quantum computer is a hybrid machine comprised of several different computational devices that operate over a wide range of temperatures.</span></span>  <span data-ttu-id="76a2d-130">Bu nedenle, bir hisse anın uygulanmasını sağlamak için gereken çok sayıda donanım ve yazılım (klasik ve hisse) katmanı olduğu için, bir yazılım yığınının merceği aracılığıyla bir hisse bilgisayarı programlamayı düşünmek çok daha yararlıdır. bir hisse bilgisayarında algoritma.</span><span class="sxs-lookup"><span data-stu-id="76a2d-130">For this reason, it is much more helpful to think about programming a quantum computer through the lens of a software stack, as there are many layers of hardware and software (classical and quantum) required to ultimately achieve the implementation of a quantum algorithm on a quantum computer.</span></span>

### <a name="quantum-conceptual-stack"></a><span data-ttu-id="76a2d-131">Hisse kavram yığını</span><span class="sxs-lookup"><span data-stu-id="76a2d-131">Quantum conceptual stack</span></span>
<span data-ttu-id="76a2d-132">Bir hisse bilgi işlem ortamında düzenleme 8704143553785700723 'nin işlevsel akışını gösteren kavramsal bir yığın aşağıda gösterilmiştir:</span><span class="sxs-lookup"><span data-stu-id="76a2d-132">A conceptual stack that illustrates the functional flow of factoring 8704143553785700723 in a quantum computing environment is shown below:</span></span>

![Yazılım yığını](~/media/concepts_stack.png)

### <a name="specification-and-algorithm"></a><span data-ttu-id="76a2d-134">Belirtim ve algoritma</span><span class="sxs-lookup"><span data-stu-id="76a2d-134">Specification and algorithm</span></span>
<span data-ttu-id="76a2d-135">Bu tür bir hisse hesaplamadığının birkaç geniş aşamasına kadar programlama vardır.</span><span class="sxs-lookup"><span data-stu-id="76a2d-135">There are several broad stages of programming such a quantum computation.</span></span>  <span data-ttu-id="76a2d-136">Birincisi ve arguya en zorlu aşamada, tek bir dilekün çözmeyle ilgili sorun belirlenir.</span><span class="sxs-lookup"><span data-stu-id="76a2d-136">The first, and arguably most challenging phase, is specifying the problem that one wishes to solve.</span></span>  <span data-ttu-id="76a2d-137">Bu durumda, sorun 8704143553785700723 numarasını iki asal sayının bir ürününe katmada olur.</span><span class="sxs-lookup"><span data-stu-id="76a2d-137">In this case, the problem is to factor the number 8704143553785700723  into a product of two prime numbers.</span></span>  <span data-ttu-id="76a2d-138">Sonraki adım, bu hesaplama sorununun çözümüne yönelik bir algoritma tasarlamaya yöneliktir.</span><span class="sxs-lookup"><span data-stu-id="76a2d-138">The next step involves designing an algorithm for solving this computational problem.</span></span>  <span data-ttu-id="76a2d-139">Bu durumda, faktörleri bulmak için Shor 'ın faünlü hisse düzenleme algoritması kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="76a2d-139">In this case, Shor's famous quantum factoring algorithm can be used to find the factors.</span></span>  <span data-ttu-id="76a2d-140">Bu algoritma, Q # ' da ifade edilir ve ardından bir hisse miktarı dizisi, bir dizi işlem ile ilgili bir hata-ücretsiz hisse bilgisayarında çalıştırılabilen çıktıdır.</span><span class="sxs-lookup"><span data-stu-id="76a2d-140">This algorithm is expressed in Q# and then a sequence of quantum operations is output that could be run on an idealized error-free quantum computer.</span></span>  

### <a name="physical-gates"></a><span data-ttu-id="76a2d-141">Fiziksel kapıları</span><span class="sxs-lookup"><span data-stu-id="76a2d-141">Physical gates</span></span>
<span data-ttu-id="76a2d-142">Bu örnekte, bir hata-ücretsiz hisse bilgisayarı sağlamak için doğası olduğunu varsayarak, sonraki adım Q # tarafından oluşturulan işlemleri alır ve bunları, fiziksel kapıların seçtiği hisse temel donanım çalıştırılabilir.</span><span class="sxs-lookup"><span data-stu-id="76a2d-142">In this example, assume nature is not so kind as to provide an error-free quantum computer so the subsequent step takes the operations emitted by Q# and translates them using templates specified by the quantum error correction method chosen into physical gates that the basic hardware can execute.</span></span>  <span data-ttu-id="76a2d-143">Bu işlem, bir önceki modelde açıklanan bir fiziksel qubit ana bilgisayarıyla, bu bilgileri tek bir qubit içindeki bilgileri, şirket içi fiziksel üzerinde yerel hataları yeniden düzenleyebilir Bu tür hataların algılanabilmesi ve düzeltilmesi için yeterince uzun.</span><span class="sxs-lookup"><span data-stu-id="76a2d-143">This process involves replacing every logical qubit described in the previous model with a host of physical qubits that are used to store and protect the information within a single qubit in a redundant fashion that can resist local errors on the constituent physical qubits long enough for such errors to be detected and corrected.</span></span>  <span data-ttu-id="76a2d-144">Aynı şekilde, Q # kodu tarafından tanımlanan mantıksal qubits 'in birçok fiziksel qubit ile değişmesi gerekir. aynı şekilde, çıktıda açıklanan her hisse kapıda fiziksel qubit üzerinde işlem yapan bir fiziksel ağ dizisine çevrilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="76a2d-144">Just as the logical qubits described by the Q# code need to be replaced with many physical qubits, similarly each quantum gate described in the output needs to be translated into a sequence of physical gates that act upon the physical qubits.</span></span>  <span data-ttu-id="76a2d-145">Bu nedenle, Q # çıkışı nadiren bilgi işlem için son hedeftir ve daha fazla soyutlama düzeyi, kodu donanımda bir şekilde yürütmek için gereklidir.</span><span class="sxs-lookup"><span data-stu-id="76a2d-145">For this reason, the output of Q# is seldom the final target for quantum computing and further levels of abstraction are needed to execute the code on hardware in an oblivious fashion.</span></span>

### <a name="control-computer"></a><span data-ttu-id="76a2d-146">Denetim bilgisayarı</span><span class="sxs-lookup"><span data-stu-id="76a2d-146">Control computer</span></span>
<span data-ttu-id="76a2d-147">Fiziksel ağ geçidi sırası, bu yönergeleri daha sonra doğrudan hisse bilgisayar ile arabirimlerin bulunduğu bir denetim bilgisayarına gönderen sıradan bir bilgisayara yüklenir.</span><span class="sxs-lookup"><span data-stu-id="76a2d-147">The physical gate sequence is then loaded into an ordinary computer that sends these instructions down to a control computer that interfaces directly with the quantum computer.</span></span>  <span data-ttu-id="76a2d-148">Yazılım yığını içindeki bu katman genellikle [Qcodes](http://qcodes.github.io/Qcodes/)gibi deneysel denetim yazılımları tarafından işlenir.</span><span class="sxs-lookup"><span data-stu-id="76a2d-148">This layer within the software stack is often handled by experimental control software such as [QCoDeS](http://qcodes.github.io/Qcodes/).</span></span>

### <a name="interface-computer"></a><span data-ttu-id="76a2d-149">Arabirim bilgisayar</span><span class="sxs-lookup"><span data-stu-id="76a2d-149">Interface computer</span></span>
<span data-ttu-id="76a2d-150">Bu işlemdeki son adım, bir hızlı denetim bilgisayarına gereken kapıların ilk akışını yapan arabirim bilgisayarını içerir.</span><span class="sxs-lookup"><span data-stu-id="76a2d-150">The final step in this process involves the interface computer first streaming the gates as needed to a fast control computer.</span></span> <span data-ttu-id="76a2d-151">Hızlı denetim bilgisayarı, gerekli kapıları qubits 'e uygulamak için gerekli olan voltages (genellikle pulu olarak adlandırılır) uygular.</span><span class="sxs-lookup"><span data-stu-id="76a2d-151">Then the fast control computer applies the voltages needed (commonly called pulses) to implement the required gates on qubits.</span></span> <span data-ttu-id="76a2d-152">Bu işlem, hisse alınan hata düzeltmekle gözlemlendiği hata düzeltilirken yapılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="76a2d-152">This has to be done while correcting any errors that are observed through quantum error correction.</span></span>  <span data-ttu-id="76a2d-153">Cryogenic FPGAs veya diğer Exotic Hardware 'in, bu adımları, bu adımların, bir miktar bilgisayarda görünme hızına göre belirlenen katı zaman gereksinimleri içinde gerçekleştirmesi gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="76a2d-153">Cryogenic FPGAs or other exotic hardware may be needed to perform these steps within the stringent time requirements imposed by the rate at which errors appear in the quantum computer.</span></span>  <span data-ttu-id="76a2d-154">Bu düzeydeki hedef dil genellikle [VHDL](https://en.wikipedia.org/wiki/VHDL)'dir ve bu, bir hisse algoritması açıklamasını ayrıştırmak için yığının en üst ucunda kullanılan farklı bir yol gerektirir.</span><span class="sxs-lookup"><span data-stu-id="76a2d-154">The target language on this level is often [VHDL](https://en.wikipedia.org/wiki/VHDL), which requires a distinct way of thinking from that which is used at the top end of the stack to parse a description of a quantum algorithm.</span></span>

### <a name="the-q-quantum-programming-language"></a><span data-ttu-id="76a2d-155">Q # hisse programlama dili</span><span class="sxs-lookup"><span data-stu-id="76a2d-155">The Q# quantum programming language</span></span>
<span data-ttu-id="76a2d-156">Q # amacı, geliştiricilerin çok sayıda hisse bilgi işlem platformunu ve arabirimini hedefleyen ve Kullanıcı ile hisse cihazı arasında çok sayıda yazılım kullanan bir kod yazmasına olanak tanıyan basit bir dil sağlamaktır.</span><span class="sxs-lookup"><span data-stu-id="76a2d-156">The aim of Q# is to provide a simple language that allows developers to write code that targets a wealth of quantum computing platforms and interface with the intervening layers of software that stand between the user and the quantum device.</span></span>  <span data-ttu-id="76a2d-157">Bu dil, bir yazılım yığını kavramını benimseyerek ve temel alınan hisse bilgisayar düzeylerine izin verirken, gibi bir dilde C#açığa çıkarılan, gerekli olan Q # kodundan temel işlemlere çeviri.</span><span class="sxs-lookup"><span data-stu-id="76a2d-157">The language facilitates this by embracing the notion of a software stack and abstracting many of the details of the underlying quantum computer while allowing other levels of the stack, exposed through a language such as C#, to perform the necessary translations from Q# code to fundamental operations.</span></span>  <span data-ttu-id="76a2d-158">Bu, geliştiricinin en iyi şekilde yaptığı işe odaklanmasını sağlar: algoritmaları tasarlama ve sorunları çözme.</span><span class="sxs-lookup"><span data-stu-id="76a2d-158">This allows the developer to focus on what they do best: designing algorithms and solving problems.</span></span>
