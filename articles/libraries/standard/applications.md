---
title: 'Q # standart kitaplıklar-uygulamalar | Microsoft Docs'
description: 'Q # standart kitaplıkları'
author: QuantumWriter
uid: microsoft.quantum.libraries.applications
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: e6eca45dd67b3566340c2a2a4fded0f6e7c3c5c3
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/29/2019
ms.locfileid: "73185180"
---
# <a name="applications"></a><span data-ttu-id="9eb8b-103">Uygulamalar</span><span class="sxs-lookup"><span data-stu-id="9eb8b-103">Applications</span></span> #

## <a name="hamiltonian-simulation"></a><span data-ttu-id="9eb8b-104">Hamiltonian simülasyonu</span><span class="sxs-lookup"><span data-stu-id="9eb8b-104">Hamiltonian Simulation</span></span> ##

<span data-ttu-id="9eb8b-105">Hisse sistemlerinin simülasyonu, hisse hesaplamanýn en heyecan verici uygulamalarından biridir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-105">The simulation of quantum systems is one of the most exciting applications of quantum computation.</span></span>
<span data-ttu-id="9eb8b-106">Klasik bir bilgisayarda, genel olarak hisse kutları benzetimi yapma zorluğunu, durumu vektör gösteriminin boyut $N $ ' i ile ölçeklendirir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-106">On a classical computer, the difficulty of simulating quantum mechanics, in general, scales with the dimension $N$ of its state-vector representation.</span></span>
<span data-ttu-id="9eb8b-107">Bu gösterim $n $ qubitleri $N = 2 ^ n $ ile üstel olarak artdıkça [, nitelik](xref:microsoft.quantum.concepts.multiple-qubits)bir şekilde bilinen, klasik donanımda hisse benzeme olarak da bilinir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-107">As this representation grows exponentially with the number of $n$ qubits $N=2^n$, a trait known also known as the [curse of dimensionality](xref:microsoft.quantum.concepts.multiple-qubits), quantum simulation on classical hardware is intractable.</span></span>

<span data-ttu-id="9eb8b-108">Ancak, bu durum hisse uygun şekilde çok farklı olabilir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-108">However, the situation can be very different on quantum hardware.</span></span> <span data-ttu-id="9eb8b-109">Hisse benzetiminin en yaygın çeşitine, zaman bağımsız Hamiltonian benzetim sorunu olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-109">The most common variation of quantum simulation is called the time-independent Hamiltonian simulation problem.</span></span> <span data-ttu-id="9eb8b-110">Burada, bir hermitian matrisi olan System Hamiltonian $H $, ve bir hisse bilgisayarında $n $ qubits 'e göre bazı ilk hisse miktarı $ \ket{\psı (0)} $ şeklinde kodlanmış bir açıklama verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-110">There, one is provided with a description of the system Hamiltonian $H$, which is a Hermitian matrix, and some initial quantum state $\ket{\psi(0)}$ that is encoded in some basis on $n$ qubits on a quantum computer.</span></span> <span data-ttu-id="9eb8b-111">Kapalı sistemlerdeki hisse makineleri Schrödinger denklemi $ $ \begin{hizalaması} ı\frac {d \ket{\psı (t)}} {d t} & = H \ket{\psı (t)} altında geliştikçe, \end{hizalaması} $ $ amaç, bir sabit zamanda $U (t) = e ^ {-iHt} $ $t Unitary zaman-uç işlecini uygulamaktır. Burada $ \ket{\psı (t)} = U (t) \ket{\psı (0)} $, Schrödinger denklemini çözer.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-111">As quantum states in closed systems evolve under the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ the goal is to implement the unitary time-evolution operator $U(t)=e^{-iHt}$ at some fixed time $t$, where $\ket{\psi(t)}=U(t)\ket{\psi(0)}$ solves the Schrödinger equation.</span></span>
<span data-ttu-id="9eb8b-112">Benzer şekilde, zamana bağlı Hamiltonian benzetim sorunu aynı denklemi çözer, ancak $H (t) $ ile artık bir zaman işlevidir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-112">Analogously, the time-dependent Hamiltonian simulation problem solves the same equation, but with $H(t)$ now a function of time.</span></span>

<span data-ttu-id="9eb8b-113">Hamiltonian simülasyonu, diğer birçok hisse simülasyonu sorununun önemli bir bileşenidir ve Hamiltonian simülasyonu sorununa yönelik çözümler, bir dizi temel olarak Unitary $ \tilde{u hatasıyla $\\| \tilde{U}-U (t)\\| [Spectral norm](xref:microsoft.quantum.concepts.matrix-advanced)içindeki \le \ Epsilon $.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-113">Hamiltonian simulation is a major component of many other quantum simulation problems, and solutions to Hamiltonian simulation problem are algorithms that describes a sequence of primitive quantum gates for synthesizing an approximating unitary $\tilde{U}$ with error $\\|\tilde{U} - U(t)\\| \le \epsilon$ in the [spectral norm](xref:microsoft.quantum.concepts.matrix-advanced).</span></span> <span data-ttu-id="9eb8b-114">Bu algoritmaların karmaşıklığı, bir hisse bilgisayar tarafından nasıl erişilebilen Hamilton açıklamasına göre çok daha güçlü bir şekilde yapılır.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-114">The complexity of these algorithms depend very strongly on how a description of the Hamiltonian of interest is made accessible by a quantum computer.</span></span> <span data-ttu-id="9eb8b-115">Örneğin, en kötü durumda, $n $ qubitleri üzerinde işlem yapan $H $, her matris öğesi için bir tane olmak üzere $2 ^ n \times 2 ^ n $ sayı listesi olarak sağlanacaksa, yalnızca verilerin okunması üstel bir süre gerektirir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-115">For instance, in the worst-case, if $H$ acting on $n$ qubits were to be provided as a list of $2^n \times 2^n$ numbers, one for each matrix element, simply reading the data would already require exponential time.</span></span> <span data-ttu-id="9eb8b-116">En iyi durumda, biri $O \ket{t}\ket{\psi (0)} = \ket{t}U (t) \ket{\psı (0)} $, sorunu çözen bir siyah kutu Unitary erişimi varsayabilir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-116">In the best case, one could assume access to a black-box unitary that $O\ket{t}\ket{\psi(0)}=\ket{t}U(t)\ket{\psi(0)}$ trivially solves the problem.</span></span> <span data-ttu-id="9eb8b-117">Bu giriş modellerinin hiçbiri özellikle ilgi çekici değildir. Bu, klasik yaklaşımlardan daha iyi olmadığı ve ikinci olarak siyah kutu olarak, uygulamanın temel kapı karmaşıklığını, bu da qubit sayısında üstel hale getirebileceği şekilde gizler.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-117">Neither of these input models are particularly interesting -- the former as it is no better than classical approaches, and the latter as the black-box hides the primitive gate complexity of its implementation, which could be exponential in the number of qubits.</span></span>

### <a name="descriptions-of-hamiltonians"></a><span data-ttu-id="9eb8b-118">Hamiltonians açıklamaları</span><span class="sxs-lookup"><span data-stu-id="9eb8b-118">Descriptions of Hamiltonians</span></span> ###

<span data-ttu-id="9eb8b-119">Bu nedenle, girişin biçimi için ek varsayımlar gereklidir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-119">Additional assumptions of the format of the input are therefore required.</span></span> <span data-ttu-id="9eb8b-120">Gerçekçi fiziksel sistemler veya ilginç hesaplama sorunlarıyla ilgili olanlar ve yeterince kısıtlayıcı olan giriş modelleri gibi ilginç Hamiltonians için yeterince tanımlayıcı olan giriş modelleri arasında ince bir denge olmalıdır bir hisse bilgisayar üzerinde verimli bir şekilde ımplemenbu tablo.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-120">A fine balance must be struck between input models that are sufficiently descriptive to encompass interesting Hamiltonians, such as those for realistic physical systems or interesting computational problems, and input models that are sufficiently restrictive to be efficiently implementable on a quantum computer.</span></span> <span data-ttu-id="9eb8b-121">Çok sayıda önemsiz olmayan giriş modeli, belgeler içinde bulunabilir ve bu, hisse miktarı ile klasik arasında değişir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-121">A variety of non-trivial input model may be found in the literature, and they range from quantum to classical.</span></span> 

<span data-ttu-id="9eb8b-122">Hisse giriş modelinin örnekleri olarak, [örnek tabanlı Hamiltonian simülasyonu](http://www.nature.com/articles/s41534-017-0013-7) , hamiltonian $H $ olmak üzere gerçekleştirilen bir yoğunluk matrisi $ \rho $ ' ın kopyalarını üreten hisse ışlarına kara kutu erişimi olduğunu varsayar.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-122">As examples of quantum input models, [sample-based Hamiltonian simulation](http://www.nature.com/articles/s41534-017-0013-7) assumes black-box access to quantum operations that produce copies of a density matrix $\rho$, which are taken to be the Hamiltonian $H$.</span></span> <span data-ttu-id="9eb8b-123">[Unitary erişim modelinde](https://arxiv.org/abs/1202.5822) tek bir Işlem, Hamiltonian 'ın toplam unitcg $ $ \begin{hizalaması} H & = \sum ^ {d-1}\_{j = 0} a\_j \hat{U}\_j, \end{hizalaması} $ $; burada $a\_j > 0 $ katsayısıdır ve $ \hat{U}\_j $, unitı 'lardır.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-123">In the [unitary access model](https://arxiv.org/abs/1202.5822) one supposes that the Hamiltonian instead decomposes into a sum of unitaries $$ \begin{align} H & = \sum^{d-1}\_{j=0} a\_j \hat{U}\_j, \end{align} $$ where $a\_j>0$ are coefficients, and $\hat{U}\_j$ are unitaries.</span></span> <span data-ttu-id="9eb8b-124">Daha sonra, bir birinin, istenen $ \hat{U}\_j $ ve Oracle $A \ayraç{0}= \sum ^ {d-1} öğesini seçen Unitary Oracle $V = \sum ^ {d-1}\_{j = 0} \ket{j}\bra{j}\otimes \hat{U}\_j $ ' a siyah box erişimi olduğunu varsaymıştır. j = 0} \sqrt{a\_j/\ Sum ^ {d-1}\_{k = 0} \Alpha\_j} \ket{j} $ Bu katsayılarını kodlayan bir hisse durumu oluşturur.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-124">It is then assumed that one has black-box access to the unitary oracle $V=\sum^{d-1}\_{j=0}\ket{j}\bra{j}\otimes \hat{U}\_j$ that selects the desired $\hat{U}\_j$, and the oracle $A\ket{0}=\sum^{d-1}\_{j=0}\sqrt{a\_j/\sum^{d-1}\_{k=0}\alpha\_j}\ket{j}$ that create a quantum state encoding these coefficients.</span></span> <span data-ttu-id="9eb8b-125">[Seyrek Hamiltonian simülasyonu](https://arxiv.org/abs/quant-ph/0301023)durumunda, tek bir Hamiltonian 'ın her satırda yalnızca $d = \mathcal{O} (\Text{Polylog} (N)) $ sıfır olmayan öğe içeren bir seyrek matris olduğunu varsaymaktadır.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-125">In the case of [sparse Hamiltonian simulation](https://arxiv.org/abs/quant-ph/0301023), one assumes that the Hamiltonian is a sparse matrix with only $d=\mathcal{O}(\text{polylog}(N))$ non-zero element in every row.</span></span> <span data-ttu-id="9eb8b-126">Üstelik, bir diğeri, bu sıfır olmayan öğelerin konumunu ve değerlerini izleyen etkin hisse devreleri varlığını kabul eder.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-126">Moreover, one assumes the existence of efficient quantum circuits that output the location of these non-zero elements, as well as the their values.</span></span> <span data-ttu-id="9eb8b-127">[Hamiltonian benzetim algoritmalarının](xref:microsoft.quantum.more-information) karmaşıklığı, bu siyah kutulara yönelik sorgu sayısı bakımından değerlendirilir ve temel kapı karmaşıklığı, bu siyah kutuları uygulama zorluklarını çok daha fazla farklılık gösterir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-127">The complexity of [Hamiltonian simulation algorithms](xref:microsoft.quantum.more-information) is evaluated in terms of number of queries to these black-boxes, and the primitive gate complexity then depends very much on the difficulty of implementing these black-boxes.</span></span>

> [!NOTE]
> <span data-ttu-id="9eb8b-128">Büyük O gösterimi, algoritmaların karmaşıklık ölçeklemesini betimleyen yaygın olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-128">The big-O notation is commonly used to describe the complexity scaling of algorithms.</span></span> <span data-ttu-id="9eb8b-129">İki gerçek işlev $f, g $ $g (x) = \mathcal{O} (f (x)) $ ifadesi, tüm > \ge x $g $0 için $x (x) \le c f (x) $ gibi mutlak pozitif bir sabit $x\_0, c\_0 $ olduğunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-129">Given two real functions $f,g$, the expression $g(x)=\mathcal{O}(f(x))$ means that there exists an absolute positive constant $x\_0, c>0$ such that $g(x) \le c f(x)$ for all $x\ge x\_0$.</span></span> 

<span data-ttu-id="9eb8b-130">En pratik uygulamalarda, bir hisse bilgisayarında uygulanacak olan bu siyah kutular, $ \mathcal{O} (\Text{Polylog} (N)) $ ilkel hisse kapıları bulunan etkin bir şekilde ımplemenanabilir olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-130">In most practical applications to be implemented on a quantum computer, these black-boxes must be efficiently implementable, that is with $\mathcal{O}(\text{polylog}(N))$ primitive quantum gates.</span></span> <span data-ttu-id="9eb8b-131">Daha güçlü, verimli simulable Hamiltonians, yeterince seyrek klasik açıklama içermelidir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-131">More strongly, efficiently simulable Hamiltonians must have some sufficiently sparse classical description.</span></span> <span data-ttu-id="9eb8b-132">Bu tür bir formülde, Hamiltonian 'ın toplam hermitian bölümü $ $ \begin{hizalaması} H & = \sum ^ {d-1} _ {j = 0} H_j olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-132">In one such formulation, it is assumed that the Hamiltonian decomposes into a sum of Hermitian parts $$ \begin{align} H & = \sum^{d-1}_{j=0} H_j.</span></span>
<span data-ttu-id="9eb8b-133">\end{hizalaması} $ $ Üstelik, her parçanın, bir Hamiltonian $H\_j $, benzetimini yapmak için kolay olduğu varsayılır.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-133">\end{align} $$ Moreover, it is assumed that each part, a Hamiltonian $H\_j$, is easy to simulate.</span></span> <span data-ttu-id="9eb8b-134">Bu, herhangi bir zaman için $e ^ {-IH\_j t} $ $t $ 'nin tam olarak $ \mathcal{O} (1) $ temel hisse kapıları kullanılarak uygulantığını gösterir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-134">This means that the unitary $e^{-iH\_j t}$ for any time $t$ may be implemented exactly using $\mathcal{O}(1)$ primitive quantum gates.</span></span> <span data-ttu-id="9eb8b-135">Örneğin, her bir $H\_j $ yerel Pauli işleçleri olduğu özel durumda bu durum geçerlidir. Yani, ı\mathcal{O} (1) $ kimlik olmayan ve ı (1) $ kimliği olmayan Pauli işleçleri, istenmeyen açık qubit üzerinde işlem gören,</span><span class="sxs-lookup"><span data-stu-id="9eb8b-135">For instance, this is true in the special case where each $H\_j$ are local Pauli operators, meaning that they are of tensor products of $\mathcal{O}(1)$ non-identity Pauli operators that act on spatially close qubits.</span></span> <span data-ttu-id="9eb8b-136">Bu model, sınırlı ve yerel etkileşime sahip fiziksel sistemlere özellikle uygulanabilir, çünkü koşulların sayısı $d = \mathcal{O} (\Text{Polylog} (N)) $ olur ve açıkça aşağı yazılabilir ve yani polinom zaman içinde açıklanabilir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-136">This model is particularly applicable to physical systems with bounded and local interaction, as the number of terms is $d=\mathcal{O}(\text{polylog}(N))$, and may clearly be written down, i.e. classically described, in polynomial time.</span></span>

> [!TIP]
> <span data-ttu-id="9eb8b-137">Bir parçalar toplamı içine oluşturan Hamiltonians, Dynamical Oluşturucu temsili kitaplığı kullanılarak açıklanabilir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-137">Hamiltonians that decompose into a sum of parts may be described using the Dynamical Generator Representation library.</span></span> <span data-ttu-id="9eb8b-138">Daha fazla bilgi için [veri yapılarının](xref:microsoft.quantum.libraries.data-structures)Dynamical Oluşturucu temsili bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-138">For more information, see the Dynamical Generator Representation section in [data structures](xref:microsoft.quantum.libraries.data-structures).</span></span>

### <a name="simulation-algorithms"></a><span data-ttu-id="9eb8b-139">Simülasyon algoritmaları</span><span class="sxs-lookup"><span data-stu-id="9eb8b-139">Simulation Algorithms</span></span> ###

<span data-ttu-id="9eb8b-140">Bir hisse simülasyonu algoritması, bir Hamiltonian 'nin verilen açıklamasını, bir bütün olarak, yaklaşık olarak görünen Hamiltonian, yaklaşık bir zaman evrimi dizisine dönüştürür.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-140">A quantum simulation algorithm converts a given description of a Hamiltonian into a sequence of primitive quantum gates that, as a whole, approximate time-evolution by said Hamiltonian.</span></span>

<span data-ttu-id="9eb8b-141">Hamiltonian, hermitian parçalarının toplamına işaret eden özel bir durumda, Trour-Suzuki ayrıştırma, hermitian bileşenleri toplamını oluşturan Hamiltonians benzetimi için özellikle basit ve sezgisel bir algoritmadır.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-141">In the special case where the Hamiltonian decomposes into a sum of Hermitian parts, the Trotter-Suzuki decomposition is a particularly simple and intuitive algorithm for simulating Hamiltonians that decompose into a sum of Hermitian components.</span></span> <span data-ttu-id="9eb8b-142">Örneğin, bu aileye ait ilk sipariş tümleştiricisi $ $ \begin{hizalaması} U (t) & = \left (e ^ {-iH\_0 t/r} e ^ {-iH\_1 t/r} \cnoktalar e ^ {-IH\_{d-1} t/r} \right) ^ {r} + \mathcal{O} (d ^ 2 \max_j\\| H\_j\\| ^ 2 t ^ 2/r), \end{hizalaması} $ $ $r d $ terimlerinin bir ürününü kullanıyor.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-142">For instance, a first-order integrator of this family approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j\\|H\_j\\|^2 t^2/r), \end{align} $$ using a product of $r d$ terms.</span></span> 

> [!TIP]
> <span data-ttu-id="9eb8b-143">Trour-Suzuki simülasyon algoritmasının uygulamaları örneklerde ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-143">Applications of the Trotter-Suzuki simulation algorithm are covered in the samples.</span></span>
> <span data-ttu-id="9eb8b-144">Yalnızca her bir hedef makine tarafından sunulan iç işlemleri kullanan, şaşırtıcı model için lütfen [ **simplefon** örneğine](https://github.com/Microsoft/Quantum/tree/master/Samples/src/SimpleIsing)bakın.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-144">For the Ising model using only the intrinsic operations provided by each target machine, please see the [**SimpleIsing** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/SimpleIsing).</span></span>
> <span data-ttu-id="9eb8b-145">Trour-Suzuki kitaplık denetim yapısını kullanan, şaşırtıcı model için lütfen [ **ısingtrour** örneğine](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingTrotterEvolution)bakın.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-145">For the Ising model using the Trotter-Suzuki library control structure, please see the [**IsingTrotter** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingTrotterEvolution).</span></span>
> <span data-ttu-id="9eb8b-146">Trour-Suzuki kitaplık denetim yapısını kullanarak molesel Hydrogen için lütfen [ **H2 simülasyon** örneğine](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationCmdLine)bakın.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-146">For molecular Hydrogen using the Trotter-Suzuki library control structure, please see the [**H2 simulation** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationCmdLine).</span></span>

<span data-ttu-id="9eb8b-147">Çoğu durumda benzetim algoritmasını uygulamak istiyoruz, ancak uygulamasının ayrıntıları ile ilgilenmez.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-147">In many cases, we would like to implement the simulation algorithm, but are not interested in the details of its implementation.</span></span> <span data-ttu-id="9eb8b-148">Örneğin, ikinci sipariş tümleştiricisi $ $ \begin{hizalaması} U (t) & = \left (e ^ {-iH\_0 t/2R} e ^ {-iH\_1 t/2R} \cnoktalar e ^ {-IH\_{d-1} t/2R} e ^ {-iH\_{d-1} t/2R} \cnoktalar e ^ {-iH\_1 t/2R} e ^ {- IH\_0 t/2R} \right) ^ {r} + \mathcal{O} (d ^ 3 \max_j\\| H\_j\\| ^ 3 t ^ 3/r ^ 2), \end{hizalaması} $ $, $2rd $ terimlerinin bir ürününü kullanıyor.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-148">For instance, the second-order integrator approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / 2r} e^{-iH\_1 t / 2r} \cdots e^{-iH\_{d-1} t / 2r} e^{-iH\_{d-1} t / 2r}  \cdots e^{-iH\_1 t / 2r} e^{-iH\_0 t / 2r} \right)^{r} + \mathcal{O}(d^3 \max_j\\|H\_j\\|^3 t^3/r^2), \end{align} $$ using a product of $2rd$ terms.</span></span> <span data-ttu-id="9eb8b-149">Daha büyük siparişler daha fazla hüküm ve en iyi duruma getirilmiş varyantlar, üs lerde yüksek düzeyde önemsiz olmayan sıralar gerektirebilir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-149">Larger orders will involve even more terms and optimized variants may require highly non-trivial orderings on the exponentials.</span></span> <span data-ttu-id="9eb8b-150">Ayrıca, diğer gelişmiş algoritmalar ara adımlarda anyala qubits kullanımını da içerebilir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-150">Other advanced algorithms may also involve the use of ancilla qubits in intermediate steps.</span></span> <span data-ttu-id="9eb8b-151">Bu nedenle, Kullanıcı tanımlı tür olarak Canon 'daki benzetim algoritmalarını paketliyoruz</span><span class="sxs-lookup"><span data-stu-id="9eb8b-151">Thus we package simulation algorithms in the canon as the user-defined type</span></span>

```qsharp
newtype SimulationAlgorithm = ((Double, EvolutionGenerator, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="9eb8b-152">İlk parametre `Double` simülasyonudur, [veri yapılarının](xref:microsoft.quantum.libraries.data-structures)Dynamical Oluşturucu temsili bölümünde ele alınan ikinci parametre `EvolutionGenerator`, bir zaman bağımsız Hamiltonian ile paketlenmiş bir klasik açıklamadır. Hamiltonian 'daki her bir terime bir hisse bağlantı hattı tarafından benzetilen yönergeler.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-152">The first parameter `Double` is the time of simulation, the second parameter `EvolutionGenerator`, covered in the Dynamical Generator Representation section of [data-structures](xref:microsoft.quantum.libraries.data-structures), is a classical description of a time-independent Hamiltonian packaged with instructions on how each term in the Hamiltonian may be simulated by a quantum circuit.</span></span> <span data-ttu-id="9eb8b-153">Bu formun türleri, sanal parametre `Qubit[]`$e ^ {-IHV t} $ olan Unitary işlemini yaklaşık olarak, sanal sistemin hisse ma durumunu depolayan yazmaç olan bir işlemdir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-153">Types of this form approximate the unitary operation $e^{-iHt}$ on the third parameter `Qubit[]`, which is the register storing the quantum state of the simulated system.</span></span> <span data-ttu-id="9eb8b-154">Benzer şekilde zamana bağlı durumda, bir zamana bağlı Hamiltonian 'ın klasik açıklaması olan bunun yerine `EvolutionSchedule` türü ile Kullanıcı tanımlı bir tür tanımladık.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-154">Similarly for the time-dependent case, we define a user-defined type with an `EvolutionSchedule` type instead, which is a classical description of a time-dependent Hamiltonian.</span></span>

```qsharp
newtype TimeDependentSimulationAlgorithm = ((Double, EvolutionSchedule, Qubit[]) => Unit : Adjoint, Controlled);
```

<span data-ttu-id="9eb8b-155">Örnek olarak, Trour-Suzuki ayrıştırma aşağıdaki Canon işlevleri kullanılarak çağrılabilir. Bu, her üstel içindeki benzetimin süresini değiştirme `trotterStepSize` ve istenen integral alanının sırası için `trotterOrder`.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-155">As an example, the Trotter-Suzuki decomposition may be called using the following canon functions, with parameters `trotterStepSize` modifying the duration of simulation in each exponential, and `trotterOrder` for the order of the desired integrator.</span></span>

```qsharp
function TrotterSimulationAlgorithm(
    trotterStepSize: Double, 
    trotterOrder: Int) 
    : SimulationAlgorithm {
    ...
}
function TimeDependentTrotterSimulationAlgorithm(
    trotterStepSize: Double, 
    trotterOrder: Int) 
    : TimeDependentSimulationAlgorithm {
    ...
}
```

> [!TIP]
> <span data-ttu-id="9eb8b-156">Simülasyon kitaplığının uygulamaları örneklerde ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-156">Applications of the simulation library are covered in the samples.</span></span> <span data-ttu-id="9eb8b-157">`SimulationAlgorithm`kullanarak, elde eden modeldeki aşama tahmini için lütfen [ **ıingphasetahmine** örnek örneğine](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingPhaseEstimation)bakın.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-157">For phase estimation in the Ising model using `SimulationAlgorithm`, please see the [**IsingPhaseEstimation** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingPhaseEstimation).</span></span>
> <span data-ttu-id="9eb8b-158">`TimeDependentSimulationAlgorithm`kullanarak, şaşırtıcı modelde Adiabatik durum hazırlığı için lütfen bkz. [ **Adiabaticfon** örneği](https://github.com/Microsoft/Quantum/tree/master/Samples/src/AdiabaticIsing).</span><span class="sxs-lookup"><span data-stu-id="9eb8b-158">For adiabatic state preparation in the Ising model using `TimeDependentSimulationAlgorithm`, please see the [**AdiabaticIsing** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/AdiabaticIsing).</span></span>


### <a name="adiabatic-state-preparation--phase-estimation"></a><span data-ttu-id="9eb8b-159">Adiabatik durum hazırlığı & aşama tahmini</span><span class="sxs-lookup"><span data-stu-id="9eb8b-159">Adiabatic State Preparation & Phase Estimation</span></span> ###

<span data-ttu-id="9eb8b-160">Hamiltonian benzetiminin yaygın bir uygulaması, Adiabatik durum hazırlığından biridir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-160">One common application of Hamiltonian simulation is adiabatic state preparation.</span></span> <span data-ttu-id="9eb8b-161">Burada, bir tane iki Hamiltonians $H\_{\Text{Start} $ ve $H\_{\Text{End}} $, ve başlangıç Hamiltonian $H\_{\Text{start}} $ öğesinin zemin durumu $ \ket{\psı (0)} $ ile birlikte sağlanır.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-161">Here, one is provided with two Hamiltonians $H\_{\text{start}}$ and $H\_{\text{end}}$, and a quantum state $\ket{\psi(0)}$ that is a ground state of the start Hamiltonian $H\_{\text{start}}$.</span></span> <span data-ttu-id="9eb8b-162">Genellikle, $H\_{\Text{Start}} $, $ \ket{\psı (0)} $ hesaplama tabanlı bir durumdan $ \ket{0\cnoktalar 0} $ üzerinden hazırlanmaya kolay bir şekilde seçilir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-162">Typically, $H\_{\text{start}}$ is chosen such that $\ket{\psi(0)}$ is easy to prepare from a computational basis state $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="9eb8b-163">Zamana bağlı simülasyon sorunu sufficientl yavaş olan bu Hamiltonians arasında enterpolasyonarak, son Hamiltonian $H\_{\Text{End}} $ gibi yüksek olasılığa sahip olmak büyük bir olasılık ile sona erdirmek mümkündür.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-163">By interpolating between these Hamiltonians in the time-dependent simulation problem sufficientl slowly, it is possible to end up, with high probability, in a ground state of the final Hamiltonian $H\_{\text{end}}$.</span></span> <span data-ttu-id="9eb8b-164">Hamiltonian zemin durumlarında iyi bir yaklaşımlar hazırlarken bu şekilde zamana bağlı Hamiltonian simülasyon algoritmalarından sonra, farklı şekilde değişen bir yaklaşım gibi diğer kavramsal farklı yaklaşımlara çağrı yaparak bu şekilde devam edebilirsiniz. eigençözücü mümkündür.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-164">Though preparing good approximations to Hamiltonian ground states could proceed in this manner by calling upon on time-dependent Hamiltonian simulation algorithms as a subroutine, other conceptually different approaches such as the variational quantum eigensolver are possible.</span></span>

<span data-ttu-id="9eb8b-165">Yine de, bir başka uygulama de, Hamiltonians 'in, kimyasal yeniden eyleminin ara adımlarını temsil eden, 'in zemin durumu enerji düzeyini tahmin ediyor.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-165">Yet another application ubiquitous in quantum chemistry is estimating the ground state energy of Hamiltonians representing the intermediate steps of chemical reaction.</span></span> <span data-ttu-id="9eb8b-166">Örneğin, bu tür bir düzen, zemin durumunu oluşturmak için Adiabatik durum hazırlanmasını kullanır ve ardından zaman bağımsız Hamilton benzetimini, daha sınırlı bir hata ile bu enerji çıkaran bir altyordam ve başarılı olma olasılığı.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-166">Such a scheme could, for instance, rely on adiabatic state preparation to create the ground state, and then incorporate time-independent Hamiltonian simulation as a subroutine in phase estimation characterization to extract this energy with some finite error and probability of success.</span></span> 

<span data-ttu-id="9eb8b-167">Simülasyon algoritmalarının Kullanıcı tanımlı türler `SimulationAlgorithm` soyutlamalarını ve `TimeDependentSimulationAlgorithm` işlevselliğini daha karmaşık hisse algoritmalarına kolayca eklemesine olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-167">Abstracting simulation algorithms as the user-defined types `SimulationAlgorithm` and `TimeDependentSimulationAlgorithm` allow us to conveniently incorporate their functionality into more sophisticated quantum algorithms.</span></span> <span data-ttu-id="9eb8b-168">Bu, yaygın olarak kullanılan bu alt yordamlar için aynı yapmamızı ister.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-168">This motivates us to do the same for these commonly used subroutines.</span></span>

<span data-ttu-id="9eb8b-169">Bu nedenle uygun işlevi tanımladık</span><span class="sxs-lookup"><span data-stu-id="9eb8b-169">Thus we define the convenient function</span></span>

```qsharp
function InterpolatedEvolution(
        interpolationTime: Double, 
        evolutionGeneratorStart: EvolutionGenerator,
        evolutionGeneratorEnd: EvolutionGenerator,
        timeDependentSimulationAlgorithm: TimeDependentSimulationAlgorithm)
        : (Qubit[] => Unit is Adj + Ctl) {
        ...
}
 
```

<span data-ttu-id="9eb8b-170">Bu, Adiabatik durum hazırlığının tüm adımlarını uygulayan bir Unitary işlemi döndürür.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-170">This returns a unitary operation that implements all steps of adiabatic state preparation.</span></span> <span data-ttu-id="9eb8b-171">İlk parametre `interpolatedTime`, ikinci parametre `evolutionGeneratorStart` tarafından tanımlanan başlangıç Hamiltonian ve üçüncü parametre `evolutionGeneratorEnd`tarafından tanımlanan bitiş Hamiltonian arasında ilk olarak daha fazla enterpoladığımız süreyi tanımlar.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-171">The first parameter `interpolatedTime` defines the time over which we linearly interpolate between the start Hamiltonian described by the second parameter `evolutionGeneratorStart` and the end Hamiltonian described by the third parameter `evolutionGeneratorEnd`.</span></span> <span data-ttu-id="9eb8b-172">Dördüncü parametre `timeDependentSimulationAlgorithm`, bir benzetim algoritması seçimini yaptığı yerdir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-172">The fourth parameter `timeDependentSimulationAlgorithm` is where one makes the choice of simulation algorithm.</span></span> <span data-ttu-id="9eb8b-173">`interpolatedTime` yeterince uzunsa, ilk zemin durumunun zamana bağlı benzetim süresi boyunca Hamiltonian 'nin anlık bir durumunun kaldığını ve bu nedenle son Hamiltonian 'in baş durumunda bittiğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-173">Note that if `interpolatedTime` is long enough, an initial ground state remains an instantaneous ground state of the Hamiltonian over the entire duration of time-dependent simulation, and thus ends in the ground state of the end Hamiltonian.</span></span>

<span data-ttu-id="9eb8b-174">Ayrıca tipik bir hisse ansız deneme denemesinin tüm adımlarını otomatik olarak gerçekleştiren yararlı bir işlem de tanımladık.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-174">We also define a helpful operation that automatically performs all steps of a typical quantum chemistry experiment.</span></span> <span data-ttu-id="9eb8b-175">Örneğin, Adiabatik durum hazırlığı tarafından üretilen durumun enerji tahminini döndüren aşağıda verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="9eb8b-175">For instance we have the following, which returns an energy estimate of the state produced by adiabatic state preparation:</span></span>

```qsharp
operation AdiabaticStateEnergyEstimate( 
    nQubits : Int, 
    statePrepUnitary: (Qubit[] => Unit),
    adiabaticUnitary: (Qubit[] => Unit),
    qpeUnitary: (Qubit[] => Unit is Adj + Ctl),
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double)) 
    : Double {
...
}
```

<span data-ttu-id="9eb8b-176">`nQubits`, ilk hisse durumu kodlamak için kullanılan qubits sayısıdır.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-176">`nQubits` is the number of qubits used to encode the initial quantum state.</span></span> <span data-ttu-id="9eb8b-177">`statePrepUnitary` başlangıç durumunu hesaplama tabanlı $ \ket{0\cnoktalar 0} $ ' dan hazırlar.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-177">`statePrepUnitary` prepares the start state from the computational basis $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="9eb8b-178">`adiabaticUnitary`, `InterpolatedEvolution` işlevi tarafından üretilen Adiabatik durum hazırlanmasını uygulayan Unitary işlemidir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-178">`adiabaticUnitary` is the unitary operation that implements adiabatic state preparation, such as produced by the  `InterpolatedEvolution` function.</span></span> <span data-ttu-id="9eb8b-179">`qpeUnitary`, sonuçta elde edilen hisse için aşama tahmini gerçekleştirmek üzere kullanılan Unitary işlemidir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-179">`qpeUnitary` is the unitary operation that is used to perform phase estimation on the resulting quantum state.</span></span> <span data-ttu-id="9eb8b-180">`phaseEstAlgorithm`, aşama tahmini algoritması seçimimize ait.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-180">`phaseEstAlgorithm` is our choice of phase estimation algorithm.</span></span>

> [!TIP]
> <span data-ttu-id="9eb8b-181">Adiabatik durum hazırlığının uygulamaları örneklerde ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-181">Applications of adiabatic state preparation are covered in the samples.</span></span> <span data-ttu-id="9eb8b-182">`AdiabaticEvolution` işlevi kullanılarak Adiabatik durum hazırlığının el ile uygulanmasını kullanan, şaşırtıcı model için lütfen [ **Adiabaticfon** örneğine](https://github.com/Microsoft/Quantum/tree/master/Samples/src/AdiabaticIsing)bakın.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-182">For the Ising model using a manual implementation of adiabatic state preparation versus using the `AdiabaticEvolution` function, please see the [**AdiabaticIsing** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/AdiabaticIsing).</span></span>
> <span data-ttu-id="9eb8b-183">Şaşırtıcı modelde aşama tahmini ve Adiabatik durum hazırlığı için lütfen [ **ıingphasetahmine** örnek](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingPhaseEstimation)bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-183">For phase estimation and adiabatic state preparation in the Ising model, please see the [**IsingPhaseEstimation** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingPhaseEstimation).</span></span>

> [!TIP]
> <span data-ttu-id="9eb8b-184">[Molesel Hydrogen benzetimi](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationCmdLine) , ilginç bir ve kısa bir örnektir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-184">The [simulation of molecular Hydrogen](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationCmdLine) is an interesting and brief sample.</span></span> <span data-ttu-id="9eb8b-185">$ [Malley et. Al](https://arxiv.org/abs/1512.06860) içinde bildirilen model ve deneysel sonuçlar.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-185">The model and experimental results reported in [O'Malley et. al.](https://arxiv.org/abs/1512.06860)</span></span> <span data-ttu-id="9eb8b-186">yalnızca Pauli matrislerini gerektirir ve $ \hat H = g\_{0}ı\_0I\_1 + g\_1 {Z\_0} + g\_2 {z\_1} + g\_3 {Z\_0} {Z\_1} + g\_4 {Y\_0} {Y\_1} + g\_5 {X\_0} {X\_1} $.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-186">only requires Pauli matrices and takes the form $\hat H = g\_{0}I\_0I\_1+g\_1{Z\_0}+g\_2{Z\_1}+g\_3{Z\_0}{Z\_1}+g\_4{Y\_0}{Y\_1}+g\_5{X\_0}{X\_1}$.</span></span> <span data-ttu-id="9eb8b-187">Bu geçerli bir Hamiltonian yalnızca yalnızca 2 qubit gerektirir; burada $g $ sabitleri, iki Hydrogen alar arasında $R $ ile hesaplanır.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-187">This is an effective Hamiltonian only requiring only 2 qubits, where the constants $g$ are computed from the distance $R$ between the two Hydrogen atoms.</span></span> <span data-ttu-id="9eb8b-188">Canon işlevleri kullanılarak Paulıs, unitcihazlarına dönüştürülür ve sonra da Trour-Suzuki ayrıştırma kullanılarak kısa süreler üzerinde bulunur.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-188">Using canon functions, the Paulis are converted to unitaries and then evolved over short periods of time using the Trotter-Suzuki decomposition.</span></span> <span data-ttu-id="9eb8b-189">$H _2 $ zemin durumunun bir önemi, Adiabatik durum hazırlığı kullanılmadan oluşturulabilir ve bu nedenle, Canon 'nin aşama tahmininden yararlanarak doğrudan devlet enerjisi bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-189">A good approximation to the $H_2$ ground state can be created without using adiabatic state preparation, and so the ground state energy may be found directly by utilizing phase estimation from the canon.</span></span>

## <a name="shors-algorithm"></a><span data-ttu-id="9eb8b-190">Shor 'ın algoritması</span><span class="sxs-lookup"><span data-stu-id="9eb8b-190">Shor's Algorithm</span></span> ##
<span data-ttu-id="9eb8b-191">Shor 'nin algoritması, hisse ve şu anda sınıflardaki sorunları gidermek için hisse bilgisayarlarının kullanılabileceğini gösterdi, bu, hisse alım açısından en önemli geliştirmelerin birine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-191">Shor's algorithm remains one of the most significant developments in quantum computing because it showed that quantum computers could be used to solve important, currently classically intractable problems.</span></span>
<span data-ttu-id="9eb8b-192">Shor 'ın algoritması, *düzenleme*adlı bir sorun olan bir hisse bilgisayarı kullanarak büyük sayıları çarpanlarına yönelik hızlı bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-192">Shor's algorithm provides a fast way to factor large numbers using a quantum computer, a problem called *factoring*.</span></span>
<span data-ttu-id="9eb8b-193">Birçok mevcut günlük cryptosystems güvenliği, düzenleme için hızlı algoritma yok varsayımına dayanır.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-193">The security of many present-day cryptosystems is based on the assumption that no fast algorithm exists for factoring.</span></span>
<span data-ttu-id="9eb8b-194">Bu nedenle, Shor 'nın algoritması, bir hisse alım dünyasının güvenliğini nasıl düşündüğimizi gösteren bir etkiye sahip oldu.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-194">Thus Shor's algorithm has had a profound impact on how we think about security in a post-quantum world.</span></span>

<span data-ttu-id="9eb8b-195">Shor 'ın algoritması karma algoritma olarak düşünülebilir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-195">Shor's algorithm can be thought of as a hybrid algorithm.</span></span>
<span data-ttu-id="9eb8b-196">Hisse bilgisayar, dönem bulma olarak bilinen bir hesaplama sabit görevi gerçekleştirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-196">The quantum computer is used to perform a computationally hard task known as period finding.</span></span>
<span data-ttu-id="9eb8b-197">Süre bulmanın sonuçları, faktörleri tahmin etmek için sınıfda olarak işlenir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-197">The results from period finding are then classically processed to estimate the factors.</span></span>
<span data-ttu-id="9eb8b-198">Bu iki adımı aşağıda gözden geçiririz.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-198">We review these two steps below.</span></span>

### <a name="period-finding"></a><span data-ttu-id="9eb8b-199">Süre bulma</span><span class="sxs-lookup"><span data-stu-id="9eb8b-199">Period Finding</span></span> ###

<span data-ttu-id="9eb8b-200">Hisse maadı ve aşama tahmini 'nin nasıl çalıştığını (bkz. [hisse algoritmaları](xref:microsoft.quantum.libraries.standard.algorithms)) gördük, bu araçları, *Dönem bulma*adlı bir sınıf olarak zor hesaplama sorununu çözmek için kullanabiliriz.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-200">Having seen how the quantum Fourier transform and phase estimation work (see [Quantum algorithms](xref:microsoft.quantum.libraries.standard.algorithms)), we can use these tools to solve a classically hard computational problem called *period finding*.</span></span>  <span data-ttu-id="9eb8b-201">Sonraki bölümde, düzenleme ' ye nasıl bir süre bulmayı uygulayacağınızı inceleyeceğiz.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-201">In the next section, we will see how to apply period finding to factoring.</span></span>

<span data-ttu-id="9eb8b-202">$A $ ve $N $ $ $a < N $, burada bulma sırası olarak da adlandırılan, bulma dönemi hedefi $r $ mod $a _$ $N $_ $r $, $a $ $. \equ1 \Text{mod} N $ gibi en az pozitif tamsayı olacak şekilde tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-202">Given two integers $a$ and $N$, where $a<N$, the goal of period finding, also called order finding, is to find the _order_ $r$ of $a$ modulo $N$, where $r$ is defined to be the least positive integer such that $a^r \equiv 1 \text{ mod } N$.</span></span>  

<span data-ttu-id="9eb8b-203">Bir hisse bilgisayarı kullanarak siparişi bulmak için aşağıdaki Unitary işlecine uygulanan aşama tahmini algoritmasını, _a $: $ $ U_a\ket {x} \equk\ket{(AX) \Text{mod} N} $U kullanabilirsiniz. $ $ $U _a $ öğesinin eigenvektörler tamsayı $s $ ve $0 \ LEQ s \leq r-$1 , $ $ \ket{x_s} \equıv 1/\sqrt{r} \sum\_{k = 0} ^ {r-1} e ^ {\frac{-2\pı ı SK} {r}} \ket{a ^ k\text {mod} N}, $ $, $U _a $ arasındaki _eigenstates_ .</span><span class="sxs-lookup"><span data-stu-id="9eb8b-203">To find the order using a quantum computer, we can use the phase estimation algorithm applied to the following unitary operator $U_a$: $$ U_a\ket{x} \equiv \ket{(ax)\text{ mod }N} .$$ The eigenvectors of $U_a$ are for integer $s$ and $0\leq s \leq r - 1$, $$\ket{x_s} \equiv 1 / \sqrt{r} \sum\_{k=0}^{r-1} e^{\frac{-2\pi i sk}{r}} \ket{a^k\text{ mod }N},$$ are _eigenstates_ of $U_a$.</span></span>
<span data-ttu-id="9eb8b-204">$U _a $\_eigenvalues değeri, \ket{x\_s} = e ^ {2 \ Pi i s/r} \ket{x\_s}.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-204">The eigenvalues of $U_a$ are $$ U\_a \ket{x\_s} = e^{2\pi i s / r} \ket{x\_s} .</span></span> $$

<span data-ttu-id="9eb8b-205">Bu nedenle, aşama tahmini, $s/r $ ' den [devam eden kesirleri](https://en.wikipedia.org/wiki/Continued_fraction) kullanarak $r $ tarafından verimli bir şekilde öğrenildiği ^ {2 \ Pi i s/r} $ $e eigenvalues verir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-205">Phase estimation thus outputs the eigenvalues $e^{2\pi i s / r}$ from which $r$ can be learned efficiently using [continued fractions](https://en.wikipedia.org/wiki/Continued_fraction) from $s / r$.</span></span>

<span data-ttu-id="9eb8b-206">Hisse dönemi bulma için devre diyagramı:</span><span class="sxs-lookup"><span data-stu-id="9eb8b-206">The circuit diagram for quantum period finding is:</span></span>

![](./../../media/QPE.svg)

<span data-ttu-id="9eb8b-207">Burada $2n $ qubit $ \tus{0}$ olarak başlatılır $n ve $ qubits, $ \gre{1}$ olarak başlatılır.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-207">Here $2n$ qubits are initialized to $\ket{0}$ and $n$ qubits are initialized to $\ket{1}$.</span></span>
<span data-ttu-id="9eb8b-208">Okuyucu yeniden, eigenstates 'i tutmak üzere hisse kayıt 'nın $ \tus{1}$ olarak başlatıldığını merak edebilir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-208">The reader again may wonder why the quantum register to hold the eigenstates is initialized to $\ket{1}$.</span></span>
<span data-ttu-id="9eb8b-209">Bir tane $r $ değerini önceden değil, aslında $ \ket{x_s} $ durumlarını doğrudan hazırlayamıyoruz.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-209">As one does not know the order $r$ in advance, we cannot actually prepare $\ket{x_s}$ states directly.</span></span>
<span data-ttu-id="9eb8b-210">Luckily, bu $1/\ sqrt {r} \sum\_{s = 0} ^ {r-1} \ket{x\_s} = \tus{1}$ öğesini kapatır.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-210">Luckily, it turns out that $1/\sqrt{r} \sum\_{s=0}^{r-1} \ket{x\_s} = \ket{1}$.</span></span>
<span data-ttu-id="9eb8b-211">Gerçekten $ \ket{x} $ ' i hazırlamak zorunda değildir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-211">We don't need to actually prepare $\ket{x}$!</span></span>
<span data-ttu-id="9eb8b-212">$N $ qubits 'in, State $ \tus{1}$ içinde yalnızca bir hisse kayıt hazırlayabiliriz.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-212">We can just prepare a quantum register of $n$ qubits in state $\ket{1}$.</span></span> 

<span data-ttu-id="9eb8b-213">Devre, QFT ve çeşitli kontrollü kapıları içerir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-213">The circuit contains the QFT and several controlled gates.</span></span>
<span data-ttu-id="9eb8b-214">QFT kapısı [daha önce](xref:microsoft.quantum.libraries.standard.algorithms)açıklanmıştı.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-214">The QFT gate has been described [previously](xref:microsoft.quantum.libraries.standard.algorithms).</span></span>
<span data-ttu-id="9eb8b-215">Denetim qubit $ \tus{1}$ ve $ \ket{x} $ ' i $ \ket{x} $ ' e eşler $ \ istemci, $ \ değer \ metin {mod} N} $ ile $ \ket{x} $, kontrollü-$U _a $ kapısı haritaları.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-215">The controlled-$U_a$ gate maps $\ket{x}$ to $\ket{(ax)\text{ mod } N}$ if the control qubit is $\ket{1}$, and maps $\ket{x}$ to $\ket{x}$ otherwise.</span></span>

<span data-ttu-id="9eb8b-216">$ (A ^ NX) \Text{mod} N $ ' ı elde etmek için, yalnızca $a ^ n \Text{mod} N $ sınıfındaki $U.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-216">To achieve $(a^nx)\text{ mod } N$,  we can simply apply controlled-$U_{a^n}$, where we calculate $a^n \text{ mod } N$ classically to plug into the quantum circuit.</span></span>  
<span data-ttu-id="9eb8b-217">Bu tür Modüler aritmetik elde etme devrelerine [, özellikle](./algorithms.md#arithmetic)de denetlenen-$U\_{a ^ ı} $ işlemlerini uygulamak için modüler üs bir devreniz olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-217">The circuits to achieve such modular arithmetic have been described in the [quantum arithmetic documentation](./algorithms.md#arithmetic), specifically we require a modular exponentiation circuit to implement the controlled-$U\_{a^i}$ operations.</span></span>

<span data-ttu-id="9eb8b-218">Yukarıdaki devre, [hisse miktarı tahminine](xref:microsoft.quantum.characterization.quantumphaseestimation) karşılık gelir ve açıkça sıra bulma imkanı sağladığından, gereken qubits sayısını azaltabiliriz.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-218">While the circuit above corresponds to [Quantum Phase Estimation](xref:microsoft.quantum.characterization.quantumphaseestimation) and explicitly enables order finding, we can reduce the number of qubits required.</span></span> <span data-ttu-id="9eb8b-219">Beauregard 'in [, Arxıv: Quant-pH/, 5095v3 sayfa 8](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8)' de açıklandığı gibi sipariş bulma yöntemini takip edebilir veya Microsoft. hisse. Canon ' de bulunan aşama tahmini yordamlardan birini kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-219">We can either follow Beauregard's method for order finding as described [on Page 8 of arXiv:quant-ph/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), or use one of the phase estimation routines available in Microsoft.Quantum.Canon.</span></span> <span data-ttu-id="9eb8b-220">Örneğin, [sağlam aşama tahmini](xref:microsoft.quantum.characterization.robustphaseestimation) de bir ek qubit kullanır.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-220">For example, [Robust Phase Estimation](xref:microsoft.quantum.characterization.robustphaseestimation) also uses one extra qubit.</span></span>
 
### <a name="factoring"></a><span data-ttu-id="9eb8b-221">Düzenleme</span><span class="sxs-lookup"><span data-stu-id="9eb8b-221">Factoring</span></span> ###
<span data-ttu-id="9eb8b-222">Düzenleme 'in hedefi, $N $ tam sayı çarpanlarının belirlenmesi, burada $N $ bir $n $ bit sayıdır.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-222">The goal of factoring is to determine the two prime factors of integer $N$, where $N$ is an $n$-bit number.</span></span>  
<span data-ttu-id="9eb8b-223">Düzenleme, aşağıda açıklanan adımlardan oluşur.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-223">Factoring consists of the steps described below.</span></span> <span data-ttu-id="9eb8b-224">Adımlar üç parçaya ayrılır: klasik bir ön işleme yordamı (1-4); $a \Text{mod} N $ (5); sırasını bulmak için bir hisse bilgi işlem yordamı ve sıra (6-9) ile aynı ana faktörleri türetmede bir klasik özelleştirmediğiniz yordamı.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-224">The steps are split into three parts: a classical preprocessing routine (1-4); a quantum computing routine to find the order of $a \text{ mod } N$ (5); and a classical postprocessing routine to derive the prime factors from the order (6-9).</span></span>

<span data-ttu-id="9eb8b-225">Klasik ön işleme yordamı aşağıdaki adımlardan oluşur:</span><span class="sxs-lookup"><span data-stu-id="9eb8b-225">The classical preprocessing routine consists of the following steps:</span></span>
1. <span data-ttu-id="9eb8b-226">$N $ çiftse, ana faktör $2 $ ' i döndürün.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-226">If $N$ is even, return the prime factor $2$.</span></span>
2. <span data-ttu-id="9eb8b-227">$P \geq1 $, $q \geq2 $ için $N = p ^ q $, ana faktör $p $ döndürün.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-227">If $N=p^q$ for $p\geq1$, $q\geq2$, return the prime factor $p$.</span></span>  <span data-ttu-id="9eb8b-228">Bu adım sınıf aracılığıyla yapılır.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-228">This step is performed classically.</span></span>
3. <span data-ttu-id="9eb8b-229">$1 < N-$1 < $a rastgele bir sayı seçin.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-229">Choose a random number $a$ such that $1 < a < N-1$.</span></span>
4. <span data-ttu-id="9eb8b-230">$ \Text{GCD} (a, N) > 1 $ ise, $ \Text{GCD} (a, N) $ ana faktörünü döndürün.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-230">If $\text{gcd}(a,N)>1$, return the prime factor $\text{gcd}(a,N)$.</span></span> <span data-ttu-id="9eb8b-231">Bu adım Euclid 'nin algoritması kullanılarak hesaplanır.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-231">This step is computed using Euclid's algorithm.</span></span>
<span data-ttu-id="9eb8b-232">Hiçbir ana faktör döndürülmezse, hisse için bu yordama devam ediyoruz:</span><span class="sxs-lookup"><span data-stu-id="9eb8b-232">If no prime factor has been returned, we proceed to the quantum routine:</span></span>
5. <span data-ttu-id="9eb8b-233">$A \Text{mod} N $ öğesinin $r $ sırasını hesaplamak için hisse dönemi bulma algoritmasını çağırın.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-233">Call the quantum period finding algorithm to calculate the order $r$ of $a \text{ mod } N$.</span></span> <span data-ttu-id="9eb8b-234">Ana faktörleri öğrenmek için klasik özelleştirmediğiniz yordamında $r $ kullanın:</span><span class="sxs-lookup"><span data-stu-id="9eb8b-234">Use $r$ in the classical postprocessing routine to determine the prime factors:</span></span>
6. <span data-ttu-id="9eb8b-235">$R $ tek ise, ön işleme adımına geri dönün (3).</span><span class="sxs-lookup"><span data-stu-id="9eb8b-235">If $r$ is odd, go back to preprocessing step (3).</span></span>
7. <span data-ttu-id="9eb8b-236">$R $ çift ve $a ^ {r/2} =-1 \ metin {mod} N $, ön işleme adımına geri dönün (3).</span><span class="sxs-lookup"><span data-stu-id="9eb8b-236">If $r$ is even and $a^{r/2} = -1\text{ mod }N$, go back to preprocessing step (3).</span></span>
8. <span data-ttu-id="9eb8b-237">$ \Text{GCD} (bir ^ {r/2} + 1, N) $, $N $, return $ \Text{GCD} (a ^ {r/2} + 1, N) $ olan önemsiz olmayan bir faktördür.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-237">If $\text{gcd}(a^{r/2}+1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}+1, N)$.</span></span>
9. <span data-ttu-id="9eb8b-238">$ \Text{GCD} (a ^ {r/2}-1, N) $, $N $, return $ \Text{GCD} (a ^ {r/2}-1, N) $ olan basit olmayan bir faktördür.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-238">If $\text{gcd}(a^{r/2}-1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}-1, N)$.</span></span>


<span data-ttu-id="9eb8b-239">Düzenleme algoritması dayalı: en az bir yarısı, $r $ 'nin eşit olduğu $a ve ^ {r/2} \neq-1 \ Text{mod} N $, bu nedenle de asal bir faktör üreten bir yarı olasılık ile gösterilmiştir.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-239">The factoring algorithm is probabilistic: it can been shown that with probability at least one half that $r$ will be even and $a^{r/2} \neq -1 \text{ mod }N$, thus producing a prime factor.</span></span>  <span data-ttu-id="9eb8b-240">(Daha fazla bilgi Için bkz. [Shor 'ın özgün kağıdına](https://doi.org/10.1109/SFCS.1994.365700) veya [daha fazla bilgi için](xref:microsoft.quantum.more-information)içindeki *temel hisse bilgi işlem* metinlarından biri).</span><span class="sxs-lookup"><span data-stu-id="9eb8b-240">(See [Shor's original paper](https://doi.org/10.1109/SFCS.1994.365700) for details, or one of the *Basic quantum computing* texts in [For more information](xref:microsoft.quantum.more-information)).</span></span>
<span data-ttu-id="9eb8b-241">Bir asal faktör döndürülmezse, (1) adımından algoritmayı tekrarlıyoruz.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-241">If a prime factor is not returned, then we simply repeat the algorithm from step (1).</span></span>  <span data-ttu-id="9eb8b-242">$N $ deneme sonrasında, her girişim başarısız olma olasılığı en fazla $2 ^ {-n} $ olur.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-242">After $n$ tries, the probability that every attempt has failed is at most $2^{-n}$.</span></span>
<span data-ttu-id="9eb8b-243">Bu nedenle, algoritmayı tekrarladıktan sonra çok az sayıda başarı oluşur.</span><span class="sxs-lookup"><span data-stu-id="9eb8b-243">Thus after repeating the algorithm a small number of times success is virtually assured.</span></span>
