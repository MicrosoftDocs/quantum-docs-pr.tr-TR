---
title: 'Q # standart kitaplıklarında hata düzeltme'
description: "Qubits 'in durumunu korurken, Q # programlarınızda hata düzeltme kodlarını nasıl kullanacağınızı öğrenin."
author: QuantumWriter
uid: microsoft.quantum.libraries.error-correction
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 514fe68f603b9a3a0b4607390719b08a43fe4967
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907775"
---
# <a name="error-correction"></a><span data-ttu-id="11d96-103">Hata Düzeltme</span><span class="sxs-lookup"><span data-stu-id="11d96-103">Error Correction</span></span> #

## <a name="introduction"></a><span data-ttu-id="11d96-104">Giriş</span><span class="sxs-lookup"><span data-stu-id="11d96-104">Introduction</span></span> ##

<span data-ttu-id="11d96-105">Klasik bilgi işlem 'da, bir bit hataları hatalara karşı korumak istiyorsa, veri bitini tekrarlayarak bu bit, *mantıksal bir bite* göre temsil etmek için genellikle yeterli olur.</span><span class="sxs-lookup"><span data-stu-id="11d96-105">In classical computing, if one wants to protect a bit against errors, it can often suffice to represent that bit by a *logical bit* by repeating the data bit.</span></span>
<span data-ttu-id="11d96-106">Örneğin, 0 durumundaki bir bit kodlama olduğunu göstermek için 0 etiketinin üzerindeki bir satırı kullandığımızda $ \üstünü{0} = $0, veri biti 0 kodlaması olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="11d96-106">For instance, let $\overline{0} = 000$ be the encoding of the data bit 0, where we use the a line above the label 0 to indicate that it is an encoding of a bit in the 0 state.</span></span>
<span data-ttu-id="11d96-107">Aynı şekilde $ \üst çizgi{1} = $111 olmasına izin verdiğimiz takdirde, herhangi bir bit çevirme hatasına karşı koruyan basit bir yineleme kodu sunuyoruz.</span><span class="sxs-lookup"><span data-stu-id="11d96-107">If we similarly let $\overline{1} = 111$, then we have a simple repetition code that protects against any one bit flip error.</span></span>
<span data-ttu-id="11d96-108">Diğer bir deyişle, üç bitten herhangi biri çevrildeyse, büyük bir oy alarak mantıksal bit durumunu kurtarabiliriz.</span><span class="sxs-lookup"><span data-stu-id="11d96-108">That is, if any of the three bits are flipped, then we can recover the state of the logical bit by taking a majority vote.</span></span>
<span data-ttu-id="11d96-109">Klasik hata düzeltmesi, bu belirli örnekte çok daha zengin bir konudur ( [Lint 'in kodlama teorisine giriş](https://www.springer.com/us/book/9783540641339)önerisi önerilir), yukarıdaki yineleme kodu, hisse bilgilerini koruyan olası bir sorunu işaret eder.</span><span class="sxs-lookup"><span data-stu-id="11d96-109">Though classical error correction is a much richer subject that this particular example (we recommend [Lint's introduction to coding theory](https://www.springer.com/us/book/9783540641339)), the repetition code above already points to a possible problem in protecting quantum information.</span></span>
<span data-ttu-id="11d96-110">Yani, [hiçbir](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) bireysel bilgi bitini ölçyoruz ve yukarıdaki benzerleme vurguladı ile klasik kod ile büyük bir oy alıp aldığımızda, korumaya çalışmamız gereken kesin bilgileri kaybettiğimiz anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="11d96-110">Namely, the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) implies that if we measure each individual qubit and take a majority vote by analogy to classical code above, then we have lost the precise information that we are trying to protect.</span></span>

<span data-ttu-id="11d96-111">Hisse birimi ayarında, ölçümün sorunlu olduğunu görüyoruz.</span><span class="sxs-lookup"><span data-stu-id="11d96-111">In the quantum setting, we will see that the measurement is problematic.</span></span> <span data-ttu-id="11d96-112">Yukarıdaki kodlamayı yine de uygulayabiliriz.</span><span class="sxs-lookup"><span data-stu-id="11d96-112">We can still implement the encoding above.</span></span>
<span data-ttu-id="11d96-113">Bu, hisse vaya hata düzeltmesini nasıl genelleştirmemiz gerektiğini görmek için yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="11d96-113">It is helpful to do so to see how we can generalize error correction to the quantum case.</span></span>
<span data-ttu-id="11d96-114">Bu nedenle, $ \ket{\üst çizgi{0}} = \demet{000} = \ayraç{0} \otimes \demet{0} \otimes \tus{0}$, ve Let $ \ket{\üst çizgi{1}} = \tus{111}$.</span><span class="sxs-lookup"><span data-stu-id="11d96-114">Thus, let $\ket{\overline{0}} = \ket{000} = \ket{0} \otimes \ket{0} \otimes \ket{0}$, and let $\ket{\overline{1}} = \ket{111}$.</span></span>
<span data-ttu-id="11d96-115">Daha sonra, bu, tüm girişler için yineleme kodumuzu tanımladık; Örneğin, $ \ket{\overline{+}} = (\ket{\üst{0}} + \ket{\üst çizgi{1}})/\sqrt{2} = (\tus{000} + \tus{111})/\sqrt{2}$.</span><span class="sxs-lookup"><span data-stu-id="11d96-115">Then, by linearity, we have defined our repetition code for all inputs; for instance, $\ket{\overline{+}} = (\ket{\overline{0}} + \ket{\overline{1}}) / \sqrt{2} = (\ket{000} + \ket{111}) / \sqrt{2}$.</span></span>
<span data-ttu-id="11d96-116">Özellikle, bir bit Çevirme hatası $X _1 $ 'ın ortadaki qubit üzerinde işlem yapmasına izin vermek için her iki dalda de gerekli düzeltmenin tam olarak $X _1 $: $ $ \begin{hizalaması} X_1 \ket{\overline{+}} & = \frac{1}{\sqrt{2}} \left (X_1 \tus{000} + X_1 \tus{111} \right) \\\\ & = \frac{1}{\sqrt{2}} \left (\tus{010} + \tus{101} \ right).</span><span class="sxs-lookup"><span data-stu-id="11d96-116">In particular, letting a bit-flip error $X_1$ act on the middle qubit, we see that the correction needed in both branches is precisely $X_1$: $$ \begin{align} X_1 \ket{\overline{+}} & = \frac{1}{\sqrt{2}} \left( X_1 \ket{000} + X_1 \ket{111} \right) \\\\ & = \frac{1}{\sqrt{2}} \left( \ket{010} + \ket{101} \right).</span></span>
<span data-ttu-id="11d96-117">\end{hizalaması} $ $</span><span class="sxs-lookup"><span data-stu-id="11d96-117">\end{align} $$</span></span>

<span data-ttu-id="11d96-118">Bu durumun, korumaya çalışmamız gereken çok durumu ölçmeden nasıl belirleyebileceklerini öğrenmek için, her farklı bit çevirme hatasının mantıksal durumlarımızla ne kadar olduğunu belirlemek yararlı olur:</span><span class="sxs-lookup"><span data-stu-id="11d96-118">To see how we can identify that this is the case without measuring the very state we are trying to protect, it is helpful to write down what each different bit flip error does to our logical states:</span></span>

| <span data-ttu-id="11d96-119">Hata $E $</span><span class="sxs-lookup"><span data-stu-id="11d96-119">Error $E$</span></span> | <span data-ttu-id="11d96-120">$E \ket{\üst çizgi{0}} $</span><span class="sxs-lookup"><span data-stu-id="11d96-120">$E\ket{\overline{0}}$</span></span> | <span data-ttu-id="11d96-121">$E \ket{\üst çizgi{1}} $</span><span class="sxs-lookup"><span data-stu-id="11d96-121">$E\ket{\overline{1}}$</span></span> |
| --- | --- | --- |
| <span data-ttu-id="11d96-122">$ \ cıvabitti $</span><span class="sxs-lookup"><span data-stu-id="11d96-122">$\boldone$</span></span> | <span data-ttu-id="11d96-123">$ \demet{000}$</span><span class="sxs-lookup"><span data-stu-id="11d96-123">$\ket{000}$</span></span> | <span data-ttu-id="11d96-124">$ \demet{111}$</span><span class="sxs-lookup"><span data-stu-id="11d96-124">$\ket{111}$</span></span> |
| <span data-ttu-id="11d96-125">$X _0 $</span><span class="sxs-lookup"><span data-stu-id="11d96-125">$X_0$</span></span> | <span data-ttu-id="11d96-126">$ \demet{100}$</span><span class="sxs-lookup"><span data-stu-id="11d96-126">$\ket{100}$</span></span> | <span data-ttu-id="11d96-127">$ \demet{011}$</span><span class="sxs-lookup"><span data-stu-id="11d96-127">$\ket{011}$</span></span> |
| <span data-ttu-id="11d96-128">$X _1 $</span><span class="sxs-lookup"><span data-stu-id="11d96-128">$X_1$</span></span> | <span data-ttu-id="11d96-129">$ \demet{010}$</span><span class="sxs-lookup"><span data-stu-id="11d96-129">$\ket{010}$</span></span> | <span data-ttu-id="11d96-130">$ \demet{101}$</span><span class="sxs-lookup"><span data-stu-id="11d96-130">$\ket{101}$</span></span> |
| <span data-ttu-id="11d96-131">$X _2 $</span><span class="sxs-lookup"><span data-stu-id="11d96-131">$X_2$</span></span> | <span data-ttu-id="11d96-132">$ \demet{001}$</span><span class="sxs-lookup"><span data-stu-id="11d96-132">$\ket{001}$</span></span> | <span data-ttu-id="11d96-133">$ \demet{110}$</span><span class="sxs-lookup"><span data-stu-id="11d96-133">$\ket{110}$</span></span> |

<span data-ttu-id="11d96-134">Koddığımız durumu korumak için, {\ket{\üst{0}} $ ve $ \ket{\üst çizgi{1}} $ arasında ayrım yapmadan üç hatayı birbirleriyle ve $ \cıvadone $ kimliğiyle ayırt edebilmemiz gerekir.</span><span class="sxs-lookup"><span data-stu-id="11d96-134">In order to protect the state that we're encoding, we need to be able to distinguish the three errors from each other and from the identity $\boldone$ without distinguishing between $\ket{\overline{0}}$ and $\ket{\overline{1}}$.</span></span>
<span data-ttu-id="11d96-135">Örneğin, $Z _0 $ değerini ölçyoruz, hiçbir hata durumunda $ \ket{\üst çizgi{0}} $ ve $ \ket{\üst çizgi{1}} $ için farklı bir sonuç elde ediyoruz ve bu nedenle kodlanmış durumu daraldık.</span><span class="sxs-lookup"><span data-stu-id="11d96-135">For example, if we measure $Z_0$, we get a different result for $\ket{\overline{0}}$ and $\ket{\overline{1}}$ in the no-error case, so that collapses the encoded state.</span></span>
<span data-ttu-id="11d96-136">Diğer taraftan, her bir hesaplama tabanlı durumda $Z _0 Z_1 $, ilk iki bitin eşlik düzeyini ölçmeye göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="11d96-136">On the other hand, consider measuring $Z_0 Z_1$, the parity of the first two bits in each computational basis state.</span></span>
<span data-ttu-id="11d96-137">Pauli işlecinin her ölçüsünün, ölçülen durumun hangi eigenvalue 'a karşılık geldiğini denetlediğini, yukarıdaki tabloda $ \ket{\psı} $ ' ın her bir durumu için, yukarıdaki tabloda yer alan her durum $ \ma{\psi} $ ' ın, $ \pm\ket{\psı} $ olup olmadığını görmek için $Z _0 Z_1 \ket</span><span class="sxs-lookup"><span data-stu-id="11d96-137">Recall that each measurement of a Pauli operator checks which eigenvalue  the state being measured corresponds to, so for each state $\ket{\psi}$ in the table above, we can compute $Z_0 Z_1 \ket{\psi}$ to see if we get $\pm\ket{\psi}$.</span></span>
<span data-ttu-id="11d96-138">Bu ölçümün her iki kodlanmış duruma de aynı şeyi gerçekleştirmemiz için $Z _0 Z_1 \ayraç{000} = \demet{000}$ $Z Z_1 _0{111} \tus{111}= \tus $ olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="11d96-138">Note that $Z_0 Z_1 \ket{000} = \ket{000}$ and that $Z_0 Z_1 \ket{111} = \ket{111}$, so that we conclude that this measurement does the same thing to both encoded states.</span></span>
<span data-ttu-id="11d96-139">Diğer taraftan, $Z _0 Z_1 \ayraç{100} =-\tus{100}$ ve $Z _0 Z_1 \ayraç{011} =-\tus{011}$, bu nedenle $Z _0 Z_1 $ ölçmesi sonucu oluşan hata oluştuğunda yararlı bilgileri ortaya çıkarır.</span><span class="sxs-lookup"><span data-stu-id="11d96-139">On the other hand, $Z_0 Z_1 \ket{100} = - \ket{100}$ and $Z_0 Z_1 \ket{011} = -\ket{011}$, so the result of measuring $Z_0 Z_1$ reveals useful information about which error occurred.</span></span>

<span data-ttu-id="11d96-140">Bunu vurgulamak için yukarıdaki tabloyu yineliyoruz, ancak her satırda $Z _0 Z_1 $ ve $Z _1 Z_2 $ ölçüm sonuçlarını eklersiniz.</span><span class="sxs-lookup"><span data-stu-id="11d96-140">To emphasize this, we repeat the table above, but add the results of measuring $Z_0 Z_1$ and $Z_1 Z_2$ on each row.</span></span>
<span data-ttu-id="11d96-141">Her ölçümün sonucunu, sırasıyla, `Zero` ve `One`'nin Q # `Result` değerlerine karşılık gelen $ + $ veya $-$ şeklinde gözlemlenen eigenvalue değerinin işaretine göre gösterir.</span><span class="sxs-lookup"><span data-stu-id="11d96-141">We denote the results of each measurement by the sign of the eigenvalue that is observed, either $+$ or $-$, corresponding to the Q# `Result` values of `Zero` and `One`, respectively.</span></span>

| <span data-ttu-id="11d96-142">Hata $E $</span><span class="sxs-lookup"><span data-stu-id="11d96-142">Error $E$</span></span> | <span data-ttu-id="11d96-143">$E \ket{\üst çizgi{0}} $</span><span class="sxs-lookup"><span data-stu-id="11d96-143">$E\ket{\overline{0}}$</span></span> | <span data-ttu-id="11d96-144">$E \ket{\üst çizgi{1}} $</span><span class="sxs-lookup"><span data-stu-id="11d96-144">$E\ket{\overline{1}}$</span></span> | <span data-ttu-id="11d96-145">Sonuç olarak $Z _0 Z_1 $</span><span class="sxs-lookup"><span data-stu-id="11d96-145">Result of $Z_0 Z_1$</span></span> | <span data-ttu-id="11d96-146">$Z _1 Z_2 $ sonucu</span><span class="sxs-lookup"><span data-stu-id="11d96-146">Result of $Z_1 Z_2$</span></span> |
| --- | --- | --- | --- | --- |
| <span data-ttu-id="11d96-147">$ \ cıvabitti $</span><span class="sxs-lookup"><span data-stu-id="11d96-147">$\boldone$</span></span> | <span data-ttu-id="11d96-148">$ \demet{000}$</span><span class="sxs-lookup"><span data-stu-id="11d96-148">$\ket{000}$</span></span> | <span data-ttu-id="11d96-149">$ \demet{111}$</span><span class="sxs-lookup"><span data-stu-id="11d96-149">$\ket{111}$</span></span> | $+$ | $+$ |
| <span data-ttu-id="11d96-150">$X _0 $</span><span class="sxs-lookup"><span data-stu-id="11d96-150">$X_0$</span></span> | <span data-ttu-id="11d96-151">$ \demet{100}$</span><span class="sxs-lookup"><span data-stu-id="11d96-151">$\ket{100}$</span></span> | <span data-ttu-id="11d96-152">$ \demet{011}$</span><span class="sxs-lookup"><span data-stu-id="11d96-152">$\ket{011}$</span></span> | $-$ | $+$ |
| <span data-ttu-id="11d96-153">$X _1 $</span><span class="sxs-lookup"><span data-stu-id="11d96-153">$X_1$</span></span> | <span data-ttu-id="11d96-154">$ \demet{010}$</span><span class="sxs-lookup"><span data-stu-id="11d96-154">$\ket{010}$</span></span> | <span data-ttu-id="11d96-155">$ \demet{101}$</span><span class="sxs-lookup"><span data-stu-id="11d96-155">$\ket{101}$</span></span> | $-$ | $-$ |
| <span data-ttu-id="11d96-156">$X _2 $</span><span class="sxs-lookup"><span data-stu-id="11d96-156">$X_2$</span></span> | <span data-ttu-id="11d96-157">$ \demet{001}$</span><span class="sxs-lookup"><span data-stu-id="11d96-157">$\ket{001}$</span></span> | <span data-ttu-id="11d96-158">$ \demet{110}$</span><span class="sxs-lookup"><span data-stu-id="11d96-158">$\ket{110}$</span></span> | $+$ | $-$ |

<span data-ttu-id="11d96-159">Bu nedenle, iki ölçümün sonuçları, hangi bit çevirme hatasının oluştuğunu benzersiz olarak belirler, ancak hangi durumu kodladığımızda bilgi vermeksizin.</span><span class="sxs-lookup"><span data-stu-id="11d96-159">Thus, the results of the two measurements uniquely determines which bit-flip error occurred, but without revealing any information about which state we encoded.</span></span>
<span data-ttu-id="11d96-160">Bu sonuçlara bir *sendromu*çağrısı yaptık ve bir sendromu 'yi *Kurtarma*olarak neden olan hataya geri eşleme sürecine başvurduk.</span><span class="sxs-lookup"><span data-stu-id="11d96-160">We call these results a *syndrome*, and refer to the process of mapping a syndrome back to the error that caused it as *recovery*.</span></span>
<span data-ttu-id="11d96-161">Özellikle, kurtarma işlemi, oluşan sendromu girişi olarak geçen bir *Klasik* çıkarım prosedürü ve oluşmuş olabilecek hataların nasıl düzeltileceğiyle ilgili bir hata döndürür.</span><span class="sxs-lookup"><span data-stu-id="11d96-161">In particular, we emphasize that recovery is a *classical* inference procedure which takes as its input the syndrome which occurred, and returns a prescription for how to fix any errors that may have occurred.</span></span>

> [!NOTE]
> <span data-ttu-id="11d96-162">Yukarıdaki bit çevirme kodu yalnızca tek bit çevirme hatalarına karşı doğru olabilir; diğer bir deyişle, tek bir qubit üzerinde işlem gören `X` bir işlemdir.</span><span class="sxs-lookup"><span data-stu-id="11d96-162">The bit-flip code above can only correct against single bit-flip errors; that is, an `X` operation acting on a single qubit.</span></span>
> <span data-ttu-id="11d96-163">Birden fazla qubit 'e `X` uygulamak, $ \ket{\üst çizgi{0}} $ öğesini $ \ket{\üst çizgi{1}} $ ile Şu kurtarma için eşleştirir.</span><span class="sxs-lookup"><span data-stu-id="11d96-163">Applying `X` to more than one qubit will map $\ket{\overline{0}}$ to $\ket{\overline{1}}$ following recovery.</span></span>
> <span data-ttu-id="11d96-164">Benzer şekilde, bir aşama çevirme işleminin uygulanması `Z` $ \ket{\üst çizgi{1}} $ $-\ket{\üst çizgi{1}} $ olarak eşlenir ve bu nedenle $ \ket{\overline{+}} $ ile $ \ket{\üst çizgi{-}} $ arasında eşleme olur.</span><span class="sxs-lookup"><span data-stu-id="11d96-164">Similarly, applying a phase flip operation `Z` will map $\ket{\overline{1}}$ to $-\ket{\overline{1}}$, and hence will map $\ket{\overline{+}}$ to $\ket{\overline{-}}$.</span></span>
> <span data-ttu-id="11d96-165">Genellikle, daha fazla hata sayısını işlemek ve $Z $ hata ve $X $ hatası işlemek için kodlar oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="11d96-165">More generally, codes can be created to handle larger number of errors, and to handle $Z$ errors as well as $X$ errors.</span></span>

<span data-ttu-id="11d96-166">Ölçümleri, tüm kod durumlarında aynı şekilde davranan hisse hata düzeltmesine ilişkin ölçümleri anlayabiliriz *.*</span><span class="sxs-lookup"><span data-stu-id="11d96-166">The insight that we can describe measurements in quantum error correction that act the same way on all code states, is the essence of the *stabilizer formalism*.</span></span>
<span data-ttu-id="11d96-167">Q # Canon, sabitleyici kodlardan kodlama ve kod çözme hakkında bir çerçeve sağlar ve bir hata durumundan nasıl kurtardığını tanımlar.</span><span class="sxs-lookup"><span data-stu-id="11d96-167">The Q# canon provides a framework for describing encoding into and decoding from stabilizer codes, and for describing how one recovers from errors.</span></span>
<span data-ttu-id="11d96-168">Bu bölümde, bu Framework 'ü ve uygulamayı birkaç basit hisse hata düzeltme koduna anladık.</span><span class="sxs-lookup"><span data-stu-id="11d96-168">In this section, we describe this framework and its application to a few simple quantum error-correcting codes.</span></span>

> [!TIP]
> <span data-ttu-id="11d96-169">Sabitleyici formalroni'ya tam giriş, bu bölümün kapsamının dışındadır.</span><span class="sxs-lookup"><span data-stu-id="11d96-169">A full introduction to the stabilizer formalism is beyond the scope of this section.</span></span>
> <span data-ttu-id="11d96-170">[Gottesman 2009](https://arxiv.org/abs/0904.2557)' ye daha fazla bilgi edinmek isteyen okuyucular hakkında bilgi veririz.</span><span class="sxs-lookup"><span data-stu-id="11d96-170">We refer readers interested in learning more to [Gottesman 2009](https://arxiv.org/abs/0904.2557).</span></span>

## <a name="representing-error-correcting-codes-in-q"></a><span data-ttu-id="11d96-171">Q 'daki hata düzeltme kodlarını temsil etme #</span><span class="sxs-lookup"><span data-stu-id="11d96-171">Representing Error Correcting Codes in Q#</span></span> ##

<span data-ttu-id="11d96-172">Q # Canon, hata düzeltme kodları belirtmeye yardımcı olmak için birkaç farklı Kullanıcı tanımlı tür sağlar:</span><span class="sxs-lookup"><span data-stu-id="11d96-172">To help specify error correcting codes, the Q# canon provides several distinct user-defined types:</span></span>

- <span data-ttu-id="11d96-173"><xref:microsoft.quantum.errorcorrection.logicalregister> `= Qubit[]`: bir qubits kaydının bir hata düzeltme kodunun kod bloğu olarak yorumlanması gerektiğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="11d96-173"><xref:microsoft.quantum.errorcorrection.logicalregister> `= Qubit[]`: Denotes that a register of qubits should be interpreted as the code block of an error-correcting code.</span></span>
- <span data-ttu-id="11d96-174"><xref:microsoft.quantum.errorcorrection.syndrome> `= Result[]`: bir ölçüm sonuçları dizisinin, bir kod bloğunda ölçülen sendromu olarak yorumlanması gerektiğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="11d96-174"><xref:microsoft.quantum.errorcorrection.syndrome> `= Result[]`: Denotes that an array of measurement results should be interpreted as the syndrome measured on a code block.</span></span>
- <span data-ttu-id="11d96-175"><xref:microsoft.quantum.errorcorrection.recoveryfn> `= (Syndrome -> Pauli[])`: bir *Klasik* işlevin, bir sendromu yorumlamak için kullanılması gerektiğini ve uygulanması gereken bir düzeltme döndürmesi gerektiğini belirtir.</span><span class="sxs-lookup"><span data-stu-id="11d96-175"><xref:microsoft.quantum.errorcorrection.recoveryfn> `= (Syndrome -> Pauli[])`: Denotes that a *classical* function should be used to interpret a syndrome and return a correction that should be applied.</span></span>
- <span data-ttu-id="11d96-176"><xref:microsoft.quantum.errorcorrection.encodeop> `= ((Qubit[], Qubit[]) => LogicalRegister)`: bir işlemin bir hata düzeltme kodunun kod bloğunu oluşturmak için yeni Andalla qubits ile birlikte verileri temsil eden qubits aldığını gösterir.</span><span class="sxs-lookup"><span data-stu-id="11d96-176"><xref:microsoft.quantum.errorcorrection.encodeop> `= ((Qubit[], Qubit[]) => LogicalRegister)`: Denotes that an operation takes qubits representing data along with fresh ancilla qubits in order to produce a code block of an error-correcting code.</span></span>
- <span data-ttu-id="11d96-177"><xref:microsoft.quantum.errorcorrection.decodeop> `= (LogicalRegister => (Qubit[], Qubit[]))`: bir işlemin kod bloğunu, verileri veri qubits 'e düzeltme hatası ve sendromu bilgilerini temsil etmek için kullanılan anetla qubits.</span><span class="sxs-lookup"><span data-stu-id="11d96-177"><xref:microsoft.quantum.errorcorrection.decodeop> `= (LogicalRegister => (Qubit[], Qubit[]))`: Denotes than an operation decomposes a code block of an error correcting code into the data qubits and the ancilla qubits used to represent syndrome information.</span></span>
- <span data-ttu-id="11d96-178"><xref:microsoft.quantum.errorcorrection.syndromemeasop> `= (LogicalRegister => Syndrome)`: kod tarafından korunan durumu etkilemeden bir kod bloğundan sendromu bilgilerini ayıklamak için kullanılması gereken bir işlemi gösterir.</span><span class="sxs-lookup"><span data-stu-id="11d96-178"><xref:microsoft.quantum.errorcorrection.syndromemeasop> `= (LogicalRegister => Syndrome)`: Denotes an operation that should be used to extract syndrome information from a code block, without disturbing the state protected by the code.</span></span>

<span data-ttu-id="11d96-179">Son olarak, Canon, bir hisse hata düzeltme kodu tanımlamak için gereken diğer türleri toplamak üzere <xref:microsoft.quantum.errorcorrection.qecc> türünü sağlar.</span><span class="sxs-lookup"><span data-stu-id="11d96-179">Finally, the canon provides the <xref:microsoft.quantum.errorcorrection.qecc> type to collect the other types required to define a quantum error-correcting code.</span></span> <span data-ttu-id="11d96-180">Her bir sabitleyici hisse ıcı kodu ile ilişkili kod uzunluğu $n $, mantıksal qubit sayısı $k $, ve en düşük uzaklık $d $, genellikle ⟦ $n $, $k $, $d $ ⟧ gösteriminde kolay bir şekilde gruplanırlar.</span><span class="sxs-lookup"><span data-stu-id="11d96-180">Associated with each stabilizer quantum code is the code length $n$, the number $k$ of logical qubits, and the minimum distance $d$, often conveniently grouped together in the notation ⟦$n$, $k$, $d$⟧.</span></span> <span data-ttu-id="11d96-181">Örneğin, <xref:microsoft.quantum.errorcorrection.bitflipcode> işlevi ⟦ 3, 1, 1 ⟧ bit çevirme kodunu tanımlar:</span><span class="sxs-lookup"><span data-stu-id="11d96-181">For example, the <xref:microsoft.quantum.errorcorrection.bitflipcode> function defines the ⟦3, 1, 1⟧ bit flip code:</span></span>

```qsharp
let encodeOp = EncodeOp(BitFlipEncoder);
let decodeOp = DecodeOp(BitFlipDecoder);
let syndMeasOp = SyndromeMeasOp(MeasureStabilizerGenerators([
    [PauliZ, PauliZ, PauliI],
    [PauliI, PauliZ, PauliZ]
], _, MeasureWithScratch));
let code = QECC(encodeOp, decodeOp, syndMeasOp);
```

<span data-ttu-id="11d96-182">`QECC` türünün bir kurtarma *işlevi içermediğinden emin* olun.</span><span class="sxs-lookup"><span data-stu-id="11d96-182">Notice that the `QECC` type does *not* include a recovery function.</span></span>
<span data-ttu-id="11d96-183">Bu, kodun kendi tanımını değiştirmeden hataları düzeltmek için kullanılan kurtarma işlevini değiştirememize olanak sağlar; Bu özellik, karakter seçme ölçümlerinden geri bildirim kurtarma tarafından kabul edilen modele dahil edildiğinde özellikle kullanışlıdır.</span><span class="sxs-lookup"><span data-stu-id="11d96-183">This allows us to change the recovery function that is used in correcting errors without changing the definition of the code itself; this ability is in particular useful when incorporating feedback from characterization measurements into the model assumed by recovery.</span></span>

<span data-ttu-id="11d96-184">Bir kod bu şekilde tanımlandıktan sonra, hatalardan kurtulmak için <xref:microsoft.quantum.errorcorrection.recover> işlemini kullanabiliriz:</span><span class="sxs-lookup"><span data-stu-id="11d96-184">Once a code is defined in this way, we can use the <xref:microsoft.quantum.errorcorrection.recover> operation to recover from errors:</span></span>

```qsharp
let code = BitFlipCode();
let fn = BitFlipRecoveryFn();
let X0 = ApplyPauli([PauliX, PauliI, PauliI], _);
using (scratch = Qubit[nScratch]) {
    let logicalRegister = encode(data, scratch);
    // Cause an error.
    X0(logicalRegister);
    Recover(code, fn, logicalRegister);
    let (decodedData, decodedScratch) = decode(logicalRegister);
    ApplyToEach(Reset, decodedScratch);
}
```

<span data-ttu-id="11d96-185">Bu, [bit çevirme kod örneğinde](https://github.com/microsoft/Quantum/tree/master/samples/error-correction/bit-flip-code)daha ayrıntılı bir şekilde araştırıyoruz.</span><span class="sxs-lookup"><span data-stu-id="11d96-185">We explore this in more detail in the [bit flip code sample](https://github.com/microsoft/Quantum/tree/master/samples/error-correction/bit-flip-code).</span></span>

<span data-ttu-id="11d96-186">Bit çevirme kodundan başlayarak, Q # Canon, [beş qubit kusursuz kodun](https://arxiv.org/abs/quant-ph/9602019)uygulamalarıyla ve her ikisi de rastgele bir tek qubit hatayı düzeltebilen [yedi-qubit kodu](https://arxiv.org/abs/quant-ph/9705052)ile sağlanır.</span><span class="sxs-lookup"><span data-stu-id="11d96-186">Aside from the bit-flip code, the Q# canon is provided with implementations of the [five-qubit perfect code](https://arxiv.org/abs/quant-ph/9602019), and the [seven-qubit code](https://arxiv.org/abs/quant-ph/9705052), both of which can correct an arbitrary single-qubit error.</span></span>
