---
title: "Q 'da hisse algoritmaları #"
description: Genliği yükseltme, Fourier dönüşümü, Draper ve Beauregard adders ve aşama tahmini dahil olmak üzere temel hisse bilgi işlem algoritmaları hakkında bilgi edinin.
author: QuantumWriter
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.libraries.standard.algorithms
ms.openlocfilehash: aaa9ddf47e5ea35e7e57b9828db082889d0e6adf
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907248"
---
# <a name="quantum-algorithms"></a><span data-ttu-id="01c2d-103">Hisse algoritmaları</span><span class="sxs-lookup"><span data-stu-id="01c2d-103">Quantum Algorithms</span></span> #

## <a name="amplitude-amplification"></a><span data-ttu-id="01c2d-104">Genliğini Yükseltme</span><span class="sxs-lookup"><span data-stu-id="01c2d-104">Amplitude Amplification</span></span> ##

<span data-ttu-id="01c2d-105">*Genliği yükseltme* , hisse bilgi işlem aracının temel araçlarından biridir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-105">*Amplitude Amplification* is one of the fundamental tools of Quantum Computing.</span></span> <span data-ttu-id="01c2d-106">Bu, Grover 'in arama, genlik tahmini ve birçok hisse makine öğrenimi algoritmalarının temelini oluşturan temel bir fikirdir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-106">It is the fundamental idea that underlies Grover's search, amplitude estimation and many quantum machine learning algorithms.</span></span>  <span data-ttu-id="01c2d-107">Birçok çeşit vardır ve soru-cevap bölümünde, uygulamanın en geniş bölümünde izin verilen kısmi yansımalar ile yükümlülüğü düzeyini temel alan genel bir sürüm sağlıyoruz.</span><span class="sxs-lookup"><span data-stu-id="01c2d-107">There are many variants, and in Q# we provide a general version based on Oblivious Amplitude Amplification with Partial Reflections to allow for the widest area of application.</span></span>

<span data-ttu-id="01c2d-108">Genizme 'nin arkasındaki orta düşünce, bir dizi yansıma gerçekleştirerek istenen sonucun oluşma olasılığını artırmakta.</span><span class="sxs-lookup"><span data-stu-id="01c2d-108">The central idea behind amplitude amplification is to amplify the probability of a desired outcome occurring by performing a sequence of reflections.</span></span>  <span data-ttu-id="01c2d-109">Bu yansıtılamalar, ilk durumu, genellikle işaretli bir durum olarak adlandırılan istenen hedef durumuna yaklaştırır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-109">These reflections rotate the initial state closer towards a desired target state, often called a marked state.</span></span>  <span data-ttu-id="01c2d-110">Özellikle, ilk durumu işaretli bir durumda olacak şekilde ölçmeye olasılığı $ \sin ^ 2 (\teta) $ ise, gen$m liği yükseltme işleminden sonra, başarı olasılığı $ \sin ^ 2 ((2m + 1) \teta) $ olur.</span><span class="sxs-lookup"><span data-stu-id="01c2d-110">Specifically, if the probability of measuring the initial state to be in a marked state is $\sin^2(\theta)$ then after applying amplitude amplification $m$ times the probability of success becomes $\sin^2((2m+1)\theta)$.</span></span>  <span data-ttu-id="01c2d-111">Bu, bazı $n $ \teta = \ Pi/[2 (2n + 1)] $ ' in değeri için $ \ teta = \ Pi/[2 (2n + 1)] $ olduğunda, genliği yükseltme $n, genliği yükseltme $100 ' den sonra% $\\% $</span><span class="sxs-lookup"><span data-stu-id="01c2d-111">This means that if $\theta = \pi/[2(2n+1)]$ for some value of $n$ then amplitude amplification is capable of boosting the probability of success to $100\\%$ after $n$ iterations of amplitude amplification.</span></span>  <span data-ttu-id="01c2d-112">$ \Teta = \sin ^{-1}(\sqrt{\Pr (success)}) $ bu yana, başarılı bir şekilde elde etmek için gereken yineleme sayısının rastgele örnekleme kullanılarak belirleyici olmayan bir şekilde bulunması gereken beklenen sayıdan çok daha düşük olması anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-112">Since $\theta = \sin^{-1}(\sqrt{\Pr(success)})$ this means that the number of iterations needed to obtain a success deterministically is quadratically lower than the expected number needed to find a marked state non-deterministically using random sampling.</span></span>

<span data-ttu-id="01c2d-113">Her genden yükseltme yinelemesi iki yansıma işleci belirtilmesini gerektirir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-113">Each iteration of Amplitude amplification requires that two reflection operators be specified.</span></span> <span data-ttu-id="01c2d-114">Özellikle, $Q $, genliği yükseltme yinelecidir ve $P _0 $, başlangıç alt alanına bir projektör operatörü ve $P _1 $, işaretlenen alt alana yönelik projektör, $Q =-(\boldone-2P_0) (\cıvadone-2P_1) $.</span><span class="sxs-lookup"><span data-stu-id="01c2d-114">Specifically, if $Q$ is the amplitude amplification iterate and $P_0$ is a projector operator onto the initial subspace and $P_1$ is the projector onto the marked subspace then $Q=-(\boldone-2P_0)(\boldone -2P_1)$.</span></span>  <span data-ttu-id="01c2d-115">Bir projektörün, egenvalues $ + $1 ve $0 $ olduğunu ve bir sonuç $ (\cıvadone-2P_0) $ olduğunu, Unity 'nin köklerinin kökleri olan (Bu durumda, $ \pm $1) bir hermitian işleci olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="01c2d-115">Recall that a projector is a Hermitian operator that has eigenvalues $+1$ and $0$ and as a result $(\boldone -2P_0)$ is unitary because it has eigenvalues that are roots of unity (in this case $\pm 1$).</span></span> <span data-ttu-id="01c2d-116">Örnek olarak, Grover 'in ilk durumuyla arama durumunu göz önünde bulundurun $H ^ {\otimes n} \tus{0}$ ve işaretli durum $ \ket{m} $, $P _0 = H ^ {\otimes n} \tus{0}\bra{0}H ^ {\otimes n} $ ve $P _1 = \ket{m}\bra{m} $.</span><span class="sxs-lookup"><span data-stu-id="01c2d-116">As an example, consider the case of Grover's search with initial state $H^{\otimes n} \ket{0}$ and marked state $\ket{m}$, $P_0 = H^{\otimes n}\ket{0}\bra{0}H^{\otimes n}$ and $P_1= \ket{m}\bra{m}$.</span></span>  <span data-ttu-id="01c2d-117">Çoğu genden yükseltme $P _0 $ uygulamalarında bir projektör, bazı vektör $ \ket{\psı} $; için $P _0 = \cıvadone-2 \ hayvan {\ PSI} \ köşeli {\ PSI} $ öğesinin bir başlangıç durumuna göre bir projektör olacaktır. Ancak, $P _0 $ olan zorunluluğun genliği, genellikle birçok hisse adına proje olur (yani, $ + $1 eigenvalue of $P _0 $ 'ın çoğulluğu $1 $ ' den büyüktür).</span><span class="sxs-lookup"><span data-stu-id="01c2d-117">In most applications of amplitude amplification $P_0$ will be a projector onto an initial state meaning that $P_0 = \boldone -2\ket{\psi}\bra{\psi}$ for some vector $\ket{\psi}$; however, for oblivious amplitude amplication $P_0$ will typically project onto many quantum states (i.e. the multiplicity of the $+1$ eigenvalue of $P_0$ is greater than $1$).</span></span>

<span data-ttu-id="01c2d-118">Genleştirme 'nın arkasındaki mantık, $Q $ ' ın Eigen ayrıştırma işleminden hemen sonra takip eder.</span><span class="sxs-lookup"><span data-stu-id="01c2d-118">The logic behind amplitude amplification follows directly from the eigen-decomposition of $Q$.</span></span>  <span data-ttu-id="01c2d-119">Özellikle, $Q $ ' ın eigenvektörler ilk durumun üzerinde sıfır olmayan desteği olduğunu, $P _0 $ ve $P _1 $ $ + $1 eigenvektörlerinin doğrusal bileşimleri olarak gösterilebiliyor.</span><span class="sxs-lookup"><span data-stu-id="01c2d-119">Specifically, the eigenvectors of $Q$ that the initial state has non-zero support over can be shown to be linear combinations of the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="01c2d-120">Özellikle, genliği yükseltme için başlangıç durumu (bir $ + $1 eigenvector $P _0 $), $ $ \ket{\psı} = \frac{-olarak yazılabilir ı}{\sqrt{2}} \left (e ^ {i\teta} \ ayraç {\ psi_ +} + e ^ {-i\teta} \ ayraç {\ psi_-} \ right), $ $ burada $ \ket{\ psi_ \pm} $, $Q $ öğesinin eigenvalues $e ^ {\pm 2i \ teta} $ olduğunu ve yalnızca $P _0 $ ve $P _1 $ ' nin $ + $1 eigenvektörlerine yönelik destek sahibi olduğunu.</span><span class="sxs-lookup"><span data-stu-id="01c2d-120">Specifically, the initial state for amplitude amplification (assuming it is a $+1$ eigenvector of $P_0$) can be written as $$ \ket{\psi}=\frac{-i}{\sqrt{2}}\left(e^{i\theta}\ket{\psi_+} + e^{-i\theta}\ket{\psi_-}\right), $$ where $\ket{\psi_\pm}$ are eigenvectors of $Q$ with eigenvalues $e^{\pm  2i\theta}$ and only have support on the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="01c2d-121">Eigenvalues $e ^ {\pm i \theta} $, $Q $ işlecinin iki projektör tarafından belirtilen iki boyutlu bir alt alanda bir döndürme ve döndürme açısının $2 \ teta $ olduğu ilk durum üzerinde bir döndürme gerçekleştirmesini anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-121">The fact that the eigenvalues are $e^{\pm i \theta}$ implies that the operator $Q$ performs a rotation in a two-dimensional subspace specified by the two projectors and the initial state where the rotation angle is $2\theta$.</span></span>  <span data-ttu-id="01c2d-122">Bu neden, $Q $ $m $ yinelemelerinin $ \sin ^ 2 ([2m + 1] \teta) $ ' dır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-122">This is why after $m$ iterations of $Q$ the success probability is $\sin^2([2m+1]\theta)$.</span></span>

<span data-ttu-id="01c2d-123">Bundan sonra gelen diğer yararlı bir özellik ise, eigenvalue $ \teta $, ilk durumun işaretleneceği olasılığa ($P _0 $ ' ın yalnızca ilk duruma kadar bir projektör olduğu durumlarda) doğrudan ilgilidir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-123">Another useful property that comes out of this is that the eigenvalue $\theta$ is directly related to probability that the initial state would be marked (in the case where $P_0$ is a projector onto only the initial state).</span></span>  <span data-ttu-id="01c2d-124">$Q $ ' nin eigenaşamaları $2 \ teta = 2 \ sin ^{-1}(\sqrt{\Pr (success)}) $ olduğundan, $Q $ öğesine aşama tahmini uyguladığımızda, bir Unitary yordamı için başarılı olma olasılığını öğreniyoruz.</span><span class="sxs-lookup"><span data-stu-id="01c2d-124">Since the eigenphases of $Q$ are $2\theta = 2\sin^{-1}(\sqrt{\Pr(success)})$ it then follows that if we apply phase estimation to $Q$ then we can learn the probability of success for a unitary quantum procedure.</span></span>  <span data-ttu-id="01c2d-125">Bu, daha az bir şekilde ihtiyaç duyulduğundan daha fazla bilgi edinmek için hisse prosedürü için en fazla sayıda daha az uygulama gerektirdiğinden yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-125">This is useful because it requires quadratically fewer applications of the quantum procedure to learn the success probability than would otherwise be needed.</span></span>

<span data-ttu-id="01c2d-126">S #, yükümlülüğü düzeyini en uygun özelleşmenin bir özelleştirmesi olarak sunar.</span><span class="sxs-lookup"><span data-stu-id="01c2d-126">Q# introduces amplitude amplification as a specialization of oblivious amplitude amplification.</span></span>  <span data-ttu-id="01c2d-127">Yükümlülüğü, ilk egenliği olan Projektörün başlangıç durumuna bir projektör olmaması gerektiğinden, bu bilinen adı ortadan kaldırmaz.</span><span class="sxs-lookup"><span data-stu-id="01c2d-127">Oblivious amplitude amplification earns this moniker because the projector onto the initial eigenspace need not be a projector onto the initial state.</span></span>  <span data-ttu-id="01c2d-128">Bu anlamda protokol, ilk duruma kadar zorunluluvou olur.</span><span class="sxs-lookup"><span data-stu-id="01c2d-128">In this sense, the protocol is oblivious to the initial state.</span></span>  <span data-ttu-id="01c2d-129">Yükümlülüğü nesnelerin anahtar uygulaması, ilk durumun bilinmediği, ancak simülasyon protokolünde bir anliksel kayıt ile ayrılmış hale geldiği Unitary Hamiltonian benzetim yöntemlerinin belirli *Doğrusal birleşimleridir* .</span><span class="sxs-lookup"><span data-stu-id="01c2d-129">The key application of oblivious amplitude amplification is in certain *linear combinations of unitary* Hamiltonian simulation methods, wherein the initial state is unknown but becomes entangled with an ancilla register in the simulation protocol.</span></span>  <span data-ttu-id="01c2d-130">Bu anyater kaydı sabit bir değer olacak şekilde ölçüldüğünde, $0 $ deyin, bu tür benzetim yöntemleri, kalan qubits 'e istenen Unitary dönüşümünü uygular (sistem kaydı adı verilir).</span><span class="sxs-lookup"><span data-stu-id="01c2d-130">If this ancilla register were to be measured to be a fixed value, say $0$, then such simulation methods apply the desired unitary transformation to the remaining qubits (called the system register).</span></span>  <span data-ttu-id="01c2d-131">Diğer tüm ölçüm sonuçları hataya yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-131">All other measurement outcomes lead to failure however.</span></span>  <span data-ttu-id="01c2d-132">Yükümlülüğü en çok genliği, bu ölçümün başarısı $100\\% $, yukarıdaki düşünmelerin kullanılması olasılığını artırır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-132">Oblivious amplitude amplification allows the probability of success of this measurement to be boosted to $100\\%$ using the above reasoning.</span></span>  <span data-ttu-id="01c2d-133">Ayrıca, normal genileri, sistem kaydının boş olduğu durumuna karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-133">Further, ordinary amplitude amplification corresponds to the case where the system register is empty.</span></span>  <span data-ttu-id="01c2d-134">Bu nedenle, soru-cevap, temel genliği yükseltme alt yordamı olarak yükümlülüğü en çok genliğini kullanır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-134">This is why Q# uses oblivious amplitude amplification as its fundamental amplitude amplification subroutine.</span></span>

<span data-ttu-id="01c2d-135">Genel yordamın (`AmpAmpObliviousByReflectionPhases`) `ancillaRegister` ve `systemRegister`çağırdığımız iki kaydı vardır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-135">The general routine (`AmpAmpObliviousByReflectionPhases`) has two registers that we call `ancillaRegister` and `systemRegister`.</span></span> <span data-ttu-id="01c2d-136">Ayrıca, gerekli yansıtımları için iki Oracles kabul eder.</span><span class="sxs-lookup"><span data-stu-id="01c2d-136">It also accepts two oracles for the necessary reflections.</span></span> <span data-ttu-id="01c2d-137">`ReflectionOracle`, `ObliviousOracle` her iki kasada de ortaklaşa hareket ederken `ancillaRegister` üzerinde çalışır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-137">The `ReflectionOracle` acts only on the `ancillaRegister` while the `ObliviousOracle` acts jointly on both registers.</span></span> <span data-ttu-id="01c2d-138">`ancillaRegister` giriş, $ \ cıvadone-2P_1 $ ilk yansıma işlecinin-1 eigenstate 'e başlatılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-138">The input to `ancillaRegister` must be initialized to a -1 eigenstate of the first reflection operator $\boldone -2P_1$.</span></span>

<span data-ttu-id="01c2d-139">Genellikle, Oracle durumu hesaplama tabanlı $ \ket{0...0} $ olarak hazırlar.</span><span class="sxs-lookup"><span data-stu-id="01c2d-139">Typically, the oracle prepares the state in the computational basis $\ket{0...0}$.</span></span> <span data-ttu-id="01c2d-140">Uygulamamızda bir qubit (`flagQubit`) `ancillaRegister` consistes, bu da `stateOracle` ve istenen anyamarın geri kalanını denetler.</span><span class="sxs-lookup"><span data-stu-id="01c2d-140">In our implementation, the `ancillaRegister` consistes of one qubit (`flagQubit`) that controls the `stateOracle` and the rest of the desired ancillas.</span></span> <span data-ttu-id="01c2d-141">`stateOracle`, `flagQubit` $ \ket{1}$ olduğunda uygulanır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-141">The `stateOracle` is applied when the `flagQubit` is $\ket{1}$.</span></span>

<span data-ttu-id="01c2d-142">Ayrıca, bir `AmpAmpObliviousByOraclePhases`çağrısı aracılığıyla yansıma yerine Oracles `StateOracle` ve `ObliviousOracle` da sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-142">One may also provide oracles `StateOracle` and `ObliviousOracle` instead of reflections via a call to `AmpAmpObliviousByOraclePhases`.</span></span>

<span data-ttu-id="01c2d-143">Belirtildiği gibi, geleneksel Genleştirmeler, `ObliviousOracle` kimlik operatörü olduğu ve sistem qubit (yani, `systemRegister` boş) olmadığı bu yordamların yalnızca özel bir durumdur.</span><span class="sxs-lookup"><span data-stu-id="01c2d-143">As mentioned, traditional Amplitude Amplification is just a special case of these routines where `ObliviousOracle` is the identity operator and there are no system qubits (i.e., `systemRegister` is empty).</span></span> <span data-ttu-id="01c2d-144">Kısmi yansıtımları için aşamalar almak istiyorsanız (örneğin, Grover araması için) `AmpAmpPhasesStandard` işlevi kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-144">If you wish to obtain phases for partial reflections (e.g., for Grover search), the function `AmpAmpPhasesStandard` is available.</span></span> <span data-ttu-id="01c2d-145">Lütfen Grover 'in algoritmasının örnek bir uygulamasına yönelik `DatabaseSearch.qs` başvurun.</span><span class="sxs-lookup"><span data-stu-id="01c2d-145">Please refer to `DatabaseSearch.qs` for a sample implementation of Grover's algorithm.</span></span>

<span data-ttu-id="01c2d-146">Tek qubit döndürme aşamalarını, kağıt [G.H. Low, ı. L. Chuang](https://arxiv.org/abs/1707.05391)tarafından belirtilen şekilde, yansıma işleci aşamalarına ilişkilendirdik.</span><span class="sxs-lookup"><span data-stu-id="01c2d-146">We relate the single-qubit rotation phases to the reflection operator phases as described in the paper by [G.H. Low, I. L. Chuang](https://arxiv.org/abs/1707.05391).</span></span> <span data-ttu-id="01c2d-147">Kullanılan sabit nokta aşamaları, düşük [, Yoder ve Chuang](https://arxiv.org/abs/1603.03996)aşamalarıyla birlikte [Yoder, Low ve Chuang](https://arxiv.org/abs/1409.3305) içinde ayrıntılıdır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-147">The fixed point phases that are used are detailed in [Yoder, Low and Chuang](https://arxiv.org/abs/1409.3305) along with the phases in [Low, Yoder and Chuang](https://arxiv.org/abs/1603.03996).</span></span>

<span data-ttu-id="01c2d-148">Arka plan için [Standart genliği](https://arxiv.org/abs/quant-ph/0005055) yükseltme ' den başlayıp, [düşük ve Chuang](https://arxiv.org/abs/1610.06546)' de [sunulan ve en](https://arxiv.org/abs/1312.1414) son genelleştirmeler için bir giriş konusuna geçebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="01c2d-148">For background, you could start from [Standard Amplitude Amplification](https://arxiv.org/abs/quant-ph/0005055) then move to an introduction to [Oblivious Amplitude Amplification](https://arxiv.org/abs/1312.1414) and finally generalizations presented in [Low and Chuang](https://arxiv.org/abs/1610.06546).</span></span> <span data-ttu-id="01c2d-149">Bu alanın tamamını (Hamiltonian simülasyonu ile ilişkili olduğu gibi), [Dominic Braz](http://www.dominicberry.org/presentations/Durban.pdf)tarafından verilen bir genel bakış sunumu.</span><span class="sxs-lookup"><span data-stu-id="01c2d-149">A nice overview presentation of this entire area (as it relates to Hamiltonian Simulation) was given by [Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf).</span></span>

## <a name="quantum-fourier-transform"></a><span data-ttu-id="01c2d-150">Hisse Fourier dönüşümü</span><span class="sxs-lookup"><span data-stu-id="01c2d-150">Quantum Fourier Transform</span></span> ##

<span data-ttu-id="01c2d-151">Fourier Transform, klasik çözümlemenin temel bir aracıdır ve yalnızca hisse hesaplamalarında önemli bir araçtır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-151">The Fourier transform is a fundamental tool of classical analysis and is just as important for quantum computations.</span></span>
<span data-ttu-id="01c2d-152">Buna ek olarak, *hisse* uygun bir şekilde bir hisse algoritması tasarımı yaparken, her ne kadar, bir klasik makinede ne kadar verimli hale gelir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-152">In addition, the efficiency of the *quantum Fourier transform* (QFT) far surpasses what is possible on a classical machine making it one of the first tools of choice when designing a quantum algorithm.</span></span>

<span data-ttu-id="01c2d-153">QFT 'nin yaklaşık bir genelleştiri olarak, istenen algoritmik doğruluğu için kesinlikle gerekli olmayan döndürmeler ayıklanarak daha iyi iyileştirmeler sağlayan <xref:microsoft.quantum.canon.approximateqft> işlem sağlıyoruz.</span><span class="sxs-lookup"><span data-stu-id="01c2d-153">As an approximate generalization of the QFT, we provide the <xref:microsoft.quantum.canon.approximateqft> operation that allows for further optimizations by pruning rotations that aren't strictly necessary for the desired algorithmic accuracy.</span></span>
<span data-ttu-id="01c2d-154">Yaklaşık QFT, dyadic $Z $-döndürme <xref:microsoft.quantum.intrinsic.rfrac> işleminin yanı sıra <xref:microsoft.quantum.intrinsic.h> işlemini de gerektirir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-154">The approximate QFT requires the dyadic $Z$-rotation operation <xref:microsoft.quantum.intrinsic.rfrac> as well as the <xref:microsoft.quantum.intrinsic.h> operation.</span></span>
<span data-ttu-id="01c2d-155">Giriş ve çıkışın big endian kodlamada kodlandığını kabul edilir---yani Dizin `0` ile qubit, ikili tamsayı gösteriminin en solundaki (en yüksek) bit olarak kodlanır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-155">The input and output are assumed to be encoded in big endian encoding---that is, the qubit with index `0` is encoded in the left-most (highest) bit of the binary integer representation.</span></span>
<span data-ttu-id="01c2d-156">Bu, [ayraç](xref:microsoft.quantum.concepts.dirac)ile hizalanır. $ \demet{100}$, $ \tus{1}$q $ durumunda olan $q _0 $ durumunda olduğu ve $q _2 $ durumunun $ \tus{0}$ durumunda olduğu anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-156">This aligns with [ket notation](xref:microsoft.quantum.concepts.dirac), as a register of three qubits in the state $\ket{100}$ corresponds to $q_0$ being in the state $\ket{1}$ while $q_1$ and $q_2$ are both in state $\ket{0}$.</span></span>
<span data-ttu-id="01c2d-157">$A $ yaklaşık parametresi, $Z $-döndürmeler, yani $a \içindeki [0.. n] $) ayıklama düzeyini belirler.</span><span class="sxs-lookup"><span data-stu-id="01c2d-157">The approximation parameter $a$ determines the pruning level of the $Z$-rotations, i.e., $a \in [0..n]$.</span></span>
<span data-ttu-id="01c2d-158">Bu durumda, tüm $Z $-Ros $2 \ pi/2 ^ k $, $k > bir $, QFT devresi öğesinden kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-158">In this case all $Z$-rotations $2\pi/2^k$ where $k > a$ are removed from the QFT circuit.</span></span>
<span data-ttu-id="01c2d-159">$K \ge \ log_2 (n) + \ log_2 (1/\epsilon) + $3 için şu şekilde bilinmektedir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-159">It is known that for $k \ge \log_2(n) + \log_2(1 / \epsilon) + 3$.</span></span> <span data-ttu-id="01c2d-160">biri $\\bağlanabilir | \operatorname{QFT}-\operatorname{AQFT} \\| < \epsilon $.</span><span class="sxs-lookup"><span data-stu-id="01c2d-160">one can bound $\\| \operatorname{QFT} - \operatorname{AQFT} \\| < \epsilon$.</span></span>
<span data-ttu-id="01c2d-161">Burada $\\| \cdot\\| $, bu örnekte $ (\operatorname{QFT}-\operatorname{AQFT}) (\operatorname{QFT}-\operatorname{AQFT}) ^ \hanger $ en büyük [eigenvalue değerinin](xref:microsoft.quantum.concepts.matrix-advanced) karekökünü temel aldığı işleçtir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-161">Here $\\|\cdot\\|$ is the operator norm which in this case is the square root of the largest [eigenvalue](xref:microsoft.quantum.concepts.matrix-advanced) of $(\operatorname{QFT} - \operatorname{AQFT})(\operatorname{QFT} - \operatorname{AQFT})^\dagger$.</span></span>

## <a name="arithmetic"></a><span data-ttu-id="01c2d-162">Aritmetik</span><span class="sxs-lookup"><span data-stu-id="01c2d-162">Arithmetic</span></span> ##

<span data-ttu-id="01c2d-163">Aritmetik olarak klasik bilgi işlem 'da merkezi bir rol oynadığında, bu da hisse olmazdır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-163">Just as arithmetic plays a central role in classical computing, it is also indispensable in quantum computing.</span></span>  <span data-ttu-id="01c2d-164">Shor 'ın düzenleme algoritması, hisse simülasyonu yöntemleri ve birçok Oracular algoritması gibi algoritmalar, tutarlı aritmetik işlemlere dayanır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-164">Algorithms such as Shor's factoring algorithm, quantum simulation methods as well as many oracular algorithms rely upon coherent arithmetic operations.</span></span>  <span data-ttu-id="01c2d-165">En çok bir aritmetik derleme, hisse açık bir devreden sonra.</span><span class="sxs-lookup"><span data-stu-id="01c2d-165">Most approaches to arithmetic build upon quantum adder circuits.</span></span>  <span data-ttu-id="01c2d-166">En basit ekleyici, klasik bir giriş $b $ alır ve değeri $ \ket{a} $ tamsayı tutan bir hisse ma durumuna ekler.</span><span class="sxs-lookup"><span data-stu-id="01c2d-166">The simplest adder takes a classical input $b$ and adds the value to a quantum state holding an integer $\ket{a}$.</span></span>  <span data-ttu-id="01c2d-167">Matematiksel olarak, bir Ekleyici (klasik giriş $b $ için $ \operatorname{Add} (b) $) değerini belirten bir özelliği vardır</span><span class="sxs-lookup"><span data-stu-id="01c2d-167">Mathematically, the adder (which we denote $\operatorname{Add}(b)$ for classical input $b$) has the property that</span></span>

<span data-ttu-id="01c2d-168">$ $ \operatorname{Add} (b) \ket{a} = \ket{a + b}.</span><span class="sxs-lookup"><span data-stu-id="01c2d-168">$$ \operatorname{Add}(b)\ket{a}=\ket{a + b}.</span></span>
<span data-ttu-id="01c2d-169">$ $ Bu temel Ekleyici devresi bir Ekleyici öğesinden daha fazla incrementer.</span><span class="sxs-lookup"><span data-stu-id="01c2d-169">$$ This basic adder circuit is more of an incrementer than an adder.</span></span>
<span data-ttu-id="01c2d-170">$ $ \Operatorname{Add}\ket{a}\ket{b} = \ket{a}\ket{a + b} aracılığıyla iki hisse girişi olan bir Ekleyici 'a dönüştürülebilir. $ $ \begin{hizalaması} \operatorname{Add} \ket{a} \ket{b} & = $n \lambda\_{a\_0} \left (\operatorname{Add} (1) \ right) \lambda\_{a\_1} \left (\operatorname{Add} (2) \right) \lambda\_{a\_2} \left (\operatorname{Add} (4) \right) \cnoktalar \lambda\_{a\_{n-1}} \left (\ operatorname {Add} ({{n-1}}) \right) \ket{a}\ket{b} \\\\ & = \ket{a} \ket{b + a}, \end{hizalaması} $n $-bit tamsayılar $a $ ve $b $ ve ek modül $2 ^ n $.</span><span class="sxs-lookup"><span data-stu-id="01c2d-170">It can be converted into an adder that has two quantum inputs via $$ \operatorname{Add}\ket{a}\ket{b}=\ket{a}\ket{a+b}, $$ using $n$ controlled applications of adders of the form \begin{align} \operatorname{Add} \ket{a} \ket{b} & = \Lambda\_{a\_0} \left(\operatorname{Add}(1) \right) \Lambda\_{a\_1} \left(\operatorname{Add}(2) \right) \Lambda\_{a\_2} \left(\operatorname{Add}(4) \right) \cdots \Lambda\_{a\_{n-1}} \left(\operatorname{Add}({{n-1}}) \right) \ket{a}\ket{b} \\\\ & = \ket{a} \ket{b + a}, \end{align} for $n$-bit integers $a$ and $b$ and addition modulo $2^n$.</span></span>  <span data-ttu-id="01c2d-171">$ \Lambda\_x (A) $ öğesinin her türlü işlemi için $A $, qubit $x $ as denetimi ile bu işlemin denetlenen sürümüne olduğunu hatırlayın.</span><span class="sxs-lookup"><span data-stu-id="01c2d-171">Recall that the notation $\Lambda\_x(A)$ refers, for any operation $A$, to the controlled version of that operation with the qubit $x$ as control.</span></span>

<span data-ttu-id="01c2d-172">Benzer şekilde, parçalı olarak denetlenen çarpma (Shor 'ın düzenleme algoritması için temel olan modüler bir biçim), benzer bir denetimli ekleme dizisi kullanılarak gerçekleştirilebilir: \begin{hizalaması} \operatorname{Mult} (a) \ket{x}\ket{b} & = \Lambda\_{x\_0} \left (\operatorname{Add} (2 ^ 0 a) \ right) \ lambda\_{a\_1} \left (\operatorname{Add} (2 ^ 1a) \right) \Lambda\_{a\_2} \left (\operatorname{Add} (2 ^ 2 a) \ right) \cnoktalar \Lambda\_{x\_{ n-1}} \left (\operatorname{Add} ({2 ^ {n-1}} a) \ right) \ket{x}\ket{b} \\\\ & = \ket{x}\ket{b + AX}.</span><span class="sxs-lookup"><span data-stu-id="01c2d-172">Similarly, classically controlled multiplication (a modular form of which is essential for Shor's factoring algorithm) can be performed by using a similar series of controlled  additions: \begin{align} \operatorname{Mult}(a)\ket{x}\ket{b} & = \Lambda\_{x\_0}\left(\operatorname{Add}(2^0 a)\right) \Lambda\_{a\_1}\left(\operatorname{Add}(2^1a)\right) \Lambda\_{a\_2}\left(\operatorname{Add}(2^2 a)\right) \cdots \Lambda\_{x\_{n-1}} \left(\operatorname{Add}({2^{n-1}}a) \right)\ket{x}\ket{b} \\\\ & = \ket{x}\ket{b+ax}.</span></span>
<span data-ttu-id="01c2d-173">\end{hizalaması} yukarıdaki $ \operatorname{Mult} $ tanımından fark edebilmeniz gereken, hisse alınan çarpma ile bir alt ttize vardır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-173">\end{align} There is a subtlety with multiplication on quantum computers that you may notice from the definition of $\operatorname{Mult}$ above.</span></span>  <span data-ttu-id="01c2d-174">Buna ek olarak, bu devrenin hisse sürümü, giriş kaydı yerine bir anakusli kayıt halinde girişlerin çarpımını depolar.</span><span class="sxs-lookup"><span data-stu-id="01c2d-174">Unlike addition, the quantum version of this circuit stores the product of the inputs in an ancillary register rather than in the input register.</span></span>  <span data-ttu-id="01c2d-175">Bu örnekte, YAZMAÇ $b $ değeriyle başlatılır, ancak genellikle sıfır değerini tutmaya başlayacaktır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-175">In this example, the register is initialized with the value $b$, but typically it will start holding the value zero.</span></span>  <span data-ttu-id="01c2d-176">Bu, genel $a $ ve $x $ için bir çarpma tersi olmadığından ' de gereklidir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-176">This is needed in because in general there is not a multiplicative inverse for general $a$ and $x$.</span></span>  <span data-ttu-id="01c2d-177">Tüm hisse işlemleri, ölçümü Kaydet, geri alınamaz ve çarpmadan ters çevirmek için yeterli bilgi tutmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-177">Since all quantum operations, save measurement, are reversible we need to keep enough information around to invert the multiplication.</span></span>  <span data-ttu-id="01c2d-178">Bu nedenle, sonuç ayrı bir dizide depolanır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-178">For this reason the result is stored in a separate array.</span></span>  <span data-ttu-id="01c2d-179">Ayrı bir kayıttaki çarpma gibi geri alınamaz bir işlemin çıkışını kaydetmenin bu eli, Charlie Bennett sonrasında "Bennett eli" olarak bilinir ve hem ters çevrilebilir hem de hisse bilgi işlem ortamında temel bir araçtır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-179">This trick of saving the output of an irreversible operation, like multiplication, in a separate register is known as the "Bennett trick" after Charlie Bennett and is a fundamental tool in both reversible and quantum computing.</span></span>

<span data-ttu-id="01c2d-180">Çok sayıda hisse kullanım için önerilir ve her biri, qubit sayısı (Space) ve gereken kapı işlemleri sayısı (süre) açısından farklı bir zorunluluğunu getirir araştırır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-180">Many quantum circuits have been proposed for addition and each explores a different tradeoff in terms of the number of qubits (space) and the number of gate operations (time) required.</span></span>  <span data-ttu-id="01c2d-181">Aşağıda, Draper Ekleyici ve Beauregard Ekleyici olarak bilinen iki son derece etkin ad inceliyoruz.</span><span class="sxs-lookup"><span data-stu-id="01c2d-181">We review two highly space efficient adders below known as the Draper adder and the Beauregard adder.</span></span>

### <a name="draper-adder"></a><span data-ttu-id="01c2d-182">Draper Adder</span><span class="sxs-lookup"><span data-stu-id="01c2d-182">Draper Adder</span></span> ###

<span data-ttu-id="01c2d-183">Draper Ekleyici en zarif bir şekilde, ek hale getirmek üzere hisse özelliklerini doğrudan çağırdığı için en zarif hisse alıclardan biridir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-183">The Draper adder is arguably one of the most elegant quantum adders, as it directly invokes quantum properties to perform addition.</span></span>  <span data-ttu-id="01c2d-184">Draper 'ın arkasındaki Öngörüler, Fourier dönüştürmesinin, aşama vardiyalarının bir bit vardiyaya çevrilmesi için kullanılabileceğini sağlar.</span><span class="sxs-lookup"><span data-stu-id="01c2d-184">The insight behind the Draper adder is that the Fourier transform can be used to translate phase shifts into a bit shift.</span></span>  <span data-ttu-id="01c2d-185">Daha sonra bir Fourier dönüşümü uygulayarak, uygun aşama vardiyaları uygulayarak ve sonra bir Adder uygulayabileceğiniz Fourier dönüşümünü geri aldıktan sonra bunu izler.</span><span class="sxs-lookup"><span data-stu-id="01c2d-185">It then follows that by applying a Fourier transform, applying appropriate phase shifts, and then undoing the Fourier transform you can implement an adder.</span></span>  <span data-ttu-id="01c2d-186">Önerilmiş pek çok diğer adtan farklı olarak, Draper ekleyici, hisse bir biçimde sunulan hisse</span><span class="sxs-lookup"><span data-stu-id="01c2d-186">Unlike many other adders that have been proposed, the Draper adder explicitly uses quantum effects introduced through the quantum Fourier transform.</span></span>  <span data-ttu-id="01c2d-187">Doğal bir klasik karşılığı yok.</span><span class="sxs-lookup"><span data-stu-id="01c2d-187">It does not have a natural classical counterpart.</span></span>  <span data-ttu-id="01c2d-188">Draper Ekleyici 'ın belirli adımları aşağıda verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-188">The specific steps of the Draper adder are given below.</span></span>

<span data-ttu-id="01c2d-189">İki $n $-bit qubit, $a $ ve $b $ değerlerinin tümünü $a $ $ $ $ $ $ $ $ $ \operatorname{QFT}\ket{a} = \frac{1}{\sqrt{2 ^ n}} \sum\_{j = 0} ^ {2 ^ n-1} e ^ {i2\pi (AIJ)</span><span class="sxs-lookup"><span data-stu-id="01c2d-189">Assume that you have two $n$-bit qubit registers storing the integers $a$ and $b$ then for all $a$ $$ \operatorname{QFT}\ket{a}= \frac{1}{\sqrt{2^n}}\sum\_{j=0}^{2^n-1} e^{i2\pi(aj)/2^n} \ket{j}.</span></span>
<span data-ttu-id="01c2d-190">$ $ $ $ \Ket{\phi\_k (a)} = \frac{1}{\sqrt{2}} \left (\ket{0} + e ^ {i2\pi a/2 ^ k} \tus{1} \ right) tanımladığımızda, $ $ daha sonra bazı algeköşeli sonrasında $ $ \operatorname{QFT}\ket{a} = \ket{\phi\_1 (a)} \otimes \cnoktalar \otimes \ket{\phi\_n (a)} olduğunu görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="01c2d-190">$$ If we define $$ \ket{\phi\_k(a)} = \frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi a /2^k}\ket{1} \right), $$ then after some algebra you can see that $$ \operatorname{QFT}\ket{a}=\ket{\phi\_1(a)}\otimes \cdots \otimes \ket{\phi\_n(a)}.</span></span>
<span data-ttu-id="01c2d-191">$ $ Bir Ekleyici işlemi gerçekleştirmeye yönelik yol daha sonra, girişlerin toplamının $ $ \ket{a + b} = \operatorname{QFT} ^{-1}\ket{\fi\_1 (a + b)} \otimes \cnoktalar \otimes \ket{\phi\_n (a + b)} olarak yazılabileceğini gözlemledikten sonra net bir hale gelir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-191">$$ The path towards performing an adder then becomes clear after observing that the sum of the inputs can be written as $$ \ket{a+b}=\operatorname{QFT}^{-1}\ket{\phi\_1(a+b)}\otimes \cdots \otimes \ket{\phi\_n(a+b)}.</span></span>
<span data-ttu-id="01c2d-192">$ $ $B $ ve $a $ tamsayısı, $b $ $ as denetimleri kullanılarak ayrıştırma içindeki her bir qubit üzerinde denetlenen aşama dönüşü gerçekleştirerek eklenebilir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-192">$$ The integers $b$ and $a$ can then be added by performing controlled-phase rotation on each of the qubits in the decomposition using the bits of $b$ as controls.</span></span>

<span data-ttu-id="01c2d-193">Bu genişleme, her tamsayı $j $ ve gerçek sayı $x $, $e ^ {i2\pi (x + j)} = e ^ {i2\pi x} $ olduğunu belirterek daha kolay bir şekilde basitleştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-193">This expansion can be further simplified by noting that for any integer $j$ and real number $x$, $e^{i2\pi(x+j)}=e^{i2\pi x}$.</span></span>  <span data-ttu-id="01c2d-194">Bunun nedeni, $360 ^ {\circ} $ derece ($ 2 \ Pi $ radyan) bir daire içinde döndürmenize neden olur.</span><span class="sxs-lookup"><span data-stu-id="01c2d-194">This is because if you rotate $360^{\circ}$ degrees ($2\pi$ radians) in a circle then you end up precisely where you started.</span></span>  <span data-ttu-id="01c2d-195">$E ^ {i2\pi x} $ için $x $ öğesinin yalnızca önemli bir parçası bu nedenle $x $ bölümünün kesirli kısmıdır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-195">The only important part of $x$ for $e^{i2\pi x}$ is therefore the fractional part of $x$.</span></span>  <span data-ttu-id="01c2d-196">Özellikle, formun ikili genişletmemiz varsa $x = y +0. x\_0x\_2 \ lnoktalar x\_n $, $e ^ {i2\pi x} = e ^ {i2\pi (0). x\_0x\_2 \ lnoktalar x\_{n-1})} $ ve bu nedenle $ $ \ket{\phi\_k (a + b)} = \frac{1}{\sqrt{2}} \left (\demet{0} + e ^ {i2\pi [a/2 ^ k +0. b\_k\ldots b\_1]} \ayraç{1} \right). $ $ Bu, her birinin $ \ket{a} $ öğesinin Fourier dönüştürmesinin genişletilmesinde tencursor faktörleri, döndürmeler sayısı $k $ düşüş olarak küçülür.</span><span class="sxs-lookup"><span data-stu-id="01c2d-196">Specifically, if we have a binary expansion of the form $x=y+0.x\_0x\_2\ldots x\_n$ then $e^{i2\pi x}=e^{i2\pi (0.x\_0x\_2\ldots x\_{n-1})}$ and hence $$\ket{\phi\_k(a+b)}=\frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi [a/2^k+0.b\_k\ldots b\_1]}\ket{1} \right).$$ This means that if we perform addition by incrementing each of the tensor factors in the expansion of the Fourier transform of $\ket{a}$ then the number of rotations shrinks as $k$ decreases.</span></span>  <span data-ttu-id="01c2d-197">Bu, Adder 'de gerekli olan hisse kapıları sayısını önemli ölçüde azaltır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-197">This substantially reduces the number of quantum gates needed in the adder.</span></span>  <span data-ttu-id="01c2d-198">Fourier dönüşümü, aşama ekleme ve ters Fourier Dönüştürme adımlarının $ \operatorname{QFT} ^{-1} \left (\fi\\\!\operatorname{ADD}\right) \operatorname{QFT} $ olarak olduğunu belirledik.</span><span class="sxs-lookup"><span data-stu-id="01c2d-198">We denote the Fourier transform, phase addition and the inverse Fourier transform steps that comprise the Draper adder as $\operatorname{QFT}^{-1} \left(\phi\\\!\operatorname{ADD}\right) \operatorname{QFT}$.</span></span> <span data-ttu-id="01c2d-199">İşlemin tamamını uygulamak için bu basitleştirme kullanan bir hisse devresini aşağıda görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="01c2d-199">A quantum circuit that uses this simplification to implement the entire process can be seen below.</span></span>

![Devper, devre diyagramı olarak gösterilen Ekleyici](~/media/draper.png)

<span data-ttu-id="01c2d-201">Bağlantı hattı 'ndaki her denetlenen $e ^ {I2 \ PI/k} $ kapısı, denetlenen aşama kapısı anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-201">Each controlled $e^{i2\pi/k}$ gate in the circuit refers to a controlled-phase gate.</span></span>  <span data-ttu-id="01c2d-202">Bu tür kapıları, $ \gre{00}\mapsto \tus{00}$ ancak $ \gre{11}\mapsto e ^ {I2 \ PI/k} \ tus{11}$ olan qubit çiftinde özelliği vardır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-202">Such gates have the property that on the pair of qubits on which they act, $\ket{00}\mapsto \ket{00}$ but $\ket{11}\mapsto e^{i2\pi/k}\ket{11}$.</span></span>  <span data-ttu-id="01c2d-203">Bu bağlantı hattı, giriş ve çıkışları depolamak için gerekenden başka bir qubit olmadan toplama işlemi gerçekleştirmemizi sağlar.</span><span class="sxs-lookup"><span data-stu-id="01c2d-203">This circuit allows us to perform addition using no additional qubits apart from those needed to store the inputs and the outputs.</span></span>

### <a name="beauregard-adder"></a><span data-ttu-id="01c2d-204">Beauregard Adder</span><span class="sxs-lookup"><span data-stu-id="01c2d-204">Beauregard Adder</span></span> ###

<span data-ttu-id="01c2d-205">Beauregard ekleyici, rastgele bir pozitif tamsayı $N $ için ek modül $N $ gerçekleştirmek üzere Draper Ekleyici ' i kullanan bir hisse modüler bir Ekleyici.</span><span class="sxs-lookup"><span data-stu-id="01c2d-205">The Beauregard adder is a quantum modular adder that uses the Draper adder in order to perform addition modulo $N$ for an arbitrary value positive integer $N$.</span></span>  <span data-ttu-id="01c2d-206">Beauregard Adder gibi hisse modüler kişilerin önemi, Adder gibi, kor 'ın düzenleme için algoritması içindeki modüler üs adım 'daki kullanımlarını büyük bir ölçüde kullanıyor.</span><span class="sxs-lookup"><span data-stu-id="01c2d-206">The significance of quantum modular adders, such as the Beauregard adder, stems to a large extent from their use in the modular exponentiation step within Shor's algorithm for factoring.</span></span>  <span data-ttu-id="01c2d-207">Hisse modüler bir ekleyici, hisse girişi $ \ket{b} $ ve klasik giriş $a $ $a $ ve $b $ tamsayı mod $N $ olarak kabul edildiği ve $ [0, \lnoktalar, N-1] $ aralığında oldukları anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-207">A quantum modular adder has the following action for quantum input $\ket{b}$ and classical input $a$ where $a$ and $b$ are promised to be integers mod $N$, meaning that they are in the interval $[0,\ldots, N-1]$.</span></span>

<span data-ttu-id="01c2d-208">$ $ \ket{b}\rightarrow \ket{b + a \Text{mod} N} = \begin{Cases} \ket{b + a}, & b + a < N\\\\ \ket{b + a-N}, & (b + a) \ge N \end{Cases}.</span><span class="sxs-lookup"><span data-stu-id="01c2d-208">$$ \ket{b}\rightarrow \ket{b+a \text{ mod }N}=\begin{cases} \ket{b+a},& b+a < N\\\\ \ket{b+a-N},& (b+a)\ge N \end{cases}.</span></span>
$$

<span data-ttu-id="01c2d-209">Beauregard ekleyici, $a $ ve $b $ aşamasına eklemek için Draper Ekleyici veya daha özel olarak $ \fi\\\!\operatorname{Add} $ kullanır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-209">The Beauregard adder uses the Draper adder, or more specifically $\phi\\\!\operatorname{ADD}$, to add $a$ and $b$ in phase.</span></span>  <span data-ttu-id="01c2d-210">Daha sonra, $a + b-N < 0 $ ' ı çıkararak $a + b < N $ $N $ ve test etmeyi kaldırarak aynı işlemi kullanır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-210">It then uses the same operation to identify whether $a+b <N$ by subtracting $N$ and testing if $a+b-N<0$.</span></span>  <span data-ttu-id="01c2d-211">Devre, bu bilgileri bir anılususılge içinde depolar ve sonra $a + b < N $ $N $ kaydı ekler.</span><span class="sxs-lookup"><span data-stu-id="01c2d-211">The circuit stores this information in an ancillary qubit and then adds $N$ back the register if $a+b<N$.</span></span>  <span data-ttu-id="01c2d-212">Daha sonra bu işlem, bu ek bitin bitmemesini sağlar (Bu adım, Adder çağrıldıktan sonra, anıllanla 'nın de ayrılabileceği emin olmak için gereklidir).</span><span class="sxs-lookup"><span data-stu-id="01c2d-212">It then concludes by uncomputing this ancillary bit (this step is needed to ensure that the ancilla can be de-allocated after calling the adder).</span></span>  <span data-ttu-id="01c2d-213">Beauregard Ekleyici için devre aşağıda verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-213">The circuit for the Beauregard adder is given below.</span></span>

![Devre diyagramı olarak gösterilen Beauregard Ekleyici](~/media/beau.png)

<span data-ttu-id="01c2d-215">Burada, $ \Fi\\\!\operatorname{ADD} $ kapısı $ \phi\\\!\operatorname{ADD} $ ile aynı şekilde sürer. Bu bağlamda, bu bağlamda, girişin hisse yerine</span><span class="sxs-lookup"><span data-stu-id="01c2d-215">Here the gate $\Phi\\\!\operatorname{ADD}$ takes the same form as $\phi\\\!\operatorname{ADD}$ except that in this context the input is classical rather than quantum.</span></span>  <span data-ttu-id="01c2d-216">Bu, $ \Fi\\\!\operatorname{ADD} $ içindeki denetlenen aşamaların, hem qubit hem de Adder için gereken kapı sayısını azaltmak üzere daha az işlem halinde derlenebilecek aşama kapıları ile değiştirilmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="01c2d-216">This allows the controlled phases in $\Phi\\\!\operatorname{ADD}$ to be replaced with phase gates that can then be compiled together into fewer operations to reduce both the number of qubits and number of gates needed for the adder.</span></span>

<span data-ttu-id="01c2d-217">Daha fazla ayrıntı için lütfen [M. Roetteler, TH. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) ve [D. Coppersmith](https://arxiv.org/abs/quant-ph/0201067)'e bakın.</span><span class="sxs-lookup"><span data-stu-id="01c2d-217">For more details, please refer to [M. Roetteler, Th. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) and [D. Coppersmith](https://arxiv.org/abs/quant-ph/0201067).</span></span>

### <a name="quantum-phase-estimation"></a><span data-ttu-id="01c2d-218">Kuantum Aşama Tahmini</span><span class="sxs-lookup"><span data-stu-id="01c2d-218">Quantum Phase Estimation</span></span> ###

<span data-ttu-id="01c2d-219">Hisse daha önemli bir uygulama olan unitfourier dönüştürmesinin, *aşama tahmini*olarak bilinen bir sorun olan Unitary işleçlerinin eigendeğerlerini öğrenmesinin nedeni.</span><span class="sxs-lookup"><span data-stu-id="01c2d-219">One particularly important application of the quantum Fourier transform is to learn the eigenvalues of unitary operators, a problem known as *phase estimation*.</span></span>
<span data-ttu-id="01c2d-220">Bir Unitary $U $ ve $ \ket{\phi} $ gibi bir State $ \ket{\phi} $, bilinmeyen eigenvalue $ \phi $, \begin{Equation} U\tus{\ Fi} = \phi\ket{\phi} ile $U $ öğesinin bir eigenstate olduğunu düşünün.</span><span class="sxs-lookup"><span data-stu-id="01c2d-220">Consider a unitary $U$ and a state $\ket{\phi}$ such that $\ket{\phi}$ is an eigenstate of $U$ with unknown eigenvalue $\phi$, \begin{equation} U\ket{\phi} = \phi\ket{\phi}.</span></span>
<span data-ttu-id="01c2d-221">\end{Equation} yalnızca bir Oracle olarak $U $ erişimi varsa, denetimli bir işlemin hedefine uygulanan $Z $ roetlerini denetimin üzerine geri yayarak $ \phi $ aşamasını öğreniyoruz.</span><span class="sxs-lookup"><span data-stu-id="01c2d-221">\end{equation} If we only have access to $U$ as an oracle, then we can learn the phase $\phi$ by utilizing that $Z$ rotations applied to the target of a controlled operation propagate back onto the control.</span></span>

<span data-ttu-id="01c2d-222">$V $ öğesinin, \begin{hizalaması} V (\ayraç{0} \otimes \ket{\phi}) & = \tus{0} \otimes \ket{\phi} gibi kontrollü bir $U $ uygulaması olduğunu varsayalım. \\\\ \textrm{ve} V (\demet{1} \otimes \ket{\phi}) & = e ^ {i \phi} \tus{1} \otimes \ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="01c2d-222">Suppose that $V$ is a controlled application of $U$, such that \begin{align} V (\ket{0} \otimes \ket{\phi}) & =            \ket{0} \otimes \ket{\phi} \\\\ \textrm{ and } V (\ket{1} \otimes \ket{\phi}) & = e^{i \phi} \ket{1} \otimes \ket{\phi}.</span></span>
<span data-ttu-id="01c2d-223">\end{hizalaması} sonra, şu şekilde, \begin{hizalaması} V (\ket{+} \otimes \ket{\phi}) & = \frac{(\tus{0} \otimes \ket{\phi}) + e ^ {ı \phi} (\demet{1} \otimes \ket{\phi})} {\sqrt{2}}.</span><span class="sxs-lookup"><span data-stu-id="01c2d-223">\end{align} Then, by linearity, \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{ (\ket{0} \otimes \ket{\phi}) + e^{i \phi} (\ket{1} \otimes \ket{\phi}) }{\sqrt{2}}.</span></span>
<span data-ttu-id="01c2d-224">\end{hizalaması} Bu \ Begin{hizalaması} V (\ket{+} \otimes \ket{\phi}) öğesini bulmak için şartlar toplayabiliyoruz & = \frac{\tus{0} + e ^ {ı \ Phi} \tus{1}} {\sqrt{2}} \otimes \ket{\phi} \\\\ & = (R_1 (\fi) \ket{+}) \otimes \ket{\phi}, \end{hizalaması}; burada $R _1 $, <xref:microsoft.quantum.intrinsic.r1> işlemi tarafından uygulanan Unitary.</span><span class="sxs-lookup"><span data-stu-id="01c2d-224">\end{align} We can collect terms to find that \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{\ket{0} + e^{i \phi} \ket{1}}{\sqrt{2}} \otimes \ket{\phi} \\\\ & = (R_1(\phi) \ket{+}) \otimes \ket{\phi}, \end{align} where $R_1$ is the unitary applied by the <xref:microsoft.quantum.intrinsic.r1> operation.</span></span>
<span data-ttu-id="01c2d-225">Farklı şekilde, $V $ uygulamanın etkisi, yalnızca bir Oracle olarak $V $ erişimine sahip olduğumuz halde, bilinmeyen bir açıyla $R _1 $ ' ı uygulama ile tam olarak aynıdır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-225">Put differently, the effect of applying $V$ is precisely the same as applying $R_1$ with an unknown angle, even though we only have access to $V$ as an oracle.</span></span>
<span data-ttu-id="01c2d-226">Bu nedenle, bu tartışmanın geri kalanı için aşama tahmini $R _1 (\phi) *$ olarak tartışıyoruz.*</span><span class="sxs-lookup"><span data-stu-id="01c2d-226">Thus, for the rest of this discussion we will discuss phase estimation in terms of $R_1(\phi)$, which we implement by using so-called *phase kickback*.</span></span>

<span data-ttu-id="01c2d-227">Denetim ve hedef kayıt bu işlemden sonra geri ılanmadan kaldığından, "_1 (2 \fi) \ket{+} $ $R durumunda ikinci bir denetim qubit hazırlamak için $U ^ $2 kontrollü bir uygulamasının hedefi olarak $ \ket{\phi} $ öğesini yeniden kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="01c2d-227">Since the control and target register remain untangled after this process, we can reuse $\ket{\phi}$ as the target of a controlled application of $U^2$ to prepare a second control qubit in the state $R_1(2 \phi) \ket{+}$.</span></span>
<span data-ttu-id="01c2d-228">Bu şekilde devam ederek, \begin{hizalaması} \ket{\psı} & = \ sum_ {j = 0} ^ n R_1 (2 ^ j \ Fi) \ket{+} \\\\ & \propto \ bigotimes_ {j = 0} ^ {n} \left (\demet{0} + biçiminde bir kayıt edinebilirsiniz \exp (i 2 ^ {j} \fi) \gre{1}\right) \\\\ & \propto \ sum_ {k = 0} ^ {2 ^ n-1} \exp (i \phi k) \ket{k} \end{hizalaması}; burada $n $, gereken duyarlık bit sayısı olan ${} \propto {}$ ile $ 'ın normalleştirme faktörünü gizliyoruz 1/\ sqrt{2 ^ n} $.</span><span class="sxs-lookup"><span data-stu-id="01c2d-228">Continuing in this way, we can obtain a register of the form \begin{align} \ket{\psi} & = \sum_{j = 0}^n R_1(2^j \phi) \ket{+} \\\\ & \propto \bigotimes_{j=0}^{n} \left(\ket{0} + \exp(i 2^{j} \phi) \ket{1}\right) \\\\ & \propto \sum_{k = 0}^{2^n - 1} \exp(i \phi k) \ket{k} \end{align} where $n$ is the number of bits of precision that we require, and where we have used ${} \propto {}$ to indicate that we have suppressed the normalization factor of $1 / \sqrt{2^n}$.</span></span>

<span data-ttu-id="01c2d-229">$ \Phi = 2 \ Pi p/2 ^ k $ ' ı bir tamsayı $p $ olarak kabul ediyorsanız, bunu $ \ket{\psı} = \operatorname{QFT} \ket{p_0 p_1 \noktalar p_n} $ olarak tanıyacağız; burada $p _j $, $j ^ {\textrm{TH}} $ bit/$2 \pi \phi $ şeklindedir.</span><span class="sxs-lookup"><span data-stu-id="01c2d-229">If we assume that $\phi = 2 \pi p / 2^k$ for an integer $p$, then we recognize this as $\ket{\psi} = \operatorname{QFT} \ket{p_0 p_1 \dots p_n}$, where $p_j$ is the $j^{\textrm{th}}$ bit of $2 \pi \phi$.</span></span>
<span data-ttu-id="01c2d-230">Bu nedenle, hisse dosyası miktarı olarak kodlanan aşamanın ikili gösterimini elde ettiğimiz için, bu nedenle hisse.</span><span class="sxs-lookup"><span data-stu-id="01c2d-230">Applying the adjoint of the quantum Fourier transform, we therefore obtain the binary representation of the phase encoded as a quantum state.</span></span>

<span data-ttu-id="01c2d-231">Q # içinde bu, $m $ $U pozitif tamsayıların bir işlevi olarak <xref:microsoft.quantum.oracles.discreteoracle> uygulamayı uygulayan <xref:microsoft.quantum.characterization.quantumphaseestimation> işlem tarafından uygulanır.</span><span class="sxs-lookup"><span data-stu-id="01c2d-231">In Q#, this is implemented by the <xref:microsoft.quantum.characterization.quantumphaseestimation> operation, which takes a <xref:microsoft.quantum.oracles.discreteoracle> implementing application of $U^m$ as a function of positive integers $m$.</span></span>
