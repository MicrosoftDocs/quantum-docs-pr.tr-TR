---
title: 'Q # programa genel bakış-Q # teknikleri | Microsoft Docs'
description: 'Q # programa genel bakış-Q # Teknik'
author: QuantumWriter
ms.author: Christopher.Granade@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.techniques.file-structure
ms.openlocfilehash: e8f52e6b0d4382331665a8e845ef19a3a1beabf9
ms.sourcegitcommit: f8d6d32d16c3e758046337fb4b16a8c42fb04c39
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 01/29/2020
ms.locfileid: "76820836"
---
# <a name="q-program-overview"></a><span data-ttu-id="8bf99-103">Q# programına genel bakış</span><span class="sxs-lookup"><span data-stu-id="8bf99-103">Q# program overview</span></span>

<span data-ttu-id="8bf99-104">S #, hisse kullanımı için ölçeklenebilir, çok faktörlü, etki alanına özgü bir programlama dilidir.</span><span class="sxs-lookup"><span data-stu-id="8bf99-104">Q# is a scalable, multi-paradigm, domain-specific programming language for quantum computing.</span></span> <span data-ttu-id="8bf99-105">S #, yönergelerin hisse makineleri üzerinde nasıl yürütüleceğini açıklayan bir hisse dili programlama dilidir.</span><span class="sxs-lookup"><span data-stu-id="8bf99-105">Q# is a quantum programming language in that it can be used to describe how instructions are executed on quantum machines.</span></span> <span data-ttu-id="8bf99-106">Simülatörleri 'ten gerçek hisse donanımına kadar hedeflenebilir makineler.</span><span class="sxs-lookup"><span data-stu-id="8bf99-106">The machines that can be targeted range from simulators to actual quantum hardware.</span></span> <span data-ttu-id="8bf99-107">S # ölçeklenebilir: birkaç qubit üzerinde çalışan teleport gibi basit tanıtım programları yazmak için kullanılabilir, ancak aynı zamanda milyonlarca qubit ile büyük makineler gerektirecek karmaşık molecules benzetimleri gibi büyük ve karmaşık programları yazmayı destekler.</span><span class="sxs-lookup"><span data-stu-id="8bf99-107">Q# is scalable: it can be used to write simple demonstration programs like teleport that run on a few qubits, but also supports writing large, sophisticated programs such as simulations of complex molecules that will require large machines with millions of qubits.</span></span> <span data-ttu-id="8bf99-108">Büyük fiziksel makineler hala gelecekte olsa da, soru-cevap olarak bir programcının karmaşık hisse algoritmaları kullanmasına izin verir.</span><span class="sxs-lookup"><span data-stu-id="8bf99-108">Even though large physical machines are still in the future, Q# allows a programmer to program complex quantum algorithms now.</span></span> <span data-ttu-id="8bf99-109">Daha fazla nedir, Q # hata ayıklama, profil oluşturma, kaynak tahmini ve belirli özel amaçlı benzetimler gibi çeşitli görevleri ölçeklenebilir bir şekilde destekler.</span><span class="sxs-lookup"><span data-stu-id="8bf99-109">What is more, Q# supports various tasks such as debugging, profiling, resource estimation, and certain special-purpose simulations in a scalable way.</span></span> 

<span data-ttu-id="8bf99-110">Teknik açıdan, bir hisse bir program, çağrıldığında, yan etkileri olarak hisse devreleri oluşturmak için belirli bir klasik işlevler kümesi olarak görülebilir.</span><span class="sxs-lookup"><span data-stu-id="8bf99-110">From a technical perspective, a quantum program can be seen as a particular set of classical functions which, when called, generate quantum circuits as their side effects.</span></span> <span data-ttu-id="8bf99-111">Bu görünümün önemli bir sonucu, Q # dilinde yazılmış bir programın, qubits 'i doğrudan modelleyebilmesini, ancak klasik bir denetim bilgisayarının bu qubits ile nasıl etkileşime gireceğini açıklar.</span><span class="sxs-lookup"><span data-stu-id="8bf99-111">An important consequence of that view is that a program written in Q# does not directly model qubits themselves, but rather describes how a classical control computer interacts with those qubits.</span></span>
<span data-ttu-id="8bf99-112">Tasarıma göre, Q #, bu nedenle hisse ya da hisse MACS 'nin diğer özelliklerini doğrudan tanımlamaz, ancak bunun yerine dilde tanımlanan çeşitli alt yordamların eylemiyle dolaylı olarak yapılır.</span><span class="sxs-lookup"><span data-stu-id="8bf99-112">By design, Q# thus does not define quantum states or other properties of quantum mechanics directly, but rather does so indirectly through the action of the various subroutines defined in the language.</span></span>
<span data-ttu-id="8bf99-113">Örneğin, [hisse bilgi Işlem kavramları](xref:microsoft.quantum.concepts.intro) Kılavuzu 'nda açıklanan $ \ket{+} = \left (\ket{0} + \tus{1}\right)/\sqrt{2}$ durumunu göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="8bf99-113">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="8bf99-114">Bu durumu Q # ' da hazırlamak için, qubits 'in $ \ket{0}$ durumunda başlatıldığı ve bu $ \ket{+} = H\gre{0}$, burada $H $ 'nin Hadamard dönüşümünden oluşan olguları kullanıyoruz:</span><span class="sxs-lookup"><span data-stu-id="8bf99-114">To prepare this state in Q#, we use the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the Hadamard transform:</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, qubit is in the state |0〉.
    H(qubit);
    // We've now applied H, such that our qubit is in H|0〉 = |+〉, as we wanted.
}
```
## <a name="q-tranformations-of-quantum-states"></a><span data-ttu-id="8bf99-115">S. hisse amaçları için soru-cevap durumları</span><span class="sxs-lookup"><span data-stu-id="8bf99-115">Q# tranformations of quantum states</span></span>

<span data-ttu-id="8bf99-116">Daha da, yukarıdaki programın yazılmasında, Q # içindeki duruma açıkça başvurmuyoruz, ancak durumun programımız tarafından nasıl *dönüştürüldüğünü* açıklıyoruz.</span><span class="sxs-lookup"><span data-stu-id="8bf99-116">Importantly, in writing the above program, we did not explicitly refer to the state within Q#, but rather described how the state was *transformed* by our program.</span></span>
<span data-ttu-id="8bf99-117">Bu nedenle, bir grafik gölgelendirici programının her bir köşenin dönüştürmelerinin açıklamasını nasıl birikdiğinden benzer şekilde, Q # ' daki bir hisse</span><span class="sxs-lookup"><span data-stu-id="8bf99-117">Thus, similar to how a graphics shader program accumulates a description of transformations to each vertex, a quantum program in Q# accumulates transformations to quantum states.</span></span>
<span data-ttu-id="8bf99-118">Bu, makineye bağlı farklı yorumlamalar olabilecek her bir hedef makinede bile her bir hisse alım durumunun büyük bir yerde *olduğu* konusunda tamamen belirsiz bir durumdur.</span><span class="sxs-lookup"><span data-stu-id="8bf99-118">This allows us to be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="8bf99-119">Bir Q # programının perspektifinden, qubit, hedef makinenin iç yapısına tamamen opak bir başvurudur.</span><span class="sxs-lookup"><span data-stu-id="8bf99-119">From the perspective of a Q# program, a qubit is an entirely opaque reference to the internal structure of a target machine.</span></span>
<span data-ttu-id="8bf99-120">Bir Q # programı, bir qubit durumunun durumunu, bir hedef makine üzerinde temsilini introspect, hatta programın kullanabildiği diğer tüm qubit gibi aynı qubit olup olmadığını da bilme özelliğine sahip değildir.</span><span class="sxs-lookup"><span data-stu-id="8bf99-120">A Q# program has no ability to introspect into the state of a qubit, its representation on a target machine, or even whether it is the same qubit as any other qubit available to the program.</span></span>
<span data-ttu-id="8bf99-121">Bunun yerine, bir program qubit 'ten bilgi edinmek için `Measure` gibi işlemleri çağırabilir ve bir qubit durumuna işlem yapmak için `X` ve `H` gibi çağrı işlemleri gerçekleştirebilir.</span><span class="sxs-lookup"><span data-stu-id="8bf99-121">Rather, a program can call operations such as `Measure` to learn information from a qubit, and call operations such as `X` and `H` to act on the state of a qubit.</span></span>
<span data-ttu-id="8bf99-122">Bu işlemlerin dil içinde hiç iç tanımı yoktur ve yalnızca belirli bir Q # programını çalıştırmak için kullanılan hedef makine tarafından somut hale getirilir.</span><span class="sxs-lookup"><span data-stu-id="8bf99-122">These operations have no intrinsic definition within the language, and are made concrete only by the target machine used to run a particular Q# program.</span></span>
<span data-ttu-id="8bf99-123">Bir Q # programı, Express hisse hesaplamasına yeni ve daha üst düzey işlemler oluşturmak için bu işlemleri bir hedef makine tarafından tanımlanan şekilde yeniden birleştirir.</span><span class="sxs-lookup"><span data-stu-id="8bf99-123">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="8bf99-124">Bu şekilde, Q #, temel alınan hisse ve hibrit-klasik algoritmaların yanı sıra bir hedef makine ya da simülatör yapısına göre genel de olacak şekilde ifade yapmayı kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="8bf99-124">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum-classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="q-operations-and-functions"></a><span data-ttu-id="8bf99-125">S # işlem ve işlevleri</span><span class="sxs-lookup"><span data-stu-id="8bf99-125">Q# operations and functions</span></span>

<span data-ttu-id="8bf99-126">Bir Q # programı, bir veya daha fazla *işlemden*, bir veya daha fazla *işlevden*ve Kullanıcı tanımlı türlerden oluşur.</span><span class="sxs-lookup"><span data-stu-id="8bf99-126">Concretely, a Q# program is comprised of one or more *operations*, one or more *functions*, and user defined types.</span></span> <span data-ttu-id="8bf99-127">İşlemler, bir hisse anın durumunun dönüşümlerini betimleyen ve en temel yapı bloğu olan Q # programlarıdır.</span><span class="sxs-lookup"><span data-stu-id="8bf99-127">Operations are used to describe the transformations of the state of a quantum machine and are the most basic building block of Q# programs.</span></span> <span data-ttu-id="8bf99-128">Her bir işlem, bir hedef makine tarafından uygulanan yerleşik *iç* işlemler de dahil olmak üzere herhangi bir sayıda işlemi çağırabilir.</span><span class="sxs-lookup"><span data-stu-id="8bf99-128">Each operation defined in Q# may then call any number of other operations, including the built-in *intrinsic* operations implemented by a target machine.</span></span>
<span data-ttu-id="8bf99-129">Derlendiğinde, her işlem hedef makinelere sağlanlenebilecek bir .NET sınıf türü olarak temsil edilir.</span><span class="sxs-lookup"><span data-stu-id="8bf99-129">When compiled, each operation is represented as a .NET class type that can be provided to target machines.</span></span>

<span data-ttu-id="8bf99-130">İşlemlere karşılık işlevler, tamamen klasik davranışı betimleyen ve klasik çıkış değerlerini hesaplama konusunda herhangi bir etkiye sahip olmayan işlevler için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="8bf99-130">In contrast to operations, functions are used to describe purely classical behavior and do not have any effects besides computing classical output values.</span></span> <span data-ttu-id="8bf99-131">S #, türü kesin belirlenmiş bir dildir ve yerleşik temel türler kümesi ve Kullanıcı tanımlı türler için destek ile birlikte gelir.</span><span class="sxs-lookup"><span data-stu-id="8bf99-131">Q# is a strongly typed language and comes with a set of built-in primitive types as well as support for user defined types.</span></span> 

<span data-ttu-id="8bf99-132">Bu kılavuzun geri kalanında, farklı dil kavramlarının ve yapıların nasıl kullanıldığını, karmaşık hisse programlarını işlem, işlev ve tür temel yapı taşları aracılığıyla belirlememize yardımcı olacak şekilde kullanacağız.</span><span class="sxs-lookup"><span data-stu-id="8bf99-132">Throughout the rest of this guide, we will see how to use different language concepts and constructs to help us define complex quantum programs through the basic building blocks of operations, functions, and types.</span></span> 

## <a name="structure-of-q-source-files"></a><span data-ttu-id="8bf99-133">Q # kaynak dosyalarının yapısı</span><span class="sxs-lookup"><span data-stu-id="8bf99-133">Structure of Q# Source Files</span></span>

<span data-ttu-id="8bf99-134">En düşük düzeyde, bir Q # kaynak dosyası, kaynak dosyadaki tanımları içeren bir .NET ad alanını belirten bir *ad alanı bildiriminden*oluşur.</span><span class="sxs-lookup"><span data-stu-id="8bf99-134">Minimally, a Q# source file consists of a *namespace declaration*, which specifies a .NET namespace which will contain the definitions in the source file.</span></span>
<span data-ttu-id="8bf99-135">Diğer Q # kaynak dosyalarından ve kitaplıklarından olan tanımlar `open` ifadesiyle eklenebilir.</span><span class="sxs-lookup"><span data-stu-id="8bf99-135">Definitions from other Q# source files and libraries can be included using the `open` statement.</span></span>
<span data-ttu-id="8bf99-136">Örneğin, temel kapıları tanımlayan işlemlerin çoğu <xref:microsoft.quantum.intrinsic> ad alanında tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="8bf99-136">For instance, most of the operations defining fundamental gates are defined in the <xref:microsoft.quantum.intrinsic> namespace.</span></span>
<span data-ttu-id="8bf99-137">Bunu kodumuza uygun hale getirmek için, her bir dosyanın en üstünde yer alan ad alanını `open`.</span><span class="sxs-lookup"><span data-stu-id="8bf99-137">To make this available to our code, we simply `open` that namespace at the top of each file:</span></span>

```qsharp
namespace Example {
    open Microsoft.Quantum.Intrinsic;

    // ...
}
```

<span data-ttu-id="8bf99-138">Bir ad alanı içinde her Q # kaynak dosyası *işlemler*, *işlevler*ve *Kullanıcı tanımlı türlerin*herhangi bir birleşimini tanımlayabilir.</span><span class="sxs-lookup"><span data-stu-id="8bf99-138">Within a namespace, each Q# source file can define any combination of *operations*, *functions*, and *user-defined types*.</span></span>
<span data-ttu-id="8bf99-139">Bu bölümün geri kalanında, her birini sırayla anlayacağız ve yararlı hisse programları için uygulamada nasıl kullanılabilecekleri hakkında örnekler sunacağız.</span><span class="sxs-lookup"><span data-stu-id="8bf99-139">In the rest of this section, we will describe each in turn and provide examples of how they can be used in practice to make useful quantum programs.</span></span>
