---
title: 'Q # API tasarım Ilkeleri'
description: 'Q # API tasarım Ilkeleri'
author: cgranade
ms.author: chgranad
ms.date: 3/9/2020
ms.topic: article
uid: microsoft.quantum.contributing.api-design
ms.openlocfilehash: a8e830e8f46ac6bd53ed5c607ca8cc2897721a20
ms.sourcegitcommit: db23885adb7ff76cbf8bd1160d401a4f0471e549
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 05/01/2020
ms.locfileid: "82687333"
---
# <a name="q-api-design-principles"></a><span data-ttu-id="794fa-103">Q # API tasarım Ilkeleri</span><span class="sxs-lookup"><span data-stu-id="794fa-103">Q# API Design Principles</span></span>

## <a name="introduction"></a><span data-ttu-id="794fa-104">Giriş</span><span class="sxs-lookup"><span data-stu-id="794fa-104">Introduction</span></span>

<span data-ttu-id="794fa-105">Bir dil ve platform olarak, soru-cevap kullanıcılara hisse, çalışma, anlama ve bilgi edinme</span><span class="sxs-lookup"><span data-stu-id="794fa-105">As a language and as a platform, Q# empowers users to write, run, understand, and explore quantum applications.</span></span>
<span data-ttu-id="794fa-106">Kullanıcılara güç sağlamak için, Q # kitaplıklarını tasarlarken, tasarımlarımıza kılavuzluk eden bir API tasarım ilkeleri kümesi izler ve hisse geliştirme topluluğu için kullanılabilir kitaplıklar oluşturmamıza yardımcı olun.</span><span class="sxs-lookup"><span data-stu-id="794fa-106">In order to empower users, when we design Q# libraries, we follow a set of API design principles to guide our designs and to help us make usable libraries for the the quantum development community.</span></span>
<span data-ttu-id="794fa-107">Bu makalede bu ilkeler listelenmekte ve soru-cevap API 'Leri tasarlarken nasıl uygulanabilmenize yardımcı olacak örnekler verilmektedir.</span><span class="sxs-lookup"><span data-stu-id="794fa-107">This article lists these principles, and gives examples to help guide how to apply them when designing Q# APIs.</span></span>

> [!TIP]
> <span data-ttu-id="794fa-108">Bu, kitaplık geliştirme ve ayrıntılı kitaplık katkılarına kılavuzluk eden oldukça ayrıntılı bir belgedir.</span><span class="sxs-lookup"><span data-stu-id="794fa-108">This is a fairly detailed document that's intended to help guide library development and in-depth library contributions.</span></span>
> <span data-ttu-id="794fa-109">Büyük olasılıkla, Q # ' da kendi kitaplıklarınızı yazıyorsanız veya [q # kitaplıkları deposuna](https://github.com/microsoft/QuantumLibraries)daha büyük Özellikler katkıdıysanız en çok yararlı bulacaksınız.</span><span class="sxs-lookup"><span data-stu-id="794fa-109">You'll probably find it most useful if you're writing your own libraries in Q#, or if you're contributing larger features to the [Q# libraries repository](https://github.com/microsoft/QuantumLibraries).</span></span>
>
> <span data-ttu-id="794fa-110">Öte yandan, hisse geliştirme paketine daha genel katkıda bulunma hakkında daha fazla bilgi edinmek istiyorsanız, [katkı Kılavuzu](xref:microsoft.quantum.contributing)' nu kullanmaya başladık.</span><span class="sxs-lookup"><span data-stu-id="794fa-110">On the other hand, if you're looking to learn how to contribute to the Quantum Development Kit more generally, we suggest starting with the [contribution guide](xref:microsoft.quantum.contributing).</span></span>
> <span data-ttu-id="794fa-111">Q # kodunuzun biçimlendirilmesini nasıl önerdiğimiz hakkında daha genel bilgiler arıyorsanız, [Stil kılavuzunu](xref:microsoft.quantum.contributing.style)kullanıma almak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="794fa-111">If you're looking for more general information about how we recommend formatting your Q# code, you may be interested in checking out the [style guide](xref:microsoft.quantum.contributing.style).</span></span>

## <a name="general-principles"></a><span data-ttu-id="794fa-112">Genel Ilkeler</span><span class="sxs-lookup"><span data-stu-id="794fa-112">General Principles</span></span>

<span data-ttu-id="794fa-113">**Anahtar ilkesi:** , Odağı hisse. uygulamalara yerleştiren API 'Leri kullanıma sunun.</span><span class="sxs-lookup"><span data-stu-id="794fa-113">**Key principle:** Expose APIs that places the focus on quantum applications.</span></span>

- <span data-ttu-id="794fa-114">✅Algoritmaların ve uygulamaların üst düzey yapısını yansıtan işlem ve işlev **adlarını seçin.**</span><span class="sxs-lookup"><span data-stu-id="794fa-114">✅ **DO** choose operation and function names that reflect the   high-level structure of algorithms and applications.</span></span>
- <span data-ttu-id="794fa-115">⛔️ birincil olarak alt düzey uygulama ayrıntılarına odaklanarak API 'Leri kullanıma **sunmayın** .</span><span class="sxs-lookup"><span data-stu-id="794fa-115">⛔️ **DON'T** expose APIs that focus primarily on low-level   implementation details.</span></span>

<span data-ttu-id="794fa-116">**Anahtar ilkesi:** API 'Lerin kullanım için sezgisel olduğundan emin olmak için her API tasarımını örnek kullanım durumları ile başlatın.</span><span class="sxs-lookup"><span data-stu-id="794fa-116">**Key principle:** Start each API design with sample use cases to ensure that APIs are intuitive to use.</span></span>

- <span data-ttu-id="794fa-117">✅Bir ortak API 'nin her bileşeninin, başlangıçtan itibaren olası tüm kullanımlar için tasarım denemesi yerine karşılık gelen bir kullanım örneğine sahip **olduğundan emin olun** .</span><span class="sxs-lookup"><span data-stu-id="794fa-117">✅ **DO** ensure that each component of a public API has a corresponding use case, rather than trying to design for all possible uses from the start.</span></span>
    <span data-ttu-id="794fa-118">Farklı bir şekilde, yararlı olmaları durumunda ortak API 'Ler oluşturmayın, ancak bir API 'nin her bölümünün yararlı olacağı *somut* bir örneğe sahip olduğundan emin olun.</span><span class="sxs-lookup"><span data-stu-id="794fa-118">Put differently, don't introduce public APIs in case they are useful, but make sure that each part of an API has a *concrete* example in which it will be useful.</span></span>

  <span data-ttu-id="794fa-119">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-119">*Examples:*</span></span>
  - <span data-ttu-id="794fa-120">@"microsoft.quantum.canon.applytoeachca", çok sayıda hisse `ApplyToEachCA(H, _)` algoritmasında ortak bir görev olan bir Tekdüzen üst konum durumunda Yazmaçları hazırlamak için olarak kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="794fa-120">@"microsoft.quantum.canon.applytoeachca" can be used as `ApplyToEachCA(H, _)` to prepare registers in a uniform superposition state, a common task in many quantum algorithms.</span></span> <span data-ttu-id="794fa-121">Aynı işlem, hazırlık, sayı ve Oracle tabanlı algoritmalarda birçok diğer görev için de kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="794fa-121">The same operation can also be used for many other tasks in preparation, numerics, and oracle-based algorithms.</span></span>

- <span data-ttu-id="794fa-122">✅Tek bir kez beyin fırtınası **yapın** ve yeni API tasarımları oluşturun ve bunları sezgisel olarak kontrol edin ve önerilen kullanım durumlarını karşılayın.</span><span class="sxs-lookup"><span data-stu-id="794fa-122">✅ **DO** brainstorm and workshop new API designs to double-check   that they are intuitive and meet proposed use cases.</span></span>

  <span data-ttu-id="794fa-123">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-123">*Examples:*</span></span>
  - <span data-ttu-id="794fa-124">Yeni API tasarımlarının mevcut uygulamaları nasıl basitleştireceğinizi ve açıklanmadığını görmek için geçerli Q\# kodunu inceleyin.</span><span class="sxs-lookup"><span data-stu-id="794fa-124">Inspect current Q\# code to see how new API designs could   simplify and clarify existing implementations.</span></span>
  - <span data-ttu-id="794fa-125">Birincil hedef kitleleri temsilcileriyle önerilen API tasarımlarını gözden geçirin.</span><span class="sxs-lookup"><span data-stu-id="794fa-125">Review proposed API designs with representatives of primary   audiences.</span></span>

<span data-ttu-id="794fa-126">**Anahtar ilkesi:** Okunabilir kodu desteklemek ve teşvik etmek için API 'Ler tasarlayın.</span><span class="sxs-lookup"><span data-stu-id="794fa-126">**Key principle:** Design APIs to support and encourage readable code.</span></span>

- <span data-ttu-id="794fa-127">✅Kodun etki alanı uzmanları ve uzman olmayanlar tarafından okunabilir **olduğundan emin olun** .</span><span class="sxs-lookup"><span data-stu-id="794fa-127">✅ **DO** ensure that code is readable by domain experts and   non-experts alike.</span></span>
- <span data-ttu-id="794fa-128">✅Uygulama ayrıntılarına uygun şekilde **Delve yapmak için** belgeleri kullanarak her bir işlemin ve yüksek düzeyli algoritmadaki işlevin etkilerine odaklanın.</span><span class="sxs-lookup"><span data-stu-id="794fa-128">✅ **DO** place the focus on the effects of each operation and   function within the high-level algorithm, using documentation to   delve into implementation details as appropriate.</span></span>
- <span data-ttu-id="794fa-129">✅Uygun olan her durumda [ortak\# Q stili kılavuzunu](xref:microsoft.quantum.contributing.style) **izleyin.**</span><span class="sxs-lookup"><span data-stu-id="794fa-129">✅ **DO** follow the common [Q\# style guide](xref:microsoft.quantum.contributing.style) whenever applicable.</span></span>

<span data-ttu-id="794fa-130">**Anahtar ilkesi:** API 'Leri kararlı olacak şekilde tasarlayın ve ileriye dönük uyumluluk sağlayın.</span><span class="sxs-lookup"><span data-stu-id="794fa-130">**Key principle:** Design APIs to be stable and to provide forward compatibility.</span></span>

- <span data-ttu-id="794fa-131">✅Önemli değişiklikler gerektiğinde eski API 'Leri sorunsuz bir **şekilde kullanımdan kaldırır** .</span><span class="sxs-lookup"><span data-stu-id="794fa-131">✅ **DO** deprecate old APIs gracefully when breaking changes are   required.</span></span>

- <span data-ttu-id="794fa-132">✅Kullanımdan kaldırma sırasında mevcut kullanıcı kodunun doğru çalışmasına izin veren "dolgu" işlemleri ve **işlevleri sağlar.**</span><span class="sxs-lookup"><span data-stu-id="794fa-132">✅ **DO** provide "shim" operations and functions that allow   existing user code to operate correctly during deprecation.</span></span>

  <span data-ttu-id="794fa-133">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-133">*Examples:*</span></span>
  - <span data-ttu-id="794fa-134">Öğesine adlı `EstimateExpectation` bir işlemi yeniden adlandırırken `EstimateAverage`, var olan kodun doğru şekilde `EstimateExpectation` çalışmaya devam edebilmesi için özgün işlemi yeni adında çağıran adlı yeni bir işlem tanıtın.</span><span class="sxs-lookup"><span data-stu-id="794fa-134">When renaming an operation called `EstimateExpectation` to   `EstimateAverage`, introduce a new operation called   `EstimateExpectation` that calls the original operation at   its new name, so that existing code can continue to work   correctly.</span></span>

- <span data-ttu-id="794fa-135">✅Kullanıcı kullanım dışı @"microsoft.quantum.core.deprecated" Bırakıla iletişim kurmak için **özniteliğini kullanın.**</span><span class="sxs-lookup"><span data-stu-id="794fa-135">✅ **DO** use the @"microsoft.quantum.core.deprecated" attribute to communicate deprecations to the user.</span></span>

- <span data-ttu-id="794fa-136">✅Bir işlemi veya işlevi yeniden adlandırırken, yeni adı bir dize girişi **olarak sağlayın.** `@Deprecated`</span><span class="sxs-lookup"><span data-stu-id="794fa-136">✅ When renaming an operation or function, **DO** provide the new   name as a string input to `@Deprecated`.</span></span>

- <span data-ttu-id="794fa-137">⛔️, önizleme sürümleri için en az altı aya veya desteklenen yayınlar için en az iki yıla kadar kullanım süresi olmadan mevcut işlevleri veya **işlemleri kaldırmayın.**</span><span class="sxs-lookup"><span data-stu-id="794fa-137">⛔️ **DON'T** remove existing functions or operations without a   deprecation period of at least six months for preview releases,   or at least two years for supported releases.</span></span>

## <a name="functions-and-operations"></a><span data-ttu-id="794fa-138">İşlevler ve Işlemler</span><span class="sxs-lookup"><span data-stu-id="794fa-138">Functions and Operations</span></span>

<span data-ttu-id="794fa-139">**Anahtar ilkesi:** her işlev ve işlemin API içinde iyi tanımlanmış tek bir amaca sahip olduğundan emin olun.</span><span class="sxs-lookup"><span data-stu-id="794fa-139">**Key principle:** ensure that every function and operation has a single well-defined purpose within the API.</span></span>

- <span data-ttu-id="794fa-140">⛔️, birden çok ilgisiz görevi gerçekleştiren işlevleri ve işlemleri **kullanıma sunmaz.**</span><span class="sxs-lookup"><span data-stu-id="794fa-140">⛔️ **DON'T** expose functions and operations that perform multiple   unrelated tasks.</span></span>

<span data-ttu-id="794fa-141">**Anahtar ilkesi:** işlevleri ve işlemleri mümkün olduğunca yeniden kullanılabilir olacak şekilde tasarlayın ve gelecekteki ihtiyaçları tahmin edin.</span><span class="sxs-lookup"><span data-stu-id="794fa-141">**Key principle:** design functions and operations to be as reusable as possible, and to anticipate future needs.</span></span>

- <span data-ttu-id="794fa-142">✅Aynı API 'de ve daha önce var olan kitaplıklarda diğer işlevler ve işlemlerle birlikte oluşturmak için işlevler ve **işlemler tasarlayın.**</span><span class="sxs-lookup"><span data-stu-id="794fa-142">✅ **DO** design functions and operations to compose well with other   functions and operations, both in the same API and in previously   existing libraries.</span></span>

  <span data-ttu-id="794fa-143">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-143">*Examples:*</span></span>
  - <span data-ttu-id="794fa-144">@"microsoft.quantum.canon.delay" İşlem, girişi hakkında en düşük varsayımlar yapar ve bu nedenle, her iki işlemin veya Kullanıcı tarafından tanımlanan bir işlem için uygulamaları geciktirmek üzere kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="794fa-144">The @"microsoft.quantum.canon.delay" operation makes minimal assumptions about its input, and thus can be used to delay applications of either operations across the Q# standard library or as defined by users.</span></span>
    <!-- TODO: define bad example. -->

- <span data-ttu-id="794fa-145">✅İşlemler yerine işlev olarak yalnızca belirleyici klasik **mantığı sergileme** .</span><span class="sxs-lookup"><span data-stu-id="794fa-145">✅ **DO** expose purely deterministic classical logic as   as functions rather than operations.</span></span>

  <span data-ttu-id="794fa-146">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-146">*Examples:*</span></span>
  - <span data-ttu-id="794fa-147">Kayan nokta girişini gösteren bir alt yordam, bir işlem `Squared : Double -> Double` `Square : Double => Double`olarak değil, kullanıcıya gösterilmelidir.</span><span class="sxs-lookup"><span data-stu-id="794fa-147">A subroutine which squares its floating-point input can be written deterministically, and so should be exposed to the user as `Squared : Double -> Double` rather than as an operation `Square : Double => Double`.</span></span> <span data-ttu-id="794fa-148">Bu, alt yordamın daha fazla yerde (örneğin, diğer işlevlerin içinde) çağrılmasına izin verir ve derleyiciye performansı ve iyileştirmeleri etkileyebilecek yararlı iyileştirme bilgileri sağlar.</span><span class="sxs-lookup"><span data-stu-id="794fa-148">This allows for the subroutine to be called in more places (e.g.: inside of other functions), and provides useful optimization information to the compiler that can affect performance and optimizations.</span></span>
  - <span data-ttu-id="794fa-149">`ForEach<'TInput, 'TOutput>('TInput => 'TOutput, 'TInput[]) => 'TOutput[]`ve `Mapped<'TInput, 'TOutput>('TInput -> 'TOutput, 'TInput[]) -> 'TOutput[]` belirleyici bir şekilde yapılan garantilere göre farklılık gösterir; her ikisi de farklı koşullarda yararlı olur.</span><span class="sxs-lookup"><span data-stu-id="794fa-149">`ForEach<'TInput, 'TOutput>('TInput => 'TOutput, 'TInput[]) => 'TOutput[]` and `Mapped<'TInput, 'TOutput>('TInput -> 'TOutput, 'TInput[]) -> 'TOutput[]` differ in the guarantees made with respect to   determinism; both are useful in different circumstances.</span></span>
  - <span data-ttu-id="794fa-150">Hisse alma işlemlerinin uygulamasını dönüştüren API yordamları, genellikle belirleyici bir şekilde gerçekleştirilebilir ve bu nedenle, gibi işlevler olarak kullanılabilir hale getirilebilir `CControlled<'T>(op : 'T => Unit) => ((Bool, 'T) => Unit)`.</span><span class="sxs-lookup"><span data-stu-id="794fa-150">API routines that transform the application of quantum   operations can often be carried out in a deterministic     fashion and hence can be made available as functions such as   `CControlled<'T>(op : 'T => Unit) => ((Bool, 'T) => Unit)`.</span></span>

- <span data-ttu-id="794fa-151">✅Gerektiğinde tür parametrelerini kullanarak, her bir işlev ve işlem için giriş türünü makul **şekilde genelleştirin** .</span><span class="sxs-lookup"><span data-stu-id="794fa-151">✅ **DO** generalize the input type as much as reasonable for each   function and operation, using type parameters as needed.</span></span>

  <span data-ttu-id="794fa-152">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-152">*Examples:*</span></span>
  - <span data-ttu-id="794fa-153">`ApplyToEach`en yaygın `<'T>(('T => Unit), 'T[]) => Unit` uygulamasının belirli türü yerine türü vardır `((Qubit => Unit), Qubit[]) => Unit`.</span><span class="sxs-lookup"><span data-stu-id="794fa-153">`ApplyToEach` has type `<'T>(('T => Unit), 'T[]) => Unit` rather than the specific type of its most common   application, `((Qubit => Unit), Qubit[]) => Unit`.</span></span>

> [!TIP]
> <span data-ttu-id="794fa-154">Gelecekteki ihtiyaçları tahmin etmek önemlidir, ancak kullanıcılarınız için somut sorunları çözmenin de önemlidir.</span><span class="sxs-lookup"><span data-stu-id="794fa-154">It is important to anticipate future needs, but it is also important to solve concrete problems for your users.</span></span>
> <span data-ttu-id="794fa-155">Bu nedenle bu temel prensibi, her zaman dikkatli bir değerlendirme gerektirir ve API 'Leri geliştirmekten kaçınmak için "Tıpkı büyük/küçük"</span><span class="sxs-lookup"><span data-stu-id="794fa-155">Acting on this key principle thus always requires careful consideration and balancing to avoid developing APIs "just in case."</span></span>

<span data-ttu-id="794fa-156">**Anahtar ilkesi:** öngörülebilir ve çağrılabilir amacını ileten işlevler ve işlemler için giriş ve çıkış türlerini seçin.</span><span class="sxs-lookup"><span data-stu-id="794fa-156">**Key principle:** choose input and output types for functions and operations that are predictable, and that communicate the purpose of a callable.</span></span>

- <span data-ttu-id="794fa-157">✅Yalnızca bir arada kabul edildiğinde önemli olan giriş ve çıkışları mantıksal olarak gruplamak için demet **türlerini kullanın.**</span><span class="sxs-lookup"><span data-stu-id="794fa-157">✅ **DO** use tuple types to logically group inputs and outputs that are only significant when considered together.</span></span> <span data-ttu-id="794fa-158">Bu durumlarda Kullanıcı tanımlı bir tür kullanmayı düşünün.</span><span class="sxs-lookup"><span data-stu-id="794fa-158">Consider using a user-defined type in these cases.</span></span>

  <span data-ttu-id="794fa-159">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-159">*Examples:*</span></span>
  - <span data-ttu-id="794fa-160">Başka bir işlevin yerel en düşük değerleri çıktısını almak için bir işlev, uygun bir imza `LocalMinima(fn : (Double -> Double), (left : Double, right : Double)) : Double` olabilecek bir arama aralığının bir giriş olarak sınırlarını gerektirebilir.</span><span class="sxs-lookup"><span data-stu-id="794fa-160">A function to output the local minima of another function   may need to take bounds of a search interval as input, such   that `LocalMinima(fn : (Double -> Double), (left : Double, right : Double)) : Double` may be an appropriate signature.</span></span>
  - <span data-ttu-id="794fa-161">Bir makine öğrenimi sınıflandırmasının bir türevi olan parametre kaydırma tekniğinin bir türevini tahmin etmeye yönelik bir işlem, hem kaydırılan hem de geriye doğru olmayan parametre vektörlerini giriş olarak alamaz.</span><span class="sxs-lookup"><span data-stu-id="794fa-161">An operation to estimate a derivative of a machine learning classifier using the parameter shift technique may need to take both the shifted and unshifted parameter vectors as inputs.</span></span> <span data-ttu-id="794fa-162">Şuna benzer bir giriş `(unshifted : Double[], shifted : Double[])` bu durumda uygun olabilir.</span><span class="sxs-lookup"><span data-stu-id="794fa-162">An input similar to `(unshifted : Double[], shifted : Double[])` may be appropriate in this case.</span></span>

- <span data-ttu-id="794fa-163">✅Giriş ve çıkış tanımlama alanlarında öğeleri farklı işlevler ve işlemler arasında tutarlı bir **şekilde sıralayın.**</span><span class="sxs-lookup"><span data-stu-id="794fa-163">✅ **DO** order items in input and output tuples consistently   across different functions and operations.</span></span>

  <span data-ttu-id="794fa-164">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-164">*Examples:*</span></span>
  - <span data-ttu-id="794fa-165">İki veya işlev ya da her biri bir döndürme açısı ve bir hedef qubit girişi olarak düşünüyorsa, bunların her giriş grubu için aynı sıralandıklarından emin olun.</span><span class="sxs-lookup"><span data-stu-id="794fa-165">If considering two or functions or operations that each take a rotation angle and a target qubit as inputs, ensure that they are ordered the same in each input tuple.</span></span> <span data-ttu-id="794fa-166">Diğer bir deyişle, `ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl` ve `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)` ' `ApplyRotation(target : Qubit, angle : Double) : Unit is Adj + Ctl` yi `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)`tercih eder.</span><span class="sxs-lookup"><span data-stu-id="794fa-166">That is, prefer `ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl` and `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)` to `ApplyRotation(target : Qubit, angle : Double) : Unit is Adj + Ctl` and `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)`.</span></span>

<span data-ttu-id="794fa-167">**Anahtar ilkesi:** kısmi uygulama gibi Q\# dil özellikleriyle iyi çalışmak için işlevler ve işlemler tasarlayın.</span><span class="sxs-lookup"><span data-stu-id="794fa-167">**Key principle:** design functions and operations to work well with Q\# language features such as partial application.</span></span>

- <span data-ttu-id="794fa-168">✅Giriş tanımlama grupları içindeki öğeleri, en yaygın olarak uygulanan girdilerin önce gerçekleşmesi (yani, kısmi uygulamanın currying 'e benzer şekilde davranması) **için sıralayın.**</span><span class="sxs-lookup"><span data-stu-id="794fa-168">✅ **DO** order items in input tuples such that the most commonly   applied inputs occur first (i.e.: so that partial application   acts similarly to currying).</span></span>

  <span data-ttu-id="794fa-169">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-169">*Examples:*</span></span>
  - <span data-ttu-id="794fa-170">Kayan noktalı `ApplyRotation` bir sayı ve bir qubit girişi olan bir işlem, genellikle, türü `Qubit => Unit`bir girişi bekleyen işlemlerle kullanım için ilk olarak kayan nokta girişi ile kısmen uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="794fa-170">An operation `ApplyRotation` that takes a floating-point number and a qubit as inputs may often be partially applied with the floating-point input first for use with operations that expect an input of type `Qubit => Unit`.</span></span> <span data-ttu-id="794fa-171">Bu nedenle, bir imzası`operation ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl`</span><span class="sxs-lookup"><span data-stu-id="794fa-171">Thus, a signature of `operation ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl`</span></span>
      <span data-ttu-id="794fa-172">kısmi uygulamayla en tutarlı şekilde çalışır.</span><span class="sxs-lookup"><span data-stu-id="794fa-172">would work most consistently with partial application.</span></span>
  - <span data-ttu-id="794fa-173">Genellikle, bu kılavuz, tüm klasik verilerin giriş tanımlama grupları 'ndaki tüm qugeler öncesine yerleştirilmesi anlamına gelir, ancak iyi bir deneyim kullanır ve API 'nizin uygulamada nasıl çağrıldığını inceleyin.</span><span class="sxs-lookup"><span data-stu-id="794fa-173">Typically, this guidance means placing all classical data   before all qubits in input tuples, but use good judgment and   examine how your API is called in practice.</span></span>

## <a name="user-defined-types"></a><span data-ttu-id="794fa-174">Kullanıcı tanımlı türler</span><span class="sxs-lookup"><span data-stu-id="794fa-174">User-Defined Types</span></span>

<span data-ttu-id="794fa-175">**Anahtar ilkesi:** API 'leri daha açıklayıcı ve kullanımı kolay hale getirmenize yardımcı olması için Kullanıcı tanımlı türleri kullanın.</span><span class="sxs-lookup"><span data-stu-id="794fa-175">**Key principle:** use user-defined types to help make APIs more expressive and convenient to use.</span></span>

- <span data-ttu-id="794fa-176">✅Uzun ve/veya karmaşık türler için yararlı bir Özet sağlamak üzere Kullanıcı tanımlı yeni türler **ortaya çıkarabilir.**</span><span class="sxs-lookup"><span data-stu-id="794fa-176">✅ **DO** introduce new user-defined types to provide helpful   shorthand for long and/or complicated types.</span></span>

  <span data-ttu-id="794fa-177">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-177">*Examples:*</span></span>
  - <span data-ttu-id="794fa-178">Üç qubit dizi girişi olan bir işlem türünün genellikle giriş olarak alındığı veya çıkış olarak döndürüldüğü durumlarda, gibi bir UDT sağlayarak`newtype TimeDependentBlockEncoding = ((Qubit[], Qubit[], Qubit[]) => Unit is Adj + Ctl)`</span><span class="sxs-lookup"><span data-stu-id="794fa-178">In cases where an operation type with three qubit array inputs is commonly taken as an input or returned as an output, providing a UDT such as `newtype TimeDependentBlockEncoding = ((Qubit[], Qubit[], Qubit[]) => Unit is Adj + Ctl)`</span></span>
      <span data-ttu-id="794fa-179">yararlı bir Özet sağlamaya yardımcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="794fa-179">can help provide a useful shorthand.</span></span>

- <span data-ttu-id="794fa-180">✅Belirli bir temel türün yalnızca belirli bir anlamda kullanılması gerektiğini göstermek için Kullanıcı tanımlı yeni **türler tanıtılmalıdır** .</span><span class="sxs-lookup"><span data-stu-id="794fa-180">✅ **DO** introduce new user-defined types to indicate that a given   base type should only be used in a very particular sense.</span></span>

  <span data-ttu-id="794fa-181">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-181">*Examples:*</span></span>
  - <span data-ttu-id="794fa-182">Özellikle, klasik verileri bir hisse kaydına kodlayan bir işlem olarak yorumlanan bir işlem, Kullanıcı tanımlı bir türle `newtype InputEncoder = (Apply : (Qubit[] => Unit))`etiketlemek için uygun olabilir.</span><span class="sxs-lookup"><span data-stu-id="794fa-182">An operation that should be interpreted specifically as an   operation that encodes classical data into a quantum   register may be appropriate to label with a user-defined   type `newtype InputEncoder = (Apply : (Qubit[] => Unit))`.</span></span>

- <span data-ttu-id="794fa-183">✅Sonraki genişletilebilirliğe izin veren adlandırılmış öğelerle Yeni Kullanıcı tanımlı türler (ör.: gelecekte ek adlandırılmış öğeler içerebilen bir sonuç yapısı **) tanıtılmalıdır** .</span><span class="sxs-lookup"><span data-stu-id="794fa-183">✅ **DO** introduce new user-defined types with named items that   allow for future extensibility (e.g.: a results structure that   may contain additional named items in the future).</span></span>

  <span data-ttu-id="794fa-184">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-184">*Examples:*</span></span>
  - <span data-ttu-id="794fa-185">Bir işlem `TrainModel` çok sayıda yapılandırma seçeneği kullanıma sunarsa, bu seçeneklerin yeni `TrainingOptions` bir udt olarak kullanıma sunulmasına ve yeni bir işlev `DefaultTrainingOptions : Unit -> TrainingOptions` sağlamaya yönelik olarak, kitaplık geliştiricilerinin uygun şekilde yeni udt öğeleri eklemesine Izin verirken, kullanıcıların traıningoptions udt değerlerinde belirli adlandırılmış öğeleri geçersiz kılmasına izin verir.</span><span class="sxs-lookup"><span data-stu-id="794fa-185">When an operation `TrainModel` exposes a large number of   configuration options, exposing these options as a new   `TrainingOptions` UDT and providing a new function   `DefaultTrainingOptions : Unit -> TrainingOptions` allows   users to override specific named items in TrainingOptions   UDT values while still allowing library developers to add   new UDT items as appropriate.</span></span>

- <span data-ttu-id="794fa-186">✅**DO** Kullanıcı tanımlı yeni türler için adlandırılmış öğeleri, kullanıcıların doğru demet oluşturmayı bilmesini gerektirmek için tercih edin.</span><span class="sxs-lookup"><span data-stu-id="794fa-186">✅ **DO** declare named items for new user-defined types in   preference to requiring users to know the correct tuple   deconstruction.</span></span>

  <span data-ttu-id="794fa-187">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-187">*Examples:*</span></span>
  - <span data-ttu-id="794fa-188">Kutupsal ayrıştırma içinde karmaşık bir sayıyı temsil ettiğinizde, tercih `newtype ComplexPolar = (Magnitude: Double, Argument: Double)` edilir. `newtype ComplexPolar = (Double, Double)`</span><span class="sxs-lookup"><span data-stu-id="794fa-188">When representing a complex number in its polar   decomposition, prefer   `newtype ComplexPolar = (Magnitude: Double, Argument: Double)` to   `newtype ComplexPolar = (Double, Double)`.</span></span>

<span data-ttu-id="794fa-189">**Anahtar ilkesi:** bilişsel yükün azaltılması ve kullanıcının ek kavramlar ve terminoloji öğrenmesini gerektirmeyen yollarla Kullanıcı tanımlı türleri kullanın.</span><span class="sxs-lookup"><span data-stu-id="794fa-189">**Key principle:** use user-defined types in ways reduce  cognitive load and that don't require the user to learn additional concepts and nomenclature.</span></span>

- <span data-ttu-id="794fa-190">⛔️ **,** kullanıcının bir unsarmadan işlecini (`!`) sık kullanmasını gerektiren ya da genellikle birden çok düzey sarmalama düzeyi gerektiren Kullanıcı tanımlı türler sunmaz.</span><span class="sxs-lookup"><span data-stu-id="794fa-190">⛔️ **DON'T** introduce user-defined types that require the user to make frequent use of the unwrap operator (`!`), or that commonly require multiple levels of unwrapping.</span></span> <span data-ttu-id="794fa-191">Olası risk azaltma stratejileri şunlardır:</span><span class="sxs-lookup"><span data-stu-id="794fa-191">Possible mitigation strategies include:</span></span>

  - <span data-ttu-id="794fa-192">Kullanıcı tanımlı bir türü tek bir öğe ile kullanıma sunmadığında, bu öğe için bir ad tanımlamayı göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="794fa-192">When exposing a user-defined type with a single item, consider defining a name for that item.</span></span> <span data-ttu-id="794fa-193">Örneğin, tercih edin `newtype Encoder = (Apply : (Qubit[] => Unit is Adj + Ctl))` `newtype Encoder = (Qubit[] => Unit is Adj + Ctl)`.</span><span class="sxs-lookup"><span data-stu-id="794fa-193">For instance, consider `newtype Encoder = (Apply : (Qubit[] => Unit is Adj + Ctl))` in preference to `newtype Encoder = (Qubit[] => Unit is Adj + Ctl)`.</span></span>

  - <span data-ttu-id="794fa-194">Diğer işlevlerin ve işlemlerin "sarmalanmış" UDT örneklerini doğrudan kabul edebilmesini sağlama.</span><span class="sxs-lookup"><span data-stu-id="794fa-194">Ensuring that other functions and operations can accept   "wrapped" UDT instances directly.</span></span>

- <span data-ttu-id="794fa-195">⛔️ **,** ek ifade sağlamadan yerleşik türleri yinelenen yeni kullanıcı tanımlı türler sunmaz.</span><span class="sxs-lookup"><span data-stu-id="794fa-195">⛔️ **DON'T** introduce new user-defined types that duplicate   built-in types without providing additional expressiveness.</span></span>

  <span data-ttu-id="794fa-196">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-196">*Examples:*</span></span>
  - <span data-ttu-id="794fa-197">Bir UDT `newtype QubitRegister = Qubit[]` `Qubit[]`, daha fazla ifade sunmaz ve bu nedenle, hiç bir avantaj olmadan kullanımı zorlaştırır.</span><span class="sxs-lookup"><span data-stu-id="794fa-197">A UDT `newtype QubitRegister = Qubit[]` provides no   additional expressiveness over `Qubit[]`, and is thus harder   to use with no discernable benefit.</span></span>
  - <span data-ttu-id="794fa-198">Bir UDT `newtype LittleEndian = Qubit[]` , temel kaydın nasıl kullanılacağını ve yorumlanması gerektiğini belgelemektedir ve bu nedenle temel türü üzerinde ek ifade sağlar.</span><span class="sxs-lookup"><span data-stu-id="794fa-198">A UDT `newtype LittleEndian = Qubit[]` documents how the   underlying register is to be used and interpreted, and thus   provides additional expressiveness over its base type.</span></span>

- <span data-ttu-id="794fa-199">⛔️ **,** kesinlikle gerekli olmadığı takdirde erişimci işlevleri sunmaz;   Bu durumda adlandırılmış öğeleri kesin olarak tercih edin.</span><span class="sxs-lookup"><span data-stu-id="794fa-199">⛔️ **DON'T** introduce accessor functions unless strictly required;   strongly prefer named items in this case.</span></span>

  <span data-ttu-id="794fa-200">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-200">*Examples:*</span></span>
  - <span data-ttu-id="794fa-201">Bir UDT `newtype Complex = (Double, Double)`'ye `newtype Complex = (Real : Double, Imag : Double)` giriş yaparken, işlevleri ve `GetReal : Complex -> Double` `GetImag : Complex -> Double`işlevlerine giriş yapmak için tanımını değiştirmeyi tercih edin.</span><span class="sxs-lookup"><span data-stu-id="794fa-201">When introducing a UDT `newtype Complex = (Double, Double)`,   prefer modifying the definition to   `newtype Complex = (Real : Double, Imag : Double)` to introducing   functions `GetReal : Complex -> Double` and   `GetImag : Complex -> Double`.</span></span>

## <a name="namespaces-and-organization"></a><span data-ttu-id="794fa-202">Ad alanları ve kuruluş</span><span class="sxs-lookup"><span data-stu-id="794fa-202">Namespaces and Organization</span></span>

<span data-ttu-id="794fa-203">**Anahtar ilkesi:** her bir ad alanındaki işlevlerin, işlemlerin ve Kullanıcı tanımlı türlerin amacını açıkça ileten, tahmin edilen ve ad alanı adlarını seçin.</span><span class="sxs-lookup"><span data-stu-id="794fa-203">**Key principle:** choose namespace names that are predictable and that clearly communicate the purpose of functions, operations, and user-defined types in each namespace.</span></span>

- <span data-ttu-id="794fa-204">✅**Ad alanlarını olarak** `Publisher.Product.DomainArea`adlandırın.</span><span class="sxs-lookup"><span data-stu-id="794fa-204">✅ **DO** name namespaces as `Publisher.Product.DomainArea`.</span></span>

  <span data-ttu-id="794fa-205">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-205">*Examples:*</span></span>
  - <span data-ttu-id="794fa-206">Hisse geliştirme seti 'nin hisse bir parçası olarak Microsoft tarafından yayımlanan işlevler, işlemler ve UDTs 'ler `Microsoft.Quantum.Simulation` ad alanına yerleştirilir.</span><span class="sxs-lookup"><span data-stu-id="794fa-206">Functions, operations, and UDTs published by Microsoft as a   part of the quantum simulation feature of the Quantum   Development Kit are placed in the   `Microsoft.Quantum.Simulation` namespace.</span></span>
  - <span data-ttu-id="794fa-207">`Microsoft.Quantum.Math`Microsoft tarafından, matematik etki alanı alanıyla ilgili olan hisse geliştirme setinin bir parçası olarak yayımlanan bir ad alanını temsil eder.</span><span class="sxs-lookup"><span data-stu-id="794fa-207">`Microsoft.Quantum.Math` represents a namespace   published by Microsoft as part of the Quantum Development   Kit pertaining to the mathematics domain area.</span></span>

- <span data-ttu-id="794fa-208">✅Belirli işlevler için kullanılan işlemler, işlevler ve Kullanıcı tanımlı türler, bu işlevselliği farklı sorun etki alanlarında kullanıldığında bile bu işlevselliği açıklayan bir ad **alanına yerleştirir.**</span><span class="sxs-lookup"><span data-stu-id="794fa-208">✅ **DO** place operations, functions, and user-defined types used   for specific functionality into a namespace that describes that   functionality, even when that functionality is used across   different problem domains.</span></span>

  <span data-ttu-id="794fa-209">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-209">*Examples:*</span></span>
  - <span data-ttu-id="794fa-210">Microsoft tarafından, hisse alım geliştirme seti 'nin bir parçası olarak yayımlanan durum hazırlama API 'Leri içine `Microsoft.Quantum.Preparation`yerleştirilir.</span><span class="sxs-lookup"><span data-stu-id="794fa-210">State preparation APIs published by Microsoft as a part of   the Quantum Development Kit would be placed into   `Microsoft.Quantum.Preparation`.</span></span>
  - <span data-ttu-id="794fa-211">Hisse geliştirme setinin bir parçası olarak Microsoft tarafından yayımlanan hisse simülasyonu API 'Leri içine `Microsoft.Quantum.Simulation`yerleştirilir.</span><span class="sxs-lookup"><span data-stu-id="794fa-211">Quantum simulation APIs published by Microsoft as a part of the Quantum   Development Kit would be placed into   `Microsoft.Quantum.Simulation`.</span></span>

- <span data-ttu-id="794fa-212">✅Yalnızca belirli etki alanlarında kullanılan işlemler, işlevler ve Kullanıcı tanımlı türler, yardımcı programı etki alanlarını gösteren ad **alanlarına yerleştirir.**</span><span class="sxs-lookup"><span data-stu-id="794fa-212">✅ **DO** place operations, functions, and user-defined types used only within specific domains into namespaces indicating their domain of utility.</span></span> <span data-ttu-id="794fa-213">Gerekirse, etki alanına özgü her ad alanı içinde odaklanmış görevleri belirtmek için alt ad alanlarını kullanın.</span><span class="sxs-lookup"><span data-stu-id="794fa-213">If needed, use subnamespaces to indicate focused tasks within each domain-specific namespace.</span></span>

  <span data-ttu-id="794fa-214">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-214">*Examples:*</span></span>
  - <span data-ttu-id="794fa-215">Microsoft tarafından yayımlanan hisse makine öğrenimi kitaplığı, büyük ölçüde @"microsoft.quantum.machinelearning" ad alanına yerleştirildi, ancak örnek veri kümeleri @"microsoft.quantum.machinelearning.datasets" ad alanı tarafından sağlanır.</span><span class="sxs-lookup"><span data-stu-id="794fa-215">The quantum machine learning library published by Microsoft is largely   placed into the @"microsoft.quantum.machinelearning" namespace, but example   datasets are provided by the @"microsoft.quantum.machinelearning.datasets"   namespace.</span></span>
  - <span data-ttu-id="794fa-216">Hisse uygun olarak Microsoft tarafından yayınlanan hisse uyumlu API 'Leri, hisse geliştirme seti 'nin bir parçası olarak içine `Microsoft.Quantum.Chemistry`yerleştirilmelidir.</span><span class="sxs-lookup"><span data-stu-id="794fa-216">Quantum chemistry APIs published by Microsoft as a part of the Quantum Development Kit should be placed into `Microsoft.Quantum.Chemistry`.</span></span> <span data-ttu-id="794fa-217">Ürdün--Wigner ayrıştırma işlevinin uygulamaya özgü işlevselliği ' de `Microsoft.Quantum.Chemistry.JordanWigner`yerleştirilebilecek ve bu sayede hisse dili Mistry etki alanı alanının birincil arabiriminin uygulamalarla ilgilenmemesi sağlanır.</span><span class="sxs-lookup"><span data-stu-id="794fa-217">Functionality specific to implementing the Jordan--Wigner decomposition may be placed in `Microsoft.Quantum.Chemistry.JordanWigner`, so that the primary interface for the quantum chemistry domain area is not concerned with implementations.</span></span>

<span data-ttu-id="794fa-218">**Anahtar ilkesi:** Kullanıcılara sunulan API yüzeyine bilerek yönelik olarak ad alanlarını ve erişim değiştiricilerini kullanın ve API 'lerinizi uygulamayla ve test etme ile ilgili dahili ayrıntıları gizleyin.</span><span class="sxs-lookup"><span data-stu-id="794fa-218">**Key principle:** Use namespaces and access modifiers together to be intentional about the API surface exposed to users, and to hide internal details related to implementation and testing of your APIs.</span></span>

- <span data-ttu-id="794fa-219">✅Makul her durumda **, uygulanan** API ile aynı ad ALANıNA bir API uygulamak için gereken tüm işlevleri ve işlemleri, ancak bir kitaplık IÇIN genel API yüzeyinin bir parçası olmadığını belirtmek için "özel" veya "iç" anahtar sözcükleriyle işaretlenir.</span><span class="sxs-lookup"><span data-stu-id="794fa-219">✅ Whenever reasonable, **DO** place all functions and operations needed to implement an API into the same namespace as the API being implemented, but marked with the "private" or "internal" keywords to indicate that they are not part of the public API surface for a library.</span></span> <span data-ttu-id="794fa-220">Özel ve iç işlemleri ve işlevleri ortak callables 'den görsel olarak ayırt etmek için alt çizgi (`_`) ile başlayan bir ad kullanın.</span><span class="sxs-lookup"><span data-stu-id="794fa-220">Use a name beginning with an underscore (`_`) to visually distinguish private and internal operations and functions from public callables.</span></span>

  <span data-ttu-id="794fa-221">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-221">*Examples:*</span></span>
  - <span data-ttu-id="794fa-222">İşlem adı `_Features` , belirli bir ad alanı ve derleme için özel bir işlevi belirtir ve `internal` anahtar kelimesiyle birlikte gelmelidir.</span><span class="sxs-lookup"><span data-stu-id="794fa-222">The operation name `_Features` indicates a function that is   private to a given namespace and assembly, and should be   accompanied by either the `internal` keyword.</span></span>

- <span data-ttu-id="794fa-223">✅Belirli bir ad alanı için API 'YI uygulamak üzere çok sayıda özel işlev veya işlemin gerekli olduğu nadir bir durumda, bunları uygulanan ve biten ad alanıyla eşleşen yeni bir ad **alanına yerleştirin.** `.Private`</span><span class="sxs-lookup"><span data-stu-id="794fa-223">✅ In the rare case that an extensive set of private functions or operations are needed to implement the API for a given namespace, **DO** place them in a new namespace matching the namespace being implemented and ending in `.Private`.</span></span>

- <span data-ttu-id="794fa-224">✅Tüm birim testlerini test ve bitiş altındaki ad alanıyla eşleşen ad **alanlarına yerleştirin.** `.Tests`</span><span class="sxs-lookup"><span data-stu-id="794fa-224">✅ **DO** place all unit tests into namespaces matching the     namespace under test and ending in `.Tests`.</span></span>

## <a name="naming-conventions-and-vocabulary"></a><span data-ttu-id="794fa-225">Adlandırma kuralları ve sözlük</span><span class="sxs-lookup"><span data-stu-id="794fa-225">Naming Conventions and Vocabulary</span></span>

<span data-ttu-id="794fa-226">**Anahtar ilkesi:** NET, erişilebilir ve farklı bir hedef kitle genelinde okunabilir olan adları ve terminolojiyi, hem hisse nunovıces hem de uzmanlar dahil olmak üzere seçin.</span><span class="sxs-lookup"><span data-stu-id="794fa-226">**Key principle:** Choose names and terminology that are clear, accessible, and readable across a diverse range of audiences, including both quantum novices and experts.</span></span>

- <span data-ttu-id="794fa-227">⛔️ Discriminatory veya exclusionary tanımlayıcı adlarını veya API belge açıklamalarındaki **terminolojiyi kullanmayın.**</span><span class="sxs-lookup"><span data-stu-id="794fa-227">⛔️ **DON'T** use discriminatory or exclusionary identifier names,   nor terminology in API documentation comments.</span></span>

- <span data-ttu-id="794fa-228">✅Özellikle daha zor kavramlar için ilgili bağlamı, örnekleri ve başvuruları sağlamak üzere API belge **açıklamalarını kullanın.**</span><span class="sxs-lookup"><span data-stu-id="794fa-228">✅ **DO** use API documentation comments to provide relevant   context, examples, and references, especially for more difficult   concepts.</span></span>

- <span data-ttu-id="794fa-229">⛔️ gereksiz esoteric olan veya okumak için önemli hisse algoritmaları bilgisi gerektiren tanımlayıcı **adlarını kullanmayın.**</span><span class="sxs-lookup"><span data-stu-id="794fa-229">⛔️ **DON'T** use identifier names that are unnecessarily esoteric,   or that require significant quantum algorithms knowledge to   read.</span></span>

  <span data-ttu-id="794fa-230">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-230">*Examples:*</span></span>
  - <span data-ttu-id="794fa-231">"Genver yineleme" olarak "genonu yineleme" olarak tercih edin.</span><span class="sxs-lookup"><span data-stu-id="794fa-231">Prefer "amplitude amplification iteration" to "Grover   iteration."</span></span>

- <span data-ttu-id="794fa-232">✅Bir çağrılabilir uygulamanın amaçlanan etkisini açıkça iletişim kuran işlemler ve işlev adları ' **nı seçin.**</span><span class="sxs-lookup"><span data-stu-id="794fa-232">✅ **DO** choose operations and function names that clearly communicate the intended effect of a callable, and not its implementation.</span></span> <span data-ttu-id="794fa-233">Uygulamanın [API belge açıklamalarında](xref:microsoft.quantum.language.statements#documentation-comments)ve belgelendiğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="794fa-233">Note that the implementation can and should be documented in [API documentation comments](xref:microsoft.quantum.language.statements#documentation-comments).</span></span>

  <span data-ttu-id="794fa-234">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-234">*Examples:*</span></span>
  - <span data-ttu-id="794fa-235">"Hadamard test" için "tahmini örtüşme" yı tercih edin, ikincisi ise eski 'ın nasıl uygulandığını iletir.</span><span class="sxs-lookup"><span data-stu-id="794fa-235">Prefer "estimate overlap" to "Hadamard test," as the latter   communicates how the former is implemented.</span></span>

- <span data-ttu-id="794fa-236">✅Tüm Q\# API 'lerinde tutarlı bir biçimde **sözcükler kullanın:**</span><span class="sxs-lookup"><span data-stu-id="794fa-236">✅ **DO** use words in a consistent fashion across all Q\# APIs:</span></span>

  - <span data-ttu-id="794fa-237">**Eylemlerinin**</span><span class="sxs-lookup"><span data-stu-id="794fa-237">**Verbs:**</span></span>

    - <span data-ttu-id="794fa-238">Onay **: büyük**olasılıkla fiziksel olmayan kaynakları kullanarak bir hedef makinenin ve qubits 'in durumu hakkında bir varsayım olduğunu denetleyin.</span><span class="sxs-lookup"><span data-stu-id="794fa-238">**Assert**: Check that an assumption about the state of a target machine and its qubits holds, possibly by using unphysical resources.</span></span> <span data-ttu-id="794fa-239">Bu fiili kullanan işlemler, kitaplıkların ve yürütülebilir programların işlevselliğini etkilemeden her zaman güvenli bir şekilde kaldırılabilir.</span><span class="sxs-lookup"><span data-stu-id="794fa-239">Operations using this verb should always be safely removable without affecting the functionality of libraries and executable programs.</span></span> <span data-ttu-id="794fa-240">Olguların aksine, genel olarak, bir qubit kayıt durumu, yürütme ortamı veya benzeri bir durum gibi, genel olarak, onaylar genel olarak değişebilir.</span><span class="sxs-lookup"><span data-stu-id="794fa-240">Note that unlike facts, assertions may in general depend on external state, such as the state of a qubit register, the execution environment or so forth.</span></span> <span data-ttu-id="794fa-241">Dış durum bağımlılığı bir tür yan etkildir, ancak onaylar işlevler yerine işlemler olarak gösterilmelidir.</span><span class="sxs-lookup"><span data-stu-id="794fa-241">As dependency on external state is a kind of side effect, assertions must be exposed as operations rather than functions.</span></span>

    - <span data-ttu-id="794fa-242">**Tahmin**: bir veya daha fazla tekrarlanmış ölçüm kullanarak, ölçüm sonuçlarından bir klasik miktarı tahmin edin.</span><span class="sxs-lookup"><span data-stu-id="794fa-242">**Estimate**: Using one or more possibly repeated   measurements, estimate a classical quantity from   measurement results.</span></span>

      <span data-ttu-id="794fa-243">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-243">*Examples:*</span></span>
      - @"microsoft.quantum.characterization.estimatefrequency"
      - @"microsoft.quantum.characterization.estimateoverlapbetweenstates"

    - <span data-ttu-id="794fa-244">**Hazırlama**: belirli bir başlangıç durumunda (genellikle $ \ket{00\cnoktalar 0} $) başlayan bir veya daha fazla qubits 'e bir hisse veya işlem dizisi uygulayın, bu qubits 'in durumunun istenen bir bitiş durumuna gelişmesine neden olur.</span><span class="sxs-lookup"><span data-stu-id="794fa-244">**Prepare**: Apply a quantum operation or sequence of operations to one or more qubits assumed to start in a particular initial state (typically $\ket{00\cdots 0}$), causing the state of those qubits to evolve to a desired end state.</span></span> <span data-ttu-id="794fa-245">Genel olarak, verili **başlangıç durumundan farklı** durumlara göre işlem, tanımsız bir Unitary dönüştürmesi ile sonuçlanabilir, ancak yine de bir işlemin ve kendi adjoint "iptal etmeyi" ve hiçbir op **uygulamamalıdır** .</span><span class="sxs-lookup"><span data-stu-id="794fa-245">In general, acting on states other than the given starting state **MAY** result in an undefined unitary transformation, but **SHOULD** still preserve that an operation and its adjoint "cancel out" and apply a no-op.</span></span>

      <span data-ttu-id="794fa-246">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-246">*Examples:*</span></span>
      - @"microsoft.quantum.preparation.preparearbitrarystate"
      - @"microsoft.quantum.preparation.prepareuniformsuperposition"

    - <span data-ttu-id="794fa-247">**Measure**: bir veya daha fazla qubits 'e bir hisse veya işlem dizisi uygulayarak klasik veri geri alma işlemini okuyun.</span><span class="sxs-lookup"><span data-stu-id="794fa-247">**Measure**: Apply a quantum operation or sequence of   operations to one or more qubits, reading classical data   back out.</span></span>

      <span data-ttu-id="794fa-248">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-248">*Examples:*</span></span>
      - @"microsoft.quantum.intrinsic.measure"
      - @"microsoft.quantum.arithmetic.measurefxp"
      - @"microsoft.quantum.arithmetic.measureinteger"

    - <span data-ttu-id="794fa-249">**Uygula**: bir veya daha fazla qubits 'e hisse veya işlem dizisi uygulayın ve bu qubits 'in durumunun tutarlı bir şekilde değişmesine neden olur.</span><span class="sxs-lookup"><span data-stu-id="794fa-249">**Apply**: Apply a quantum operation or sequence of operations to one or more qubits, causing the state of those qubits to change in a coherent fashion.</span></span> <span data-ttu-id="794fa-250">Bu fiil, Q\# terminolojinin en genel fiildir ve daha belirli bir fiil daha doğrudan ilgili olduğunda kullanılmamalıdır. **SHOULD NOT BE**</span><span class="sxs-lookup"><span data-stu-id="794fa-250">This verb is the most general verb in Q\# nomenclature, and **SHOULD NOT BE** used when a more specific verb is more directly relevant.</span></span>

  - <span data-ttu-id="794fa-251">**İsimler**:</span><span class="sxs-lookup"><span data-stu-id="794fa-251">**Nouns**:</span></span>

    - <span data-ttu-id="794fa-252">**Olgu**: bir hedef makinenin, ortamının veya makine qubits 'in durumunda değil, yalnızca kendi girdilerine bağlı olan bir Boolean koşulu.</span><span class="sxs-lookup"><span data-stu-id="794fa-252">**Fact**: A Boolean condition which depends only on its inputs and not on the state of a target machine, its environment, or the state of the machine's qubits.</span></span> <span data-ttu-id="794fa-253">Bir onaylama işlemi aksine, olgu yalnızca söz konusu olgusuna belirtilen *değerlere* duyarlıdır.</span><span class="sxs-lookup"><span data-stu-id="794fa-253">By contrast with an assertion, a fact is only sensitive to the *values* provided to that fact.</span></span> <span data-ttu-id="794fa-254">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="794fa-254">For example:</span></span>

      <span data-ttu-id="794fa-255">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-255">*Examples:*</span></span>
      - <span data-ttu-id="794fa-256">@"microsoft.quantum.diagnostics.equalityfacti": iki tamsayı girişi hakkında bir eşitlik olgusu temsil eder; giriş olarak girilen tamsayılar birbirlerine eşittir ya da başka bir program durumundan bağımsız olarak değildir.</span><span class="sxs-lookup"><span data-stu-id="794fa-256">@"microsoft.quantum.diagnostics.equalityfacti": represents an equality fact about two integer inputs; either the integers provided as input are equal to each other, or they are not, independent of any other program state.</span></span>

    - <span data-ttu-id="794fa-257">**Seçenekler:** Bir işlev veya işleme "isteğe bağlı bağımsız değişkenler" gibi davranan, birkaç adlandırılmış öğe içeren bir UDT.</span><span class="sxs-lookup"><span data-stu-id="794fa-257">**Options:** A UDT containing several named items that can act as "optional arguments" to a function or operation.</span></span> <span data-ttu-id="794fa-258">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="794fa-258">For example:</span></span>

      <span data-ttu-id="794fa-259">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-259">*Examples:*</span></span>
      - <span data-ttu-id="794fa-260">@"microsoft.quantum.machinelearning.trainingoptions" Udt, öğrenme oranı, Mini toplu iş boyutu ve ml eğitimi için diğer yapılandırılabilir parametreler için adlandırılmış öğeler içerir.</span><span class="sxs-lookup"><span data-stu-id="794fa-260">The @"microsoft.quantum.machinelearning.trainingoptions" UDT includes named items for learning rate, minibatch size, and other configurable parameters for ML training.</span></span>

  - <span data-ttu-id="794fa-261">**Sıfatlar**:</span><span class="sxs-lookup"><span data-stu-id="794fa-261">**Adjectives**:</span></span>

    - <span data-ttu-id="794fa-262">**yeni**⛔️: Bu sıfatıcı, birçok programlama dilinde (ör.: C++, C#, Java, TypeScript, PowerShell), kullanımıyla ilgili bir fiil olarak karışıklık oluşmasını önlemek **için kullanılmamalıdır.**</span><span class="sxs-lookup"><span data-stu-id="794fa-262">⛔️ **New**: This adjective **SHOULD NOT** be used, as to avoid confusion   with its usage as a verb in many   programming languages (e.g.: C++, C#, Java, TypeScript, PowerShell).</span></span>

  - <span data-ttu-id="794fa-263">**Ön pozisyonlar:** Bazı durumlarda, işlev ve işlem adlarında isimler ve fiillerin rollerini daha fazla netleştirmek veya netleştirmek için ön pozisyonlar kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="794fa-263">**Prepositions:** In some cases, prepositions can be used to further disambiguate or clarify the roles of nouns and verbs in function and operation names.</span></span> <span data-ttu-id="794fa-264">Bununla birlikte, dikkatli ve tutarlı şekilde yapılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="794fa-264">Care should be taken to do so sparingly and consistently, however.</span></span>

    - <span data-ttu-id="794fa-265">**Şöyle:** Bir işlevin giriş ve çıktısının aynı bilgileri temsil ettiğini, ancak çıktının özgün temsili yerine bu bilgileri bir *X* **olarak** temsil ettiğini temsil eder.</span><span class="sxs-lookup"><span data-stu-id="794fa-265">**As:** Represents that a function's input and output represent the same information, but that the output represents that information **as** an *X* instead of its original representation.</span></span> <span data-ttu-id="794fa-266">Bu özellikle tür dönüştürme işlevleri için ortaktır.</span><span class="sxs-lookup"><span data-stu-id="794fa-266">This is especially common for type conversion functions.</span></span>

      <span data-ttu-id="794fa-267">*Örnekler*</span><span class="sxs-lookup"><span data-stu-id="794fa-267">*Examples:*</span></span>
      - <span data-ttu-id="794fa-268">`IntAsDouble(2)`hem Input (`2`) hem de Output (`2.0`) 'ın aynı bilgileri qualitatively temsil ettiğini, ancak bunu yapmak için farklı Q\# veri türlerini kullandığını gösterir.</span><span class="sxs-lookup"><span data-stu-id="794fa-268">`IntAsDouble(2)` indicates that both the input (`2`) and the output (`2.0`)   represent qualitatively the same information, but using   different Q\# data types to do so.</span></span>

    - <span data-ttu-id="794fa-269">**Kimden:** Tutarlılığı sağlamak için bu ön pozisyon, tür dönüştürme işlevlerini veya uygun **olduğu yerde başka** bir durumu belirtmek **için kullanılmamalıdır.**</span><span class="sxs-lookup"><span data-stu-id="794fa-269">**From:** To ensure consistency, this preposition   **SHOULD NOT** be used to indicate type conversion   functions or any other case where **As** is appropriate.</span></span>

    - <span data-ttu-id="794fa-270">⛔️ **:** bu ön pozisyon, birçok programlama dilinde fiil olarak kullanımıyla ilgili karışıklık olmaması **için kullanılmamalıdır.**</span><span class="sxs-lookup"><span data-stu-id="794fa-270">⛔️ **To:** This preposition **SHOULD NOT** be used, as to   avoid confusion with its usage as a verb in many   programming languages.</span></span>
